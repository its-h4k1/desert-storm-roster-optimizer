<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Desert Storm â€“ Aufstellung (Latest)</title>
  <style>
    :root{
      --fg:#111; --muted:#666; --line:#ddd;
      --ok:#1f9d55; --mid:#c9a227; --bad:#d64545;
      --bg:#fff; --bgth:#fafafa;
    }
    body{font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;margin:24px;color:var(--fg);background:var(--bg)}
    h1{margin:0 0 8px}
    h2{margin:0 0 8px}
    h3{margin:12px 0 6px;font-weight:600}
    .top-bar{display:flex;align-items:flex-start;gap:12px;flex-wrap:wrap;margin:0 0 6px}
    .top-actions{margin-left:auto;display:flex;gap:10px;align-items:flex-start;flex-wrap:wrap}
    .admin-link{display:inline-flex;align-items:center;gap:8px;padding:8px 14px;border:1px solid var(--line);border-radius:10px;text-decoration:none;color:var(--fg);background:#fff;box-shadow:0 4px 12px rgba(0,0,0,0.05);font-weight:600}
    .admin-link:hover{border-color:#c8d5ec;box-shadow:0 6px 16px rgba(0,0,0,0.08)}
    .admin-link:active{transform:translateY(1px)}
    .stamp{display:block;font-size:0.8em;line-height:1.4;margin-top:4px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:24px}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left;vertical-align:top}
    th{background:var(--bgth)}
    .muted{color:var(--muted)}
    .num{font-variant-numeric:tabular-nums}
    .counts{font-size:.9em;color:var(--muted);font-weight:400;margin-left:.25rem}
    .chip{display:inline-block;min-width:52px;text-align:right;padding:2px 8px;border-radius:999px;border:1px solid var(--line)}
    .chip.ns-neutral{background:#f6f7f8;border:1px solid #ccc;color:#555}
    .ns-ok{border-color:#bfe8cc;background:#f3fbf6}
    .ns-mid{background:#fff9e6;border:1px solid #f3d78a}
    .ns-bad{border-color:#f2b7b7;background:#fff5f5}
    .sub{margin:6px 0 18px}
    .wrap{display:grid;grid-template-columns:1fr;gap:28px}
    @media (min-width: 960px){ .wrap{grid-template-columns:1fr 1fr} }
    .tag{display:inline-block;margin-left:6px;padding:2px 7px;border-radius:999px;font-size:0.72em;font-weight:600;vertical-align:middle}
    .tag-nd{background:var(--bad);color:#fff}
    .tag-low{background:#f1e1a8;color:#111}
    .tag-event{background:#ecfeff;border:1px solid #a5f3fc;color:#0f172a}
    .tag-hard{background:#fee2e2;border:1px solid #fecdd3;color:#7f1d1d}
    .tag-fix{background:#f5f5f5;border:1px solid #d4d4d8;color:#3f3f46;display:inline-flex;align-items:center;gap:4px;letter-spacing:0.01em}
    .tag-callup{background:#eff6ff;border:1px solid #bfdbfe;color:#1d4ed8;display:inline-flex;align-items:center;gap:4px;letter-spacing:0.01em;font-weight:600}
    .legend{font-size:0.85em;margin:32px 0 0}
    .legend + .legend{margin-top:6px}
    .roster-controls{margin:12px 0 20px}
    .player-meta-toggle{font-size:0.9em;color:var(--fg);display:inline-flex;align-items:center;gap:8px;cursor:pointer;user-select:none}
    .player-meta-toggle input{width:16px;height:16px}
    .player-name-row{font-size:14px;font-weight:600}
    .player-meta-row{font-size:11px;color:#777;margin-top:2px;display:none}
    .show-player-meta .player-meta-row{display:block}
    .hide-callups .callup-badge{display:none}
    #absences{margin-top:48px;padding-top:24px;border-top:1px solid var(--line)}
    #absences h2{margin:0 0 8px}
    #absences .absences-empty{color:var(--muted);margin:0}
    #absences table{margin-top:12px}
    .absences-roster-badge{display:inline-block;margin-left:6px;padding:2px 8px;border-radius:999px;border:1px solid var(--line);font-size:0.75em;color:var(--muted);background:var(--bgth)}
    .absences-error{color:#b00}
    .extra-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px;margin-top:8px}
    .extra-card{border:1px solid var(--line);border-radius:10px;padding:10px;background:var(--bgth)}
    .extra-card h3{margin:0 0 6px}
    .extra-list{list-style:none;padding:0;margin:0;display:grid;gap:6px}
    .extra-meta{color:var(--muted);font-size:0.85em}
    .diag{margin:10px 0 0;padding:10px;border-radius:10px;border:1px solid var(--line);background:#fff}
    .diag h4{margin:0 0 6px;font-size:1em}
    .diag ul{margin:0;padding-left:20px;color:#444}
    .diag .warn{color:#7f1d1d;font-weight:600}
    #extras{margin-top:48px;padding-top:24px;border-top:1px solid var(--line)}
    #extras h2{margin-top:0}
    #signup-inline{display:none;margin-top:8px}
  </style>
</head>
<body>
  <div class="top-bar">
    <h1>Desert Storm â€“ Aufstellung <span id="stamp" class="muted stamp"></span></h1>
    <div class="top-actions">
      <a class="admin-link" href="admin/index.html">Admin &amp; Tools</a>
    </div>
  </div>
  <p class="muted" id="sort-note" style="margin:0 0 18px"></p>

  <div class="roster-controls">
    <label class="player-meta-toggle">
      <input type="checkbox" id="player-meta-toggle" />
      Detailzeile pro Spieler anzeigen
    </label>
    <label class="player-meta-toggle">
      <input type="checkbox" id="callup-toggle" checked />
      Callup-Empfehlungen anzeigen
    </label>
  </div>

  <p class="muted" id="callup-note" style="margin:0 0 18px; display:none"></p>

  <div id="roster-root" class="grid">
    <section id="A-Start">
      <h2>Gruppe A Â· Start</h2>
      <table>
        <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
    <section id="A-Ersatz">
      <h2>Gruppe A Â· Ersatz</h2>
      <table>
        <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
    <section id="B-Start">
      <h2>Gruppe B Â· Start</h2>
      <table>
        <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
    <section id="B-Ersatz">
      <h2>Gruppe B Â· Ersatz</h2>
      <table>
        <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
  </div>

  <section id="extras">
    <h2>ZusÃ¤tzliche Zusagen (Pool nÃ¤chstes Event)</h2>
    <p class="muted" id="extra-note">LÃ¤dt Zusagen â€¦</p>
    <div id="forced-diagnostics" class="diag"></div>
    <div id="extra-root" class="extra-grid"></div>
  </section>

  <p class="muted legend">Legende: <span class="tag tag-nd" title="Keine Historie â€“ events_seen = 0">No&nbsp;Data</span> keine Historie Â· <span class="tag tag-low" title="Wenig Historie â€“ events_seen âˆˆ {1,2}">low&nbsp;n</span> wenig Historie Â· <span class="tag tag-fix">ðŸ”’ verbindlich</span> verbindliche Zusage (Commitment=hard) Â· <span class="tag tag-callup callup-badge">ðŸ”” Callup empfohlen</span> Spieler, fÃ¼r die eine Erinnerung empfohlen wird<br />Farben basieren auf Historie (rollingâ†’overall), EB wird nur zur Sortierung verwendet.<br />No-Data = nie teilgenommen (grau). low-n â‰¤2 = gelb. 1 Fehltermin = nie rot.</p>
  <p class="muted legend" id="signup-inline"></p>

  <section id="absences">
    <h2>Absenzen</h2>
    <div id="absences-content" class="muted">Wird geladen â€¦</div>
  </section>

  <p class="sub muted">Quelle: <code>out/latest.json</code> (GitHub)</p>

  <script src="shared.js"></script>
  <script>
    // Quelle (mit Cache-Buster)
    const url = new URL(location.href);
    const branchOverride = url.searchParams.get('branch');
    const branch = branchOverride || 'main';
    const cacheBuster = `?v=${Date.now()}`;
    const SITE_ROOT = dsroShared.computeSiteRoot(location.pathname || '/');
    const LATEST_JSON_URL = dsroShared.buildLatestJsonUrl({ branchOverride, cacheBuster, siteRoot: SITE_ROOT });
    const canonicalNameJS = dsroShared.canonicalNameJS;
    const escapeHtml = dsroShared.escapeHtml;
    // Main roster UI expects latest.json at: docs/out/latest.json (served as out/latest.json on GitHub Pages).
    const ABSENCES_RAW = `https://raw.githubusercontent.com/its-h4k1/desert-storm-roster-optimizer/${branch}/data/absences.csv${cacheBuster}`;

    // Konfiguration: Prior-Defaults (werden durch schema.prior Ã¼berschrieben)
    const DEFAULT_PRIOR_FALLBACK = 0.18;
    const DEFAULT_PRIOR_PAD = 0.02;
    const EPS = 1e-12;

    const state = {
      showPlayerMeta: false,
      showCallups: true,
      absences: { entries: [], active: [], error: null, loading: true },
      playersByCanon: {},
      forcedDiagnostics: { forced: [], invalid: [], overbooked: [] },
      callupMeta: { available: false, recommendedTotal: null, reasonCounts: {}, fromStats: false },
    };
    const rosterRoot = document.getElementById("roster-root");
    const playerMetaToggle = document.getElementById("player-meta-toggle");
    const callupToggle = document.getElementById("callup-toggle");
    const callupNote = document.getElementById("callup-note");
    const absencesContainer = document.getElementById("absences-content");
    const extraRoot = document.getElementById("extra-root");
    const extraNote = document.getElementById("extra-note");
    const signupInline = document.getElementById("signup-inline");
    if (playerMetaToggle) {
      state.showPlayerMeta = Boolean(playerMetaToggle.checked);
      playerMetaToggle.addEventListener("change", (event) => {
        state.showPlayerMeta = event.target.checked;
        if (rosterRoot) {
          rosterRoot.classList.toggle("show-player-meta", state.showPlayerMeta);
        }
      });
    }
    if (callupToggle) {
      state.showCallups = Boolean(callupToggle.checked);
      callupToggle.addEventListener("change", (event) => {
        state.showCallups = event.target.checked;
        if (rosterRoot) {
          rosterRoot.classList.toggle("hide-callups", !state.showCallups);
        }
        document.body.classList.toggle("hide-callups", !state.showCallups);
        updateCallupNote(state.callupMeta);
      });
    }
    if (rosterRoot) {
      rosterRoot.classList.toggle("show-player-meta", state.showPlayerMeta);
      rosterRoot.classList.toggle("hide-callups", !state.showCallups);
    }
    document.body.classList.toggle("hide-callups", !state.showCallups);
    updateCallupNote(state.callupMeta);

    // Format & Styling
    const pad = (n)=> String(n).padStart(2,"0");
    const pc  = (x)=> (x==null || isNaN(x)) ? "â€“" : (Math.round(x*1000)/10).toFixed(1)+"%";
    const BADGE_SETTINGS = {
      thresholds: {
        ok: 0.20,
        warning: 0.35,
      },
      singleMiss: {
        seenMin: 10,
        rateMax: 0.12,
      },
      lowNMax: 2,
      softenBadUntilSeen: 5,
    };
    const GREEN_TH  = BADGE_SETTINGS.thresholds.ok;
    const YELLOW_TH = BADGE_SETTINGS.thresholds.warning;
    const SINGLE_MISS_GREEN_SEEN_MIN = BADGE_SETTINGS.singleMiss.seenMin;
    const SINGLE_MISS_GREEN_RATE_MAX = BADGE_SETTINGS.singleMiss.rateMax;
    const clamp = (x)=> Math.min(1, Math.max(0, x));
    const toNumber = (v)=>{
      if (v==null) return null;
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };

    function formatCallupReasons(callup) {
      if (!callup) return "";
      const reasons = Array.isArray(callup.reasons) ? callup.reasons : [];
      const labels = reasons.map(r => {
        if (!r) return "";
        if (typeof r === "string") return r;
        return r.label || r.code || "";
      }).filter(Boolean);
      return labels.join(" Â· ");
    }

    function buildCallupBadge(callup) {
      if (!callup || !callup.recommended) return "";
      const reasonText = formatCallupReasons(callup);
      const label = reasonText || "Callup empfohlen";
      return `<span class="tag tag-callup callup-badge" title="${escapeHtml(label)}">ðŸ”” ${escapeHtml(label)}</span>`;
    }

    function extractCallupMeta(payload, playersArray, schema = {}) {
      const schemaVersion = Number.isFinite(schema.version) ? Number(schema.version) : null;
      const stats = payload && typeof payload === 'object' && payload.callup_stats && typeof payload.callup_stats === 'object'
        ? payload.callup_stats
        : null;
      const statsCountRaw = stats && Object.prototype.hasOwnProperty.call(stats, 'recommended_total')
        ? Number(stats.recommended_total)
        : null;
      const statsCount = Number.isFinite(statsCountRaw) ? statsCountRaw : null;
      const statsReasons = (stats && stats.reasons && typeof stats.reasons === 'object') ? stats.reasons : null;

      let derivedCount = 0;
      const derivedReasons = {};
      playersArray.forEach(p => {
        if (!p || typeof p !== 'object') return;
        const callup = p.callup;
        const recommended = Boolean(callup && callup.recommended === true);
        if (!recommended) return;
        derivedCount += 1;
        if (Array.isArray(callup.reasons)) {
          callup.reasons.forEach(reason => {
            if (!reason || typeof reason !== 'object') return;
            const code = String(reason.code || 'unknown');
            derivedReasons[code] = (derivedReasons[code] || 0) + 1;
          });
        }
      });

      const recommendedTotal = statsCount != null ? statsCount : derivedCount;
      const reasonCounts = statsReasons || derivedReasons;
      const available = Boolean(stats || derivedCount > 0 || playersArray.some(p => p && p.callup));

      return { available, recommendedTotal, reasonCounts, fromStats: Boolean(stats), schemaVersion };
    }

    function updateCallupNote(meta) {
      if (!callupNote) return;
      const show = state.showCallups;
      if (!show) {
        callupNote.style.display = 'none';
        return;
      }

      const available = Boolean(meta && meta.available);
      const recommendedTotal = Number.isFinite(meta?.recommendedTotal) ? Number(meta.recommendedTotal) : null;
      let text = '';
      if (!available) {
        text = 'Callup-Empfehlungen: nicht im latest.json enthalten.';
      } else if (recommendedTotal === 0) {
        text = 'Callup-Empfehlungen: keine Spieler empfohlen (laut latest.json).';
      } else if (recommendedTotal != null && recommendedTotal > 0) {
        text = `Callup-Empfehlungen: ${recommendedTotal} Spieler empfohlen.`;
      }

      if (text) {
        callupNote.textContent = text;
        callupNote.style.display = 'block';
      } else {
        callupNote.textContent = '';
        callupNote.style.display = 'none';
      }
    }

    function splitCsvLine(line) {
      const out = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (inQuotes) {
          if (char === '"') {
            if (line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            current += char;
          }
        } else if (char === '"') {
          inQuotes = true;
        } else if (char === ',') {
          out.push(current);
          current = "";
        } else {
          current += char;
        }
      }
      out.push(current);
      return out;
    }

    function parseCsv(text) {
      const cleaned = (text || "").replace(/^\ufeff/, "").split(/\r?\n/);
      const lines = cleaned.filter(line => line && line.trim().length);
      if (!lines.length) return [];
      const headers = splitCsvLine(lines.shift()).map(h => h.trim());
      return lines.map(line => {
        const cells = splitCsvLine(line);
        const obj = {};
        headers.forEach((header, idx) => {
          obj[header] = cells[idx] != null ? cells[idx].trim() : "";
        });
        return obj;
      });
    }

    function parseDateOnly(value) {
      if (!value) return null;
      const trimmed = String(value).trim();
      if (!trimmed) return null;
      const date = new Date(trimmed);
      if (Number.isNaN(date.getTime())) return null;
      return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
    }

    function parseInAllianceFlag(value) {
      if (value == null) return false;
      const normalized = String(value).trim().toLowerCase();
      // "InAlliance" kennzeichnet die Allianz-Mitgliedschaft (1 = im Roster, 0 = ausgetreten).
      return ["1","true","yes","y","aktiv","active"].includes(normalized);
    }

    function normalizeAbsenceRow(row) {
      const playerName = (row?.PlayerName ?? row?.playername ?? "").toString().trim();
      const from = (row?.From ?? row?.from ?? "").toString().trim();
      const to = (row?.To ?? row?.to ?? "").toString().trim();
      const reason = (row?.Reason ?? row?.reason ?? "").toString().trim();
      const activeFlag =
        row?.InAlliance ?? row?.inalliance ?? row?.Active ?? row?.active;
      return {
        playerName,
        canon: canonicalNameJS(playerName),
        from,
        to,
        fromDate: parseDateOnly(from),
        toDate: parseDateOnly(to),
        reason,
        inAlliance: parseInAllianceFlag(activeFlag),
      };
    }

    function todayDateUTC() {
      const now = new Date();
      return new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    }

    function computeActiveAbsences(entries) {
      const today = todayDateUTC();
      const todayMs = today.getTime();
      return entries.filter(entry => {
        if (!entry.inAlliance) {
          return false; // Nur Spieler, die noch zur Allianz gehÃ¶ren, tauchen in der Ãœbersicht auf.
        }
        if (entry.fromDate && entry.fromDate.getTime() > todayMs) {
          return false;
        }
        if (entry.toDate && entry.toDate.getTime() < todayMs) {
          return false;
        }
        return true;
      });
    }

    function formatAbsenceRange(entry) {
      const from = entry.from || "â€“";
      const to = entry.to || "â€“";
      if (!entry.from && !entry.to) return "â€“";
      return `${from} â€“ ${to}`;
    }

    function rosterBadgeFor(entry) {
      const meta = state.playersByCanon[entry.canon];
      if (!meta) return "";
      const parts = [];
      if (meta.group) parts.push(`Gruppe ${meta.group}`);
      if (meta.role) parts.push(meta.role);
      const text = parts.join(" Â· ");
      return text ? `<span class="absences-roster-badge">im Roster${text ? ` Â· ${escapeHtml(text)}` : ""}</span>` : "";
    }

    function updateAbsencesUI() {
      if (!absencesContainer) return;
      const { loading, error, active } = state.absences;
      if (loading) {
        absencesContainer.textContent = "Wird geladen â€¦";
        return;
      }
      if (error) {
        absencesContainer.innerHTML = `<p class="absences-error">Absenzen konnten nicht geladen werden (${escapeHtml(error.message || error)})</p>`;
        return;
      }
      if (!active.length) {
        absencesContainer.innerHTML = '<p class="absences-empty">Aktuell sind keine Absenzen erfasst.</p>';
        return;
      }
      const rows = active.map(entry => {
        const rosterMeta = state.playersByCanon[entry.canon];
        const label = rosterMeta?.display || entry.playerName || "Unbekannt";
        const badge = rosterBadgeFor(entry);
        return `
          <tr>
            <td>${escapeHtml(label)}${badge}</td>
            <td>${escapeHtml(formatAbsenceRange(entry))}</td>
            <td>${entry.reason ? escapeHtml(entry.reason) : "â€“"}</td>
            <td>aktiv</td>
          </tr>
        `;
      }).join("");
      absencesContainer.innerHTML = `
        <table>
          <thead>
            <tr><th>Spieler</th><th>Zeitraum</th><th>Grund</th><th>Status</th></tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;
    }

    function fetchAbsences() {
      state.absences.loading = true;
      state.absences.error = null;
      updateAbsencesUI();
      fetch(ABSENCES_RAW, { cache: "no-store" })
        .then(r => { if (!r.ok) throw new Error(r.status + " " + r.statusText); return r.text(); })
        .then(text => {
          const parsed = parseCsv(text);
          const normalized = parsed.map(normalizeAbsenceRow).filter(row => row.playerName);
          state.absences.entries = normalized;
          state.absences.active = computeActiveAbsences(normalized);
          state.absences.error = null;
        })
        .catch(err => {
          state.absences.entries = [];
          state.absences.active = [];
          state.absences.error = err;
        })
        .finally(() => {
          state.absences.loading = false;
          updateAbsencesUI();
        });
    }

    function extractSignupStats(meta) {
      const toNum = (value) => {
        const n = Number(value);
        return Number.isFinite(n) ? n : null;
      };
      if (!meta || typeof meta !== 'object') {
        return {
          source: '',
          totalEntries: null,
          hardTotal: null,
          hardApplied: null,
          hardInvalid: null,
          hardOverbooked: null,
          extraTotal: null,
          extraByGroup: null,
          missingHard: null,
          inRosterHard: null,
        };
      }
      return {
        source: meta.source || '',
        totalEntries: toNum(meta.rows_with_canon ?? meta.total_entries ?? meta.rows_with_playername ?? meta.raw_rows),
        hardTotal: toNum(meta.hard_commitments_total ?? meta.hard_commitments),
        hardApplied: toNum(meta.hard_commitments_applied),
        hardInvalid: toNum(meta.hard_commitments_invalid),
        hardOverbooked: toNum(meta.hard_commitments_overbooked),
        extraTotal: toNum(meta.extra_entries_total),
        extraByGroup: (meta.extra_entries_by_group && typeof meta.extra_entries_by_group === 'object') ? meta.extra_entries_by_group : null,
        missingHard: toNum(meta.hard_commitments_missing_from_roster),
        inRosterHard: toNum(meta.in_roster_hard_commitments),
      };
    }

    function renderExtraSignups(extraData, meta, diagnostics = {}) {
      if (!extraRoot) return;
      const groups = ['A','B'];
      const stats = extractSignupStats(meta);
      const extraCount = Number.isFinite(stats.extraTotal)
        ? Number(stats.extraTotal)
        : groups.reduce((sum, g) => sum + (Array.isArray(extraData[g]) ? extraData[g].length : 0), 0);
      const totalEntries = Number.isFinite(stats.totalEntries) ? stats.totalEntries : extraCount;
      const inRosterHard = Number.isFinite(stats.inRosterHard)
        ? stats.inRosterHard
        : (Number.isFinite(stats.hardApplied) ? stats.hardApplied : null);
      const summaryParts = [];
      if (Number.isFinite(totalEntries)) summaryParts.push(`${totalEntries} EintrÃ¤ge`);
      if (Number.isFinite(stats.hardTotal)) {
        const suffix = (inRosterHard != null) ? ` (${inRosterHard} im Roster)` : '';
        summaryParts.push(`${stats.hardTotal} verbindliche Zusagen${suffix}`);
      }
      if (!extraCount) summaryParts.push('keine zusÃ¤tzlichen Zusagen auÃŸerhalb des Rosters');
      const summaryText = summaryParts.length ? `Zusage-Pool (nÃ¤chstes Event): ${summaryParts.join(' Â· ')}` : '';
      if (signupInline) {
        signupInline.textContent = summaryText;
        signupInline.style.display = (!extraCount && summaryText) ? 'block' : 'none';
      }

      const hasDiagnostics = Boolean((diagnostics.forced || []).length || (diagnostics.invalid || []).length || (diagnostics.overbooked || []).length);
      const extrasSection = document.getElementById('extras');
      const shouldShowSection = extraCount > 0 || hasDiagnostics;
      if (!shouldShowSection) {
        if (extrasSection) extrasSection.style.display = 'none';
        extraRoot.innerHTML = '';
        if (extraNote) extraNote.textContent = '';
        return;
      }
      if (extrasSection) extrasSection.style.display = '';

      if (extraNote) {
        const parts = [];
        if (Number.isFinite(totalEntries)) parts.push(`Datei-EintrÃ¤ge: ${totalEntries}`);
        if (Number.isFinite(stats.hardTotal)) {
          const applied = (inRosterHard != null) ? ` (${inRosterHard} im Roster)` : '';
          parts.push(`verbindlich: ${stats.hardTotal}${applied}`);
        }
        if (Number.isFinite(extraCount) && extraCount > 0) parts.push(`auÃŸerhalb des Rosters: ${extraCount}`);
        if (stats.source) parts.push(`Quelle: ${stats.source}`);
        extraNote.textContent = parts.join(' Â· ') || 'Keine zusÃ¤tzlichen Zusagen erfasst.';
      }

      if (!extraCount) {
        extraRoot.innerHTML = '<p class="muted">Keine zusÃ¤tzlichen Zusagen auÃŸerhalb der Aufstellung.</p>';
        return;
      }

      extraRoot.innerHTML = '';
      groups.forEach(group => {
        const card = document.createElement('div');
        card.className = 'extra-card';
        const title = document.createElement('h3');
        title.textContent = `Gruppe ${group}`;
        card.appendChild(title);
        const list = document.createElement('ul');
        list.className = 'extra-list';
        const entries = Array.isArray(extraData[group]) ? extraData[group] : [];
        if (!entries.length) {
          const li = document.createElement('li');
          li.textContent = 'Keine Zusagen';
          list.appendChild(li);
        } else {
          entries.forEach(entry => {
            const li = document.createElement('li');
            const name = entry.player || entry.PlayerName || 'Unbekannt';
            const role = entry.role || entry.Role || '';
            const note = entry.note || entry.Note || '';
            const source = entry.source || entry.Source || '';
            const groupPref = entry.group || entry.Group || '';
            const metaParts = [];
            if (groupPref) metaParts.push(`Gruppe ${groupPref}`);
            if (role) metaParts.push(role);
            if (source) metaParts.push(source);
            const metaText = metaParts.length ? ` <span class="extra-meta">(${escapeHtml(metaParts.join(' Â· '))})</span>` : '';
            const noteText = note ? ` <span class="extra-meta">${escapeHtml(note)}</span>` : '';
            li.innerHTML = `${escapeHtml(name)}${metaText}${noteText}`;
            list.appendChild(li);
          });
        }
        card.appendChild(list);
        extraRoot.appendChild(card);
      });
    }

    function renderForcedDiagnostics(diag, meta) {
      const container = document.getElementById('forced-diagnostics');
      if (!container) return;
      const forced = Array.isArray(diag?.forced) ? diag.forced : [];
      const invalid = Array.isArray(diag?.invalid) ? diag.invalid : [];
      const overbooked = Array.isArray(diag?.overbooked) ? diag.overbooked : [];
      const stats = extractSignupStats(meta);

      const summaryParts = [];
      const hardTotal = Number.isFinite(stats.hardTotal) ? stats.hardTotal : null;
      const hardApplied = Number.isFinite(stats.hardApplied) ? stats.hardApplied : forced.length;
      const hardInvalid = Number.isFinite(stats.hardInvalid) ? stats.hardInvalid : invalid.length;
      const hardOverbooked = Number.isFinite(stats.hardOverbooked) ? stats.hardOverbooked : overbooked.length;
      if (Number.isFinite(stats.totalEntries)) summaryParts.push(`Datei-EintrÃ¤ge: ${stats.totalEntries}`);
      if (hardTotal != null) summaryParts.push(`davon verbindliche Zusagen: ${hardTotal}`);
      if (Number.isFinite(hardApplied)) summaryParts.push(`FixplÃ¤tze im Roster: ${hardApplied}`);
      if (Number.isFinite(hardInvalid) && hardInvalid > 0) summaryParts.push(`ignoriert: ${hardInvalid}`);
      if (Number.isFinite(hardOverbooked) && hardOverbooked > 0) summaryParts.push(`Ã¼ber KapazitÃ¤t: ${hardOverbooked}`);

      if (!forced.length && !invalid.length && !overbooked.length) {
        container.innerHTML = summaryParts.length
          ? `<p class="muted">${summaryParts.join(' Â· ')}</p>`
          : '<p class="muted">Keine verbindlichen Zusagen im Pool.</p>';
        return;
      }

      const parts = [];
      if (overbooked.length) {
        const items = overbooked
          .map(item => {
            const cap = Number.isFinite(item.capacity) ? Number(item.capacity) : null;
            const excess = Number.isFinite(item.excess_forced) ? Number(item.excess_forced) : null;
            const capText = cap != null ? `Slots: ${cap}` : 'Slots unbekannt';
            const excessText = excess != null ? `Ãœberbuchung: +${excess}` : 'Ãœberbuchung';
            return `<li class="warn">${escapeHtml(item.group || '?')}/${escapeHtml(item.role || '?')}: ${excessText} (${capText})</li>`;
          })
          .join('');
        parts.push(`<div><h4>Ãœberbuchungen</h4><ul>${items}</ul></div>`);
      }

      if (invalid.length) {
        const items = invalid
          .map(item => `<li>${escapeHtml(item.player || item.canon || '?')} â€” ${escapeHtml(item.reason || 'ungÃ¼ltig')}</li>`)
          .join('');
        parts.push(`<div><h4>Ignorierte harte Zusagen</h4><ul>${items}</ul></div>`);
      }

      if (forced.length) {
        const items = forced
          .map(item => {
            const over = item.overbooked ? ' Â· <span class="warn">(Ã¼ber KapazitÃ¤t)</span>' : '';
            return `<li>${escapeHtml(item.player || item.canon || '?')} â†’ ${escapeHtml(item.group || '?')}/${escapeHtml(item.role || '?')}${over}</li>`;
          })
          .join('');
        parts.push(`<div><h4>Verbindlich gesetzt</h4><ul>${items}</ul></div>`);
      }

      const summary = summaryParts.length ? `<p class="muted">${summaryParts.join(' Â· ')}</p>` : '';
      container.innerHTML = summary + parts.join('');
    }

    fetchAbsences();

    /**
     * Farb-Logik fÃ¼r No-Show-Badges (bisheriges Verhalten in Klartext):
     * 1. Keine Historie (events_seen=0 oder unbekannt) â†’ graue Badge ("nodata").
     * 2. Wer nie gefehlt hat, bleibt grÃ¼n, unabhÃ¤ngig von der Rate.
     * 3. low-n (â‰¤2 Teilnahmen) wird generell gelb eingeordnet, damit einzelne AusreiÃŸer
     *    nicht sofort rot erscheinen.
     * 4. Single-Miss-Spieler: ab 10 Events und Rate <12 % weiterhin grÃ¼n, sonst gelb.
     * 5. Alle anderen nutzen die Schwellwerte 20 % (grÃ¼nâ†’gelb) und 35 % (gelbâ†’rot).
     * 6. ZusÃ¤tzliche Feinjustierung: Bis 5 Events wird ein eigentlich rotes Rating
     *    auf gelb abgeschwÃ¤cht, um die geringe Stichprobe sichtbar zu machen.
     */
    function classifyNoShowBadge({ rate, eventsSeen, flags = {} }) {
      const { noData=false, neverMissed=false, lowN=false, singleMiss=false } = flags;

      if (noData) {
        return { level: "nodata", reason: "no-data" };
      }

      if (neverMissed) {
        return { level: "good", reason: "never-missed" };
      }

      if (lowN) {
        return { level: "warning", reason: "low-n" };
      }

      const value = (rate != null && Number.isFinite(rate)) ? rate : null;
      if (value == null) {
        return { level: "nodata", reason: "no-rate" };
      }

      if (singleMiss) {
        if ((eventsSeen ?? 0) >= SINGLE_MISS_GREEN_SEEN_MIN && value < SINGLE_MISS_GREEN_RATE_MAX) {
          return { level: "good", reason: "single-miss-soft-green" };
        }
        return { level: "warning", reason: "single-miss-soft-warning" };
      }

      let level;
      if (value < GREEN_TH) level = "good";
      else if (value < YELLOW_TH) level = "warning";
      else level = "bad";

      if (level === "bad" && eventsSeen != null && eventsSeen <= BADGE_SETTINGS.softenBadUntilSeen) {
        return { level: "warning", reason: "small-sample-soften" };
      }

      return { level, reason: "threshold" };
    }

    const BADGE_CLASS_BY_LEVEL = {
      nodata: "chip ns-neutral",
      neutral: "chip ns-neutral",
      good: "chip ns-ok",
      warning: "chip ns-mid",
      bad: "chip ns-bad",
    };

    function buildChipTooltip(p, rRolling, rOverall) {
      const seen   = (p && Number.isFinite(p.events_seen))  ? Number(p.events_seen)  : null;
      const miss   = (p && Number.isFinite(p.noshow_count)) ? Number(p.noshow_count) : null;
      const eb     = (p && p.eb && isFinite(p.eb.p_hat))    ? Number(p.eb.p_hat)     : null;
      const parts = [];
      parts.push(`n=${seen!=null?seen:"â€“"}`);
      parts.push(`misses=${miss!=null?miss:"â€“"}`);
      if (rRolling!=null && isFinite(rRolling)) parts.push(`rolling=${pc(rRolling)}`);
      if (rOverall!=null && isFinite(rOverall)) parts.push(`overall=${pc(rOverall)}`);
      if (eb!=null) parts.push(`ebâ‰ˆ${pc(eb)}`);
      return parts.join(" Â· ");
    }

    function buildPlayerMetaText(meta) {
      const eventsSeen = Number.isFinite(meta.eventsSeen) ? Number(meta.eventsSeen) : (meta.eventsSeen === 0 ? 0 : null);
      const noshowCountOverall = Number.isFinite(meta.noshowCountOverall) ? Number(meta.noshowCountOverall) : null;
      const noshowRateOverall = Number.isFinite(meta.noshowRateOverall) ? Number(meta.noshowRateOverall) : null;
      const noshowRateRolling = Number.isFinite(meta.noshowRateRolling) ? Number(meta.noshowRateRolling) : null;

      if (eventsSeen === 0) {
        return "0 Events Â· noch nie teilgenommen";
      }

      const parts = [];

      if (eventsSeen != null) {
        parts.push(`${eventsSeen} ${eventsSeen === 1 ? "Event" : "Events"}`);
      } else {
        parts.push("Events unbekannt");
      }

      if (noshowCountOverall != null) {
        let noshowText = `${noshowCountOverall} No-Show${noshowCountOverall === 1 ? "" : "s"} overall`;
        if (noshowRateOverall != null) {
          noshowText += ` (${pc(noshowRateOverall)})`;
        }
        parts.push(noshowText);
      } else if (noshowRateOverall != null) {
        parts.push(`No-Show overall ${pc(noshowRateOverall)}`);
      } else {
        parts.push("No-Show-Daten fehlen");
      }

      if (noshowRateRolling != null) {
        parts.push(`rolling ${pc(noshowRateRolling)}`);
      }

      if (eventsSeen != null && eventsSeen > 0 && eventsSeen <= 2) {
        parts.push("SchÃ¤tzung unsicher");
      }

      return parts.join(" Â· ");
    }

    const FORCED_SOURCE_LABELS = {
      manual: "Manuell",
      "callup-confirmed": "Callup",
    };

    function normalizeForcedSignup(raw) {
      if (!raw || typeof raw !== "object") return null;
      const commitment = (raw.commitment || raw.Commitment || "").toString().toLowerCase();
      if (commitment !== "hard") return null;
      const source = raw.source || raw.Source || "";
      const note = raw.note || raw.Note || "";
      const overbooked = Boolean(raw.overbooked || raw.Overbooked);
      return { commitment, source, note, overbooked };
    }

    function buildFixBadge(forcedSignup) {
      const normalized = normalizeForcedSignup(forcedSignup);
      if (!normalized) return "";
      const sourceLabel = normalized.source ? (FORCED_SOURCE_LABELS[normalized.source] || normalized.source) : "";
      const label = sourceLabel ? `verbindlich Â· ${sourceLabel}` : "verbindlich";
      const tooltipParts = ["Verbindliche Zusage aus event_signups_next.csv"];
      if (sourceLabel) tooltipParts.push(`Quelle: ${sourceLabel}`);
      if (normalized.overbooked) tooltipParts.push("Ã¼ber KapazitÃ¤t");
      return `<span class="tag tag-fix" title="${escapeHtml(tooltipParts.join(' Â· '))}">ðŸ”’ ${escapeHtml(label)}</span>`;
    }

    function writeBucketCounts(key, counts) {
      const h2 = document.querySelector(`#${key} h2`);
      if (!h2) return;
      const base = h2.getAttribute("data-label") || h2.textContent;
      h2.setAttribute("data-label", base);
      const fmt = (value, label) => `${(value==null || !Number.isFinite(value)) ? "â€“" : value} ${label}`;
      const suffix = ` â€” ${[fmt(counts.known, "bekannte"), fmt(counts.lown, "low-n"), fmt(counts.nd, "No-Data")].join(" Â· ")}`;
      h2.innerHTML = `${base}<span class="counts">${suffix}</span>`;
    }

    fetch(LATEST_JSON_URL, { cache: "no-store" })
      .then(r=>{ if(!r.ok) throw new Error(r.status+" "+r.statusText); return r.json(); })
      .then(payload => {
        const schema = (!Array.isArray(payload) && payload && typeof payload === "object") ? (payload.schema || {}) : {};
        const ebEnabled = Boolean(schema && schema.eb && schema.eb.enabled);

        // -------- payload -> rows (kompatibel zu alter Struktur) --------
        const toRows = (payload) => {
          if (Array.isArray(payload)) return payload; // alte Struktur weiterhin akzeptieren
          const playersByDisplay = Object.fromEntries((payload.players || []).map(p => [p.display, p]));
          const groups = payload.groups || {};
          const out = [];
          for (const G of ["A","B"]) {
            const g = groups[G] || {};
            for (const R of ["Start","Ersatz"]) {
              const list = (g[R] || []);
              list.forEach((name, idx) => {
                const p = playersByDisplay[name] || {};
                const eb = (p.eb && typeof p.eb === "object") ? {
                  p_hat: toNumber(p.eb.p_hat),
                  sigma: toNumber(p.eb.sigma),
                } : null;
                out.push({
                  Group: G,
                  Role: R,
                  Slot: idx + 1,
                  PlayerName: name,
                  NoShowOverall: toNumber(p.noshow_overall),
                  NoShowRolling: toNumber(p.noshow_rolling),
                  EB: eb,
                  EventsSeen: toNumber(p.events_seen),
                });
              });
            }
          }
          return out;
        };
        const rows = toRows(payload);

        const playersArray = (!Array.isArray(payload) && Array.isArray(payload.players)) ? payload.players : [];
        state.callupMeta = extractCallupMeta(payload, playersArray, schema);
        // Datengrundlage (latest.json):
        // - forced_signups (Array) sowie players[].forced_signup markieren verbindliche Zusagen aus event_signups_next.csv
        //   inkl. commitment (hard), source (manual/callup-confirmed), note & overbooked-Flag.
        // - players[].event_signup + has_event_signup spiegeln die ursprÃ¼nglichen Event-Pool-EintrÃ¤ge.
        const playersMap = Object.fromEntries(
          playersArray
            .filter(p => p && typeof p === "object" && typeof p.display === "string")
            .map(p => [p.display, p])
        );
        const playersByCanon = {};
        playersArray.forEach(p => {
          if (!p || typeof p !== "object") return;
          const canonSource = typeof p.canon === "string" && p.canon.trim() ? p.canon : p.display;
          const canon = canonicalNameJS(canonSource || "");
          if (!canon) return;
          playersByCanon[canon] = {
            display: p.display,
            group: p.group,
            role: p.role,
            has_event_signup: Boolean(p.has_event_signup || p.event_signup),
            event_signup: p.event_signup || null,
            has_forced_signup: Boolean(p.has_forced_signup || p.forced_signup),
            forced_signup: p.forced_signup || null,
            callup: p.callup || null,
          };
        });
        state.playersByCanon = playersByCanon;
        updateAbsencesUI();
        const extraSignups = {
          A: (payload && payload.groups && Array.isArray(payload.groups.A?.extra_signups)) ? payload.groups.A.extra_signups : [],
          B: (payload && payload.groups && Array.isArray(payload.groups.B?.extra_signups)) ? payload.groups.B.extra_signups : [],
        };
        state.forcedDiagnostics = {
          forced: Array.isArray(payload.forced_signups) ? payload.forced_signups : [],
          invalid: Array.isArray(payload.invalid_forced_signups) ? payload.invalid_forced_signups : [],
          overbooked: Array.isArray(payload.overbooked_forced_signups) ? payload.overbooked_forced_signups : [],
        };
        const hasEventsSeen = playersArray.some(p => p && Object.prototype.hasOwnProperty.call(p, "events_seen"));

        const observedFromPlayers = playersArray
          .map(p => {
            if (!p || typeof p !== "object") return null;
            const seen = toNumber(p.events_seen);
            const hasData = (seen == null) || (seen > 0);
            if (p.eb && p.eb.p_hat != null && hasData) {
              const v = toNumber(p.eb.p_hat);
              if (v != null) return v;
            }
            if (p.noshow_rolling != null && hasData) {
              const v = toNumber(p.noshow_rolling);
              if (v != null) return v;
            }
            if (p.noshow_overall != null && hasData) {
              const v = toNumber(p.noshow_overall);
              if (v != null) return v;
            }
            return null;
          })
          .filter(v => v != null);

        // -------- Prior (fÃ¼r No-Data-Spieler) dynamisch bestimmen --------
        // SchÃ¤tze den Mittelwert der beobachteten Raten (EB bevorzugt, sonst rolling â†’ overall)
        let observed = observedFromPlayers;
        if (!observed.length) {
          observed = rows.map(r => {
            const seen = toNumber(r.EventsSeen);
            const hasData = (seen == null) || (seen > 0);
            if (r.EB && r.EB.p_hat != null && hasData) {
              const v = toNumber(r.EB.p_hat);
              if (v != null) return v;
            }
            if (r.NoShowRolling != null && hasData) {
              const v = toNumber(r.NoShowRolling);
              if (v != null) return v;
            }
            if (r.NoShowOverall != null && hasData) {
              const v = toNumber(r.NoShowOverall);
              if (v != null) return v;
            }
            return null;
          }).filter(v => v != null);
        }
        const avg = (arr)=> arr.reduce((a,b)=>a+b,0)/Math.max(1,arr.length);
        const fallbackPrior = (schema.prior && schema.prior.fallback != null && isFinite(schema.prior.fallback)) ? Number(schema.prior.fallback) : DEFAULT_PRIOR_FALLBACK;
        const priorPad = (schema.prior && schema.prior.pad != null && isFinite(schema.prior.pad)) ? Number(schema.prior.pad) : DEFAULT_PRIOR_PAD;
        const teamMeanSchema = (schema.prior && schema.prior.team_mean != null && isFinite(schema.prior.team_mean)) ? Number(schema.prior.team_mean) : null;
        const priorValueSchema = (schema.prior && schema.prior.value != null && isFinite(schema.prior.value)) ? Number(schema.prior.value) : null;
        const priorBase = observed.length ? avg(observed) : fallbackPrior;
        const teamMean = (teamMeanSchema != null) ? teamMeanSchema : priorBase;
        const PRIOR_NOSHOW = clamp(priorValueSchema != null ? priorValueSchema : (teamMean + priorPad));

        // -------- Effektive Rate je Spieler fÃ¼r Sortierung --------
        const effRate = (r) => {
          if (r.EB && r.EB.p_hat != null) {
            const v = toNumber(r.EB.p_hat);
            if (v != null) return clamp(v);
          }
          const rolling = toNumber(r.NoShowRolling);
          if (rolling != null) return clamp(rolling);
          const overall = toNumber(r.NoShowOverall);
          if (overall != null) return clamp(overall);
          return PRIOR_NOSHOW;
        };

        // Sort-Hinweis im UI
        document.getElementById("sort-note").textContent =
          `Sortierung: niedrigste Risiko-SchÃ¤tzung zuerst (PrimÃ¤r: ${ebEnabled ? "EB pÌ‚" : "rolling"}, Fallback: ${ebEnabled ? "rolling â†’ overall" : "overall"}, Prior â‰ˆ ${(PRIOR_NOSHOW*100).toFixed(1)}%).`;

        // -------- Buckets bilden --------
        const targets = ["A-Start","A-Ersatz","B-Start","B-Ersatz"];
        const buckets = Object.fromEntries(targets.map(k => [k, []]));
        rows.forEach(r=>{
          const key = `${r.Group}-${r.Role}`;
          if (buckets[key]) buckets[key].push(r);
        });

        // -------- Buckets nach No-Show (aufsteigend) sortieren --------
        for (const key of targets) {
          buckets[key].sort((a,b)=>{
            const da = effRate(a), db = effRate(b);
            if (Math.abs(da - db) > EPS) return da - db;              // 1) No-Show (ASC)
            const oaVal = (toNumber(a.NoShowOverall) != null) ? toNumber(a.NoShowOverall) : 1;
            const obVal = (toNumber(b.NoShowOverall) != null) ? toNumber(b.NoShowOverall) : 1;
            const oa = oaVal ?? 1;
            const ob = obVal ?? 1;
            if (Math.abs(oa - ob) > EPS) return oa - ob;              // 2) Overall (ASC) als Tiebreak
            return (a.PlayerName||"").localeCompare(b.PlayerName||""); // 3) Name
          });
        }

        // -------- Render --------
        for (const key of targets) {
          const tbody = document.querySelector(`#${key} tbody`);
          tbody.innerHTML = "";
          (buckets[key] || []).forEach((r, i) => {
            const histOverall = toNumber(r.NoShowOverall);
            const histRolling = toNumber(r.NoShowRolling);
            const p = playersMap[r.PlayerName] || {};

            const seenSource = Number.isFinite(p.events_seen) ? Number(p.events_seen) : null;
            const seenFallback = Object.prototype.hasOwnProperty.call(r, "EventsSeen") ? toNumber(r.EventsSeen) : null;
            const seen = (seenSource != null) ? seenSource : seenFallback;

            const missesSource = Number.isFinite(p.noshow_count) ? Number(p.noshow_count) : null;
            const missesFallback = Object.prototype.hasOwnProperty.call(r, "NoShowCount") ? toNumber(r.NoShowCount) : null;
            const misses = (missesSource != null) ? missesSource : missesFallback;

            const seenKnown = (p && Object.prototype.hasOwnProperty.call(p, "events_seen")) ||
              Object.prototype.hasOwnProperty.call(r, "EventsSeen");
            const annotate = seenKnown || hasEventsSeen;

            const participated = (seen != null && seen > 0);
            const noData = annotate ? !participated : false;
            const lowN = annotate ? (participated && seen <= BADGE_SETTINGS.lowNMax) : false;
            const neverMissed = annotate ? (participated && misses === 0) : false;
            const singleMiss = annotate ? (participated && misses === 1) : false;

            const histRate = (histRolling ?? histOverall);

            const tip = buildChipTooltip(p, histRolling, histOverall);

            const shownOverall = noData ? null : histOverall;
            const shownRolling = noData ? null : histRolling;
            const badge = classifyNoShowBadge({
              rate: histRate,
              eventsSeen: annotate ? seen : null,
              flags: { noData, neverMissed, lowN, singleMiss },
            });
            const chipKlass = BADGE_CLASS_BY_LEVEL[badge.level] || BADGE_CLASS_BY_LEVEL.nodata;
            const reasonHint = badge.reason ? ` Â· badge=${badge.reason}` : "";
            const tooltip = `${tip}${reasonHint}`.replace(/"/g, '&quot;');
            let nameHTML = `${r.PlayerName || ""}`;
            const forcedBadge = p ? buildFixBadge(p.forced_signup || (p.has_forced_signup ? { commitment: 'hard', source: p.event_signup?.source } : null)) : '';
            const callupBadge = p ? buildCallupBadge(p.callup) : '';
            if (noData) {
              nameHTML += ' <span class="tag tag-nd" title="Keine Historie â€“ events_seen = 0">No&nbsp;Data</span>';
            }
            if (lowN) {
              nameHTML += ' <span class="tag tag-low" title="Wenig Historie â€“ events_seen âˆˆ {1,2}">low&nbsp;n</span>';
            }
            if (forcedBadge) nameHTML += ` ${forcedBadge}`;
            if (callupBadge) nameHTML += ` ${callupBadge}`;
            if (p && (p.has_event_signup || p.event_signup)) {
              nameHTML += ' <span class="tag tag-event" title="Zusage im Event-Pool (nÃ¤chstes Event)">Event-Zusage</span>';
            }
            const noshowCountOverall = Number.isFinite(p.noshow_count_overall) ? Number(p.noshow_count_overall) :
              (Number.isFinite(p.noshow_count) ? Number(p.noshow_count) :
              (Object.prototype.hasOwnProperty.call(r, "NoShowCount") ? toNumber(r.NoShowCount) : null));
            const metaText = buildPlayerMetaText({
              eventsSeen: seen,
              noshowCountOverall,
              noshowRateOverall: histOverall,
              noshowRateRolling: histRolling,
            });
            const tr = document.createElement("tr");
            tr.innerHTML = `
              <td class="num">${pad(i+1)}</td>
              <td>
                <div class="player-name-row">${nameHTML}</div>
                <div class="player-meta-row">${metaText}</div>
              </td>
              <td><span class="${chipKlass}" title="${tooltip}">${pc(shownOverall)}</span></td>
              <td><span class="${chipKlass}" title="${tooltip}">${pc(shownRolling)}</span></td>
            `;
            tbody.appendChild(tr);
          });

          if (!window.__bucketCounts) window.__bucketCounts = {};
          const keyCounts = { known:0, lown:0, nd:0 };
          (buckets[key] || []).forEach(row => {
            const pp = playersMap[row.PlayerName] || {};
            const seenVal = Number.isFinite(pp.events_seen) ? Number(pp.events_seen) :
              (Object.prototype.hasOwnProperty.call(row, "EventsSeen") ? toNumber(row.EventsSeen) : null);
            if (!(seenVal > 0)) { keyCounts.nd++; return; }
            if (seenVal <= BADGE_SETTINGS.lowNMax) { keyCounts.lown++; return; }
            keyCounts.known++;
          });
          window.__bucketCounts[key] = keyCounts;
          writeBucketCounts(key, keyCounts);
        }

        const signupMeta = payload.signup_pool || payload.event_signups || null;
        renderExtraSignups(extraSignups, signupMeta, state.forcedDiagnostics);
        renderForcedDiagnostics(state.forcedDiagnostics, signupMeta);
        updateCallupNote(state.callupMeta);

        const ts = new Date().toISOString().replace('T',' ').slice(0,19) + " UTC";
        const schemaVersion = (schema && schema.version != null) ? ` Â· schema v${schema.version}` : "";
        document.getElementById("stamp").textContent = `Stand: ${ts}${schemaVersion}`;
      })
      .catch(err=>{
        document.body.insertAdjacentHTML("beforeend",
          `<p style="color:#b00">Fehler beim Laden von <code>latest.json</code>: ${String(err)}</p>`);
      });
  </script>
</body>
</html>
