<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Desert Storm ‚Äì Aufstellung (Latest)</title>
  <style>
    :root{
      --fg:#111; --muted:#666; --line:#ddd;
      --ok:#1f9d55; --mid:#c9a227; --bad:#d64545;
      --bg:#fff; --bgth:#fafafa;
    }
    html{scroll-behavior:smooth;}
    body{font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;margin:24px;color:var(--fg);background:var(--bg)}
    h1{margin:0 0 8px}
    h2{margin:0 0 8px}
    h3{margin:12px 0 6px;font-weight:600}
    .top-bar{display:flex;align-items:flex-start;gap:12px;flex-wrap:wrap;margin:0 0 6px}
    .top-actions{margin-left:auto;display:flex;gap:10px;align-items:flex-start;flex-wrap:wrap}
    .admin-link{display:inline-flex;align-items:center;gap:8px;padding:8px 14px;border:1px solid var(--line);border-radius:10px;text-decoration:none;color:var(--fg);background:#fff;box-shadow:0 4px 12px rgba(0,0,0,0.05);font-weight:600}
    .admin-link:hover{border-color:#c8d5ec;box-shadow:0 6px 16px rgba(0,0,0,0.08)}
    .admin-link:active{transform:translateY(1px)}
    .stamp{display:block;font-size:0.8em;line-height:1.4;margin-top:4px}
    .anchor-nav{display:flex;flex-wrap:wrap;gap:10px;margin:12px 0 20px;font-size:0.95em}
    .anchor-nav a{padding:6px 10px;border:1px solid var(--line);border-radius:8px;text-decoration:none;color:var(--fg);background:#fff;box-shadow:0 4px 12px rgba(0,0,0,0.03)}
    .anchor-nav a:hover{border-color:#c8d5ec}
    .page-section{margin:32px 0}
    .section-header{display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .section-header p{margin:4px 0 0}
    .overview-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px;margin-top:10px}
    .meta-list{list-style:none;margin:0;padding:0;display:grid;gap:6px;font-size:0.95em}
    .meta-list strong{font-weight:700}
    .team-grid{display:grid;grid-template-columns:1fr;gap:16px;margin-top:12px}
    @media (min-width: 960px){ .team-grid{grid-template-columns:repeat(2,1fr)} }
    .team-card{border:1px solid var(--line);border-radius:12px;padding:14px;background:#fff;box-shadow:0 6px 18px rgba(0,0,0,0.04)}
    .team-card h3{margin:0 0 10px}
    .team-roles{display:grid;grid-template-columns:1fr;gap:14px}
    .team-legend{margin:6px 0 0}
    .legend-inline{margin-top:6px}
    .diagnostics-header{align-items:center}
    .diag-toggle{margin-left:auto}
    .diagnostics-content{display:none;margin-top:12px}
    .diagnostics-content.is-open{display:block}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left;vertical-align:top}
    th{background:var(--bgth)}
    .muted{color:var(--muted)}
    .num{font-variant-numeric:tabular-nums}
    .counts{font-size:.9em;color:var(--muted);font-weight:400;margin-left:.25rem}
    .chip{display:inline-block;min-width:52px;text-align:right;padding:2px 8px;border-radius:999px;border:1px solid var(--line)}
    .chip.ns-neutral{background:#f6f7f8;border:1px solid #ccc;color:#555}
    .ns-ok{border-color:#bfe8cc;background:#f3fbf6}
    .ns-mid{background:#fff9e6;border:1px solid #f3d78a}
    .ns-bad{border-color:#f2b7b7;background:#fff5f5}
    .sub{margin:6px 0 18px}
    .wrap{display:grid;grid-template-columns:1fr;gap:28px}
    @media (min-width: 960px){ .wrap{grid-template-columns:1fr 1fr} }
    .tag{display:inline-block;margin-left:6px;padding:2px 7px;border-radius:999px;font-size:0.72em;font-weight:600;vertical-align:middle}
    .tag-abs-active{background:#ecfdf3;border:1px solid #bbf7d0;color:#166534}
    .tag-abs-planned{background:#eef2ff;border:1px solid #c7d2fe;color:#312e81}
    .tag-nd{background:var(--bad);color:#fff}
    .tag-low{background:#f1e1a8;color:#111}
    .tag-event{background:#ecfeff;border:1px solid #a5f3fc;color:#0f172a}
    .tag-hard{background:#fee2e2;border:1px solid #fecdd3;color:#7f1d1d}
    .tag-fix{background:#f5f5f5;border:1px solid #d4d4d8;color:#3f3f46;display:inline-flex;align-items:center;gap:4px;letter-spacing:0.01em}
    .tag-callup{background:#eff6ff;border:1px solid #bfdbfe;color:#1d4ed8;display:inline-flex;align-items:center;gap:4px;letter-spacing:0.01em;font-weight:600}
    .legend{font-size:0.85em;margin:32px 0 0}
    .legend + .legend{margin-top:6px}
    .roster-controls{margin:12px 0 20px;display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .player-meta-toggle{font-size:0.9em;color:var(--fg);display:inline-flex;align-items:center;gap:8px;cursor:pointer;user-select:none}
    .player-meta-toggle input{width:16px;height:16px}
    .filter-note{font-size:0.9em;color:var(--muted)}
    .btn{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);background:#fff;border-radius:8px;padding:7px 10px;font-weight:600;cursor:pointer;color:var(--fg);box-shadow:0 4px 10px rgba(0,0,0,0.04)}
    .btn:disabled{opacity:0.55;cursor:not-allowed;box-shadow:none}
    .player-name-row{font-size:14px;font-weight:600}
    .player-meta-row{font-size:11px;color:#777;margin-top:2px;display:none}
    .show-player-meta .player-meta-row{display:block}
    .hide-callups .callup-badge{display:none}
    .is-hidden{display:none!important}
    #absences,#event-responses{margin-top:48px;padding-top:24px;border-top:1px solid var(--line)}
    #absences h2,#event-responses h2{margin:0 0 8px}
    #absences .absences-empty,#event-responses .absences-empty{color:var(--muted);margin:0}
    #absences table,#event-responses table{margin-top:12px}
    .absences-roster-badge{display:inline-block;margin-left:6px;padding:2px 8px;border-radius:999px;border:1px solid var(--line);font-size:0.75em;color:var(--muted);background:var(--bgth)}
    .absences-error{color:#b00}
    .extra-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px;margin-top:8px}
    .extra-card{border:1px solid var(--line);border-radius:10px;padding:10px;background:var(--bgth)}
    .extra-card h3{margin:0 0 6px}
    .extra-list{list-style:none;padding:0;margin:0;display:grid;gap:6px}
    .extra-meta{color:var(--muted);font-size:0.85em}
    .diag{margin:10px 0 0;padding:10px;border-radius:10px;border:1px solid var(--line);background:#fff}
    .diag h4{margin:0 0 6px;font-size:1em}
    .diag ul{margin:0;padding-left:20px;color:#444}
    .diag .warn{color:#7f1d1d;font-weight:600}
    #extras{margin-top:48px;padding-top:24px;border-top:1px solid var(--line)}
    #extras h2{margin-top:0}
    #signup-inline{display:none;margin-top:8px}
    #callup-suggestions{margin-top:32px}
    .callup-suggestion-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:12px}
    .callup-suggestion-card{border:1px solid var(--line);border-radius:10px;padding:10px;background:#fff}
    .callup-suggestion-card h3{margin:0 0 6px}
    .callup-suggestion-card table{width:100%;border-collapse:collapse;margin-top:6px}
    .callup-suggestion-card th,.callup-suggestion-card td{border-bottom:1px solid var(--line);padding:6px 8px;text-align:left}
    .callup-suggestion-card th{background:var(--bgth)}
    .callup-suggestion-card td.reason{font-size:0.9em;color:var(--muted)}
    #alliance-overview{margin-top:32px}
    #alliance-overview .filters{display:flex;flex-wrap:wrap;gap:12px;margin:10px 0}
    #alliance-overview table{margin-top:10px}
    #alliance-overview .contact-chip{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:12px;font-weight:700;border:1px solid var(--line)}
    #alliance-overview .contact-yes{background:#ecfdf3;border-color:#bbf7d0;color:#166534}
    #alliance-overview .contact-maybe{background:#fff7ed;border-color:#fed7aa;color:#7c2d12}
    #alliance-overview .contact-no{background:#fef2f2;border-color:#fecdd3;color:#991b1b}
    #alliance-overview .contact-former{background:#f4f4f5;border-color:#e4e4e7;color:#3f3f46}
    #alliance-overview .alliance-summary{margin:6px 0 4px;color:var(--muted);font-size:0.95em}
    #alliance-overview .alliance-status{display:inline-flex;align-items:center;gap:6px;font-weight:600}
    #alliance-overview .alliance-status .tag{margin-left:0}
    #alliance-overview .alliance-status .status-active{background:#ecfdf3;border:1px solid #bbf7d0;color:#166534;padding:2px 8px;border-radius:10px;font-size:0.85em}
    #alliance-overview .alliance-status .status-former{background:#f4f4f5;border:1px solid #e4e4e7;color:#3f3f46;padding:2px 8px;border-radius:10px;font-size:0.85em}
    #alliance-overview .ex-member{background:linear-gradient(90deg,#f9fafb,#f4f4f5)}
    .admin-inline-link{color:inherit;text-decoration:none;display:inline-flex;align-items:center;gap:4px;padding:2px 6px;border-radius:8px;border:1px solid var(--line);background:#fff}
    .admin-inline-link:hover{border-color:#c8d5ec}
    .prefill-highlight{box-shadow:0 0 0 2px #bfdbfe;transition:box-shadow 0.25s ease;background:linear-gradient(90deg,#eff6ff,transparent)}
    .init-error{border:1px solid #f7c5c5;background:#fff5f5;color:#7f1d1d;padding:12px 14px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.04);font-weight:600;margin:12px 0 0}
    .section-fallback{color:#7f1d1d;font-weight:600;margin:6px 0 0}
  </style>
</head>
<body>
  <div class="top-bar">
    <h1>Desert Storm ‚Äì Aufstellung <span id="stamp" class="muted stamp"></span></h1>
    <div class="top-actions">
      <a class="admin-link" href="admin/index.html">Admin &amp; Tools</a>
    </div>
  </div>
  <nav class="anchor-nav">
    <a href="#section-overview">√úberblick</a>
    <a href="#section-teams">Teams A/B</a>
    <a href="#section-alliance">Allianz &amp; Callup</a>
    <a href="#section-diagnostics">Diagnose</a>
  </nav>

  <div id="init-error" class="init-error" style="display:none"></div>

  <!-- Abschnittsstruktur: √úberblick (Status & Empfehlung), Teams A/B (Roster & Details), Allianz & Callup (Arbeitsbereich), Diagnose (Debug). -->
  <section id="section-overview" class="page-section">
    <div class="section-header">
      <h2>Event-√úberblick</h2>
      <p class="muted">Status des n√§chsten Desert Storm inkl. Anwesenheit &amp; Empfehlung.</p>
    </div>
    <div class="overview-grid">
      <div id="attendance-summary" class="diag" style="display:none"></div>
      <div id="overview-meta" class="diag">
        <h3 style="margin:0 0 6px">Event-Metadaten</h3>
        <p class="muted" id="overview-meta-note">Wird geladen ‚Ä¶</p>
        <ul class="meta-list" id="overview-meta-list" style="display:none"></ul>
      </div>
    </div>
  </section>

  <section id="section-teams" class="page-section">
    <div class="section-header">
      <h2>Teams A/B</h2>
      <p class="muted">Roster-Aufstellung und Detailhistorie pro Spieler.</p>
    </div>
    <div class="roster-controls">
      <label class="player-meta-toggle">
        <input type="checkbox" id="player-meta-toggle" />
        Detailzeile pro Spieler anzeigen
      </label>
      <label class="player-meta-toggle">
        <input type="checkbox" id="callup-toggle" checked />
        Callup-Empfehlungen anzeigen
      </label>
      <label class="player-meta-toggle" title="Blendet Spieler ohne feste Zusage aus">
        <input type="checkbox" id="commit-callup-toggle" />
        Nur feste Zusagen anzeigen
      </label>
      <span id="commit-callup-filter-note" class="filter-note" style="display:none">Gefilterte Teams-Ansicht ‚Äì es werden nur Spieler mit fester Zusage (üîí) in den Roster-Tabellen gezeigt.</span>
      <div class="filter-note" id="commit-callup-filter-help">
        Zeigt nur Spieler mit fester Zusage (üîí, Commitment=hard) in den Teams A/B. Callups ohne Fixplatz werden ausgeblendet. Kennzahlen bleiben unver√§ndert.
      </div>
      <button id="callup-export" class="btn" type="button" disabled title="Keine Callup-Kandidaten im aktuellen Roster">
        üì• Callup-Kandidaten als CSV exportieren
      </button>
    </div>
    <p class="muted" id="sort-note" style="margin:0 0 10px"></p>
    <p class="muted legend team-legend">Legende: <span class="tag tag-nd" title="Keine Historie ‚Äì events_seen = 0">No&nbsp;Data</span> keine Historie ¬∑ <span class="tag tag-low" title="Wenig Historie ‚Äì events_seen ‚àà {1,2}">low&nbsp;n</span> wenig Historie ¬∑ <span class="tag tag-fix">üîí verbindlich</span> verbindliche Zusage (Commitment=hard) ¬∑ <span class="tag tag-callup callup-badge">üîî Callup</span> Spieler, f√ºr die eine Erinnerung empfohlen wird<br />Farben basieren auf Historie (rolling‚Üíoverall), EB wird nur zur Sortierung verwendet.<br />No-Data = nie teilgenommen (grau). low-n ‚â§2 = gelb. 1 Fehltermin = nie rot.</p>
    <div id="roster-root" class="team-grid">
      <div class="team-card">
        <h3>Team A</h3>
        <div class="team-roles">
          <section id="A-Start">
            <h2>Gruppe A ¬∑ Start</h2>
            <table>
              <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
              <tbody></tbody>
            </table>
          </section>
          <section id="A-Ersatz">
            <h2>Gruppe A ¬∑ Ersatz</h2>
            <table>
              <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
              <tbody></tbody>
            </table>
          </section>
        </div>
      </div>
      <div class="team-card">
        <h3>Team B</h3>
        <div class="team-roles">
          <section id="B-Start">
            <h2>Gruppe B ¬∑ Start</h2>
            <table>
              <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
              <tbody></tbody>
            </table>
          </section>
          <section id="B-Ersatz">
            <h2>Gruppe B ¬∑ Ersatz</h2>
            <table>
              <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
              <tbody></tbody>
            </table>
          </section>
        </div>
      </div>
    </div>
  </section>

  <section id="section-alliance" class="page-section">
    <div class="section-header">
      <h2>Allianz &amp; Callup</h2>
      <p class="muted">Callup-Empfehlungen, Allianz-Tabelle und Event-Kontext.</p>
    </div>
    <p class="muted" id="callup-note" style="margin:0 0 12px; display:none"></p>
    <section id="callup-suggestions" class="diag" style="display:none">
      <h2>Zus√§tzliche Kandidaten zum Auff√ºllen (n√§chstes Event)</h2>
      <p class="muted" id="callup-suggestions-note">L√§dt Empfehlungen ‚Ä¶</p>
      <div id="callup-suggestions-content"></div>
    </section>

    <section id="extras">
      <h2>Zus√§tzliche Zusagen (Pool n√§chstes Event)</h2>
      <p class="muted" id="extra-note">L√§dt Zusagen ‚Ä¶</p>
      <div id="extra-root" class="extra-grid"></div>
      <p class="muted legend" id="signup-inline"></p>
    </section>

    <p class="muted legend legend-inline">Kurzlegende f√ºr Allianz &amp; Callup: <span class="tag tag-callup callup-badge">üîî Callup</span> Erinnerung empfohlen ¬∑ <span class="tag tag-fix">üîí verbindlich</span> bindende Zusage ¬∑ No-Show-Farben wie im Team-Block.</p>

    <section id="alliance-overview" class="diag">
      <h2>Allianz-√úbersicht (n√§chstes Desert Storm)</h2>
      <div class="filters">
        <label class="player-meta-toggle"><input type="checkbox" id="alliance-filter-contact" checked /> nur Kontakt = yes</label>
        <label class="player-meta-toggle"><input type="checkbox" id="alliance-filter-hide-roster" checked /> Spieler im Roster ausblenden</label>
        <label class="player-meta-toggle"><input type="checkbox" id="alliance-filter-hide-absent" checked /> Abwesende ausblenden</label>
        <label class="player-meta-toggle"><input type="checkbox" id="alliance-filter-show-former" /> Ausgetretene anzeigen</label>
        <button class="btn" id="alliance-export" type="button">üì§ Allianz-Tabelle als CSV</button>
      </div>
      <p id="alliance-overview-summary" class="muted" style="margin:0 0 6px;">Wird geladen ‚Ä¶</p>
      <div id="alliance-overview-table" class="muted">Wird geladen ‚Ä¶</div>
    </section>

    <section id="event-responses">
      <h2>Event-Antworten (n√§chstes Event)</h2>
      <p style="margin:6px 0 10px;"><a class="admin-link" href="admin/event-assignments.html" target="_blank" rel="noopener">‚úèÔ∏è Antwort/Zusage im Admin erfassen‚Ä¶</a></p>
      <div id="event-responses-content" class="muted">Wird geladen ‚Ä¶</div>
    </section>

    <section id="absences">
      <h2>Absenzen</h2>
      <div id="absences-content" class="muted">Wird geladen ‚Ä¶</div>
    </section>
  </section>

  <section id="section-diagnostics" class="page-section">
    <div class="section-header diagnostics-header">
      <h2>Diagnose &amp; Details</h2>
      <button class="btn diag-toggle" id="diagnostics-toggle" type="button">Diagnose &amp; technische Details anzeigen</button>
    </div>
    <div id="diagnostics-content" class="diagnostics-content">
      <div class="diag">
        <p class="muted" style="margin:0">Signup-Pool-Diagnostik, erweiterte Absenzen und weitere technische Details.</p>
      </div>
      <div id="forced-diagnostics" class="diag"></div>
      <section id="absence-diagnostics" class="diag" style="display:none"></section>
    </div>
  </section>

  <p class="sub muted">Quelle: <code>out/latest.json</code> (GitHub)</p>

  <script src="shared.js"></script>
  <script>
    // Quelle (mit Cache-Buster)
    const url = new URL(location.href);
    const branchOverride = url.searchParams.get('branch');
    const branch = branchOverride || 'main';
    const cacheBuster = `?v=${Date.now()}`;
    const SITE_ROOT = dsroShared.computeSiteRoot(location.pathname || '/');
    const LATEST_JSON_URL = dsroShared.buildLatestJsonUrl({ branchOverride, cacheBuster, siteRoot: SITE_ROOT });
    const canonicalNameJS = dsroShared.canonicalNameJS;
    const escapeHtml = dsroShared.escapeHtml;
    const fetchJsonWithErrors = dsroShared.fetchJsonWithErrors;
    const initErrorBlock = document.getElementById("init-error");
    // Main roster UI expects latest.json at: docs/out/latest.json (served as out/latest.json on GitHub Pages).
    // Konfiguration: Prior-Defaults (werden durch schema.prior √ºberschrieben)
    const DEFAULT_PRIOR_FALLBACK = 0.18;
    const DEFAULT_PRIOR_PAD = 0.02;
    const EPS = 1e-12;

    const state = {
      showPlayerMeta: false,
      showCallups: true,
      rosterFilters: { showFixedCommitmentsOnly: false },
      absences: { entries: [], active: [], error: null, loading: true },
      absenceDebug: null,
      absenceConflicts: [],
      eventResponses: { entries: [], declines: [], penalties: [], stats: {}, loading: true, error: null },
      eventResponseConflicts: [],
      playersByCanon: {},
      forcedDiagnostics: { forced: [], invalid: [], overbooked: [], rows: [] },
      callupMeta: { available: false, recommendedTotal: null, reasonCounts: {}, fromStats: false, hasStats: false },
      callupCandidates: [],
      callupSuggestions: null,
      allianceOverview: { players: [], meta: {} },
      allianceFilters: { contactYesOnly: true, hideRoster: true, hideAbsent: true, showFormer: false },
      latestPayload: null,
      playersArray: [],
    };
    const rosterFilterState = state.rosterFilters;
    const rosterRoot = document.getElementById("roster-root");
    const playerMetaToggle = document.getElementById("player-meta-toggle");
    const callupToggle = document.getElementById("callup-toggle");
    const commitCallupToggle = document.getElementById("commit-callup-toggle");
    const commitCallupFilterNote = document.getElementById("commit-callup-filter-note");
    const callupNote = document.getElementById("callup-note");
    const attendanceSummaryBox = document.getElementById("attendance-summary");
    const overviewMeta = document.getElementById("overview-meta");
    const overviewMetaNote = document.getElementById("overview-meta-note");
    const overviewMetaList = document.getElementById("overview-meta-list");
    const callupSuggestionsSection = document.getElementById("callup-suggestions");
    const callupSuggestionsContent = document.getElementById("callup-suggestions-content");
    const callupSuggestionsNote = document.getElementById("callup-suggestions-note");
    const callupExportBtn = document.getElementById("callup-export");
    const allianceTable = document.getElementById("alliance-overview-table");
    const allianceSummary = document.getElementById("alliance-overview-summary");
    const allianceExportBtn = document.getElementById("alliance-export");
    const allianceFilterContact = document.getElementById("alliance-filter-contact");
    const allianceFilterHideRoster = document.getElementById("alliance-filter-hide-roster");
    const allianceFilterHideAbsent = document.getElementById("alliance-filter-hide-absent");
    const allianceFilterShowFormer = document.getElementById("alliance-filter-show-former");
    const absencesContainer = document.getElementById("absences-content");
    const absenceDiag = document.getElementById("absence-diagnostics");
    const eventResponsesContainer = document.getElementById("event-responses-content");
    const extraRoot = document.getElementById("extra-root");
    const extraNote = document.getElementById("extra-note");
    const signupInline = document.getElementById("signup-inline");
    const diagnosticsToggle = document.getElementById("diagnostics-toggle");
    const diagnosticsContent = document.getElementById("diagnostics-content");

    function safeRenderSection(sectionId, renderFn, fallbackTarget) {
      try {
        renderFn();
      } catch (err) {
        console.error(`DS_RENDER_${sectionId.toUpperCase()}_FAILED`, err);
        if (fallbackTarget) {
          renderSectionFallback(fallbackTarget);
        }
      }
    }

    function renderSectionFallback(target, message = "Dieser Abschnitt konnte nicht geladen werden.") {
      const el = typeof target === "string" ? document.querySelector(target) : target;
      if (!el) return;
      if (el.children.length === 0 || el.tagName === "P") {
        el.textContent = message;
      } else {
        el.innerHTML = `<p class="section-fallback">${escapeHtml(message)}</p>`;
      }
      if (typeof el.classList?.remove === "function") {
        el.classList.remove("muted");
      }
      el.style.display = "block";
    }

    function clearInitError() {
      if (initErrorBlock) {
        initErrorBlock.style.display = "none";
        initErrorBlock.textContent = "";
      }
    }

    function showInitError(message) {
      if (initErrorBlock) {
        initErrorBlock.textContent = message;
        initErrorBlock.style.display = "block";
      }
      markPlaceholdersAsFailed(message);
    }

    function markPlaceholdersAsFailed(message) {
      renderSectionFallback(overviewMetaNote, message);
      renderSectionFallback(allianceSummary, message);
      renderSectionFallback(allianceTable, message);
      renderSectionFallback(eventResponsesContainer, message);
      renderSectionFallback(absencesContainer, message);
    }

    async function loadLatestJson() {
      return fetchJsonWithErrors(LATEST_JSON_URL, { cache: "no-store" });
    }

    // Zentrale Stelle f√ºr rosterbezogene Filter (leicht erweiterbar f√ºr weitere Flags)
    function applyRosterFilters(filterState = rosterFilterState) {
      const rows = document.querySelectorAll('#roster-root tr[data-player-row="true"]');
      rows.forEach(row => {
        const hasFixedCommit = row.dataset.fixedCommit === "true";
        const hideRow = Boolean(filterState.showFixedCommitmentsOnly && !hasFixedCommit);
        row.classList.toggle('is-hidden', hideRow);
      });

      if (commitCallupFilterNote) {
        commitCallupFilterNote.style.display = filterState.showFixedCommitmentsOnly ? "inline" : "none";
      }
    }

    if (playerMetaToggle) {
      state.showPlayerMeta = Boolean(playerMetaToggle.checked);
      playerMetaToggle.addEventListener("change", (event) => {
        state.showPlayerMeta = event.target.checked;
        if (rosterRoot) {
          rosterRoot.classList.toggle("show-player-meta", state.showPlayerMeta);
        }
      });
    }
    if (callupToggle) {
      state.showCallups = Boolean(callupToggle.checked);
      callupToggle.addEventListener("change", (event) => {
        state.showCallups = event.target.checked;
        if (rosterRoot) {
          rosterRoot.classList.toggle("hide-callups", !state.showCallups);
        }
        document.body.classList.toggle("hide-callups", !state.showCallups);
        updateCallupNote(state.callupMeta);
      });
    }
    if (commitCallupToggle) {
      rosterFilterState.showFixedCommitmentsOnly = Boolean(commitCallupToggle.checked);
      commitCallupToggle.addEventListener("change", (event) => {
        rosterFilterState.showFixedCommitmentsOnly = Boolean(event.target.checked);
        applyRosterFilters();
      });
      applyRosterFilters();
    }
    if (callupExportBtn) {
      callupExportBtn.addEventListener("click", () => {
        const candidates = state.callupCandidates || [];
        const suggestions = state.callupSuggestions;
        const exportedSuggestions = exportSuggestedCallupsCsv(state.latestPayload, suggestions);
        if (exportedSuggestions) return;
        if (!candidates.length) {
          callupExportBtn.title = 'Keine Callup-Kandidaten im aktuellen Roster';
          return;
        }
        exportCallupCandidatesCsv(state.latestPayload, candidates);
      });
    }
    if (allianceFilterContact) {
      state.allianceFilters.contactYesOnly = Boolean(allianceFilterContact.checked);
      allianceFilterContact.addEventListener('change', (event) => {
        state.allianceFilters.contactYesOnly = Boolean(event.target.checked);
        renderAllianceOverview();
      });
    }
    if (allianceFilterHideRoster) {
      state.allianceFilters.hideRoster = Boolean(allianceFilterHideRoster.checked);
      allianceFilterHideRoster.addEventListener('change', (event) => {
        state.allianceFilters.hideRoster = Boolean(event.target.checked);
        renderAllianceOverview();
      });
    }
    if (allianceFilterHideAbsent) {
      state.allianceFilters.hideAbsent = Boolean(allianceFilterHideAbsent.checked);
      allianceFilterHideAbsent.addEventListener('change', (event) => {
        state.allianceFilters.hideAbsent = Boolean(event.target.checked);
        renderAllianceOverview();
      });
    }
    if (allianceFilterShowFormer) {
      state.allianceFilters.showFormer = Boolean(allianceFilterShowFormer.checked);
      allianceFilterShowFormer.addEventListener('change', (event) => {
        state.allianceFilters.showFormer = Boolean(event.target.checked);
        renderAllianceOverview();
      });
    }
    if (allianceExportBtn) {
      allianceExportBtn.addEventListener('click', () => {
        exportAllianceOverviewCsv();
      });
    }
    if (diagnosticsToggle && diagnosticsContent) {
      const setDiagnosticsOpen = (open) => {
        diagnosticsContent.classList.toggle("is-open", open);
        diagnosticsContent.style.display = open ? "block" : "none";
        diagnosticsToggle.textContent = open
          ? "Diagnose & technische Details ausblenden"
          : "Diagnose & technische Details anzeigen";
      };
      setDiagnosticsOpen(false);
      diagnosticsToggle.addEventListener("click", () => {
        const isOpen = diagnosticsContent.classList.contains("is-open");
        setDiagnosticsOpen(!isOpen);
      });
    }
    if (rosterRoot) {
      rosterRoot.classList.toggle("show-player-meta", state.showPlayerMeta);
      rosterRoot.classList.toggle("hide-callups", !state.showCallups);
    }
    document.body.classList.toggle("hide-callups", !state.showCallups);
    applyRosterFilters();
    updateCallupNote(state.callupMeta);
    updateCallupExportButton(state.callupMeta, state.callupCandidates);

    // Format & Styling
    const pad = (n)=> String(n).padStart(2,"0");
    const pc  = (x)=> (x==null || isNaN(x)) ? "‚Äì" : (Math.round(x*1000)/10).toFixed(1)+"%";
    const BADGE_SETTINGS = {
      thresholds: {
        ok: 0.20,
        warning: 0.35,
      },
      singleMiss: {
        seenMin: 10,
        rateMax: 0.12,
      },
      lowNMax: 2,
      softenBadUntilSeen: 5,
    };
    const GREEN_TH  = BADGE_SETTINGS.thresholds.ok;
    const YELLOW_TH = BADGE_SETTINGS.thresholds.warning;
    const SINGLE_MISS_GREEN_SEEN_MIN = BADGE_SETTINGS.singleMiss.seenMin;
    const SINGLE_MISS_GREEN_RATE_MAX = BADGE_SETTINGS.singleMiss.rateMax;
    const clamp = (x)=> Math.min(1, Math.max(0, x));
    const toNumber = (v)=>{
      if (v==null) return null;
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };

    const CALLUP_REASON_LABELS = {
      high_overall: "Hohe No-Show overall",
      high_rolling: "Hohe No-Show rolling",
      rolling_uptick: "Rolling-Uptick (rolling > overall)",
      recent_uptick: "Rolling-Uptick (rolling > overall)",
      low_n: "Low-N (wenig Events)",
    };

    function formatCallupReasons(callup) {
      if (!callup) return "";
      const rawReasons = Array.isArray(callup.reasons) ? callup.reasons : [];
      const codes = new Set();
      const fallbackLabels = [];
      rawReasons.forEach(r => {
        if (!r) return;
        const code = (typeof r === "string") ? r : (r.code || r.label || "");
        const normalized = String(code || "").trim();
        if (normalized) {
          codes.add(normalized);
        } else if (typeof r.label === "string") {
          fallbackLabels.push(r.label.trim());
        }
      });

      const labels = [];
      const hasHighOverall = codes.has("high_overall");
      const hasHighRolling = codes.has("high_rolling");
      const hasRollingUptick = codes.has("rolling_uptick") || codes.has("recent_uptick");
      const hasLowN = codes.has("low_n");

      if (hasHighOverall && hasHighRolling) {
        labels.push("Hohe No-Show (overall + rolling)");
      } else {
        if (hasHighOverall) labels.push(CALLUP_REASON_LABELS.high_overall);
        if (hasHighRolling) labels.push(CALLUP_REASON_LABELS.high_rolling);
      }
      if (hasRollingUptick) {
        labels.push(CALLUP_REASON_LABELS.rolling_uptick);
      }
      if (hasLowN) labels.push(CALLUP_REASON_LABELS.low_n);

      if (!labels.length && fallbackLabels.length) {
        labels.push(...fallbackLabels);
      }

      return labels.join(" ¬∑ ");
    }

    function normalizeCallup(player) {
      const p = (player && typeof player === 'object') ? player : null;
      const rawCallup = (p && p.callup && typeof p.callup === 'object') ? p.callup : null;
      const base = rawCallup && typeof rawCallup === 'object' ? { ...rawCallup } : {};
      const recommendedRaw = (rawCallup && typeof rawCallup.recommended === 'boolean') ? Boolean(rawCallup.recommended) : null;
      const recommendedFlag = (p && typeof p.callup_recommended === 'boolean') ? Boolean(p.callup_recommended) : null;

      const normalizedReasons = [];
      const seenCodes = new Set();
      const rawReasons = Array.isArray(rawCallup?.reasons) ? rawCallup.reasons : [];
      rawReasons.forEach(reason => {
        if (!reason || typeof reason !== 'object') return;
        const code = String(reason.code || '').trim();
        const label = CALLUP_REASON_LABELS[code] || reason.label || code || 'Callup empfohlen';
        if (code) seenCodes.add(code);
        normalizedReasons.push({ code: code || 'unknown', label });
      });

      const reasonCodes = Array.isArray(p?.callup_reason_codes) ? p.callup_reason_codes : [];
      const singleReason = (p && typeof p.callup_reason === 'string' && p.callup_reason.trim()) ? [p.callup_reason] : [];
      [...reasonCodes, ...singleReason].forEach(code => {
        if (code === null || code === undefined) return;
        const normalized = String(code || 'unknown').trim() || 'unknown';
        if (normalized && !seenCodes.has(normalized)) {
          seenCodes.add(normalized);
          normalizedReasons.push({ code: normalized, label: CALLUP_REASON_LABELS[normalized] || normalized });
        }
      });

      const recommended = (recommendedRaw !== null)
        ? recommendedRaw
        : (recommendedFlag !== null ? recommendedFlag : normalizedReasons.length > 0);

      if (!recommended && normalizedReasons.length === 0 && !rawCallup && recommendedFlag === null) {
        return null;
      }

      base.recommended = Boolean(recommended);
      base.reasons = normalizedReasons;
      return base;
    }

    function buildCallupBadge(callup) {
      if (!callup || !callup.recommended) return "";
      const reasonText = formatCallupReasons(callup);
      const label = "Callup";
      const title = reasonText ? `Callup empfohlen: ${reasonText}` : "Callup empfohlen";
      return `<span class="tag tag-callup callup-badge" title="${escapeHtml(title)}">üîî ${escapeHtml(label)}</span>`;
    }

    function hasFixedCommit(player, forcedSignup = null) {
      const normalizedForced = normalizeForcedSignup(forcedSignup);
      return Boolean(normalizedForced && normalizedForced.commitment === "hard");
    }

    function extractCallupMeta(payload, playersArray, schema = {}) {
      const schemaVersion = Number.isFinite(schema.version) ? Number(schema.version) : null;
      const stats = payload && typeof payload === 'object' && payload.callup_stats && typeof payload.callup_stats === 'object'
        ? payload.callup_stats
        : null;
      const statsCountRaw = stats && Object.prototype.hasOwnProperty.call(stats, 'recommended_total')
        ? Number(stats.recommended_total)
        : null;
      const statsCount = Number.isFinite(statsCountRaw) ? statsCountRaw : null;
      const statsReasons = (stats && stats.reasons && typeof stats.reasons === 'object') ? stats.reasons : null;
      const hasStats = Boolean(stats);
      const configSnapshot = (stats && typeof stats.config_snapshot === 'object') ? stats.config_snapshot : null;

      let derivedCount = 0;
      const derivedReasons = {};
      playersArray.forEach(p => {
        if (!p || typeof p !== 'object') return;
        const callup = normalizeCallup(p);
        const recommended = Boolean(callup && callup.recommended === true);
        if (!recommended) return;
        derivedCount += 1;
        if (Array.isArray(callup.reasons)) {
          callup.reasons.forEach(reason => {
            if (!reason || typeof reason !== 'object') return;
            const code = String(reason.code || 'unknown');
            derivedReasons[code] = (derivedReasons[code] || 0) + 1;
          });
        }
      });

      const recommendedTotal = statsCount != null ? statsCount : derivedCount;
      const reasonCounts = statsReasons || derivedReasons;
      const available = Boolean(hasStats || derivedCount > 0 || playersArray.some(p => normalizeCallup(p)));

      return { available, recommendedTotal, reasonCounts, fromStats: Boolean(hasStats && statsCount != null), hasStats, schemaVersion, configSnapshot };
    }

    function updateCallupNote(meta) {
      if (!callupNote) return;
      const show = state.showCallups;
      if (!show) {
        callupNote.style.display = 'none';
        return;
      }

      const hasStats = Boolean(meta && meta.hasStats);
      const recommendedTotal = Number.isFinite(meta?.recommendedTotal) ? Number(meta.recommendedTotal) : null;
      const reasonCounts = meta?.reasonCounts || {};
      const configSnapshot = meta?.configSnapshot;

      let text = '';
      if (!hasStats) {
        text = 'Callup-Empfehlungen: nicht verf√ºgbar (√§ltere schema-Version).';
      } else if (recommendedTotal === 0) {
        text = 'Callup-Empfehlungen: keine Spieler empfohlen.';
      } else if (recommendedTotal != null && recommendedTotal > 0) {
        text = `Callup-Empfehlungen: ${recommendedTotal} Spieler empfohlen.`;
      }

      const breakdownOrder = ['high_rolling', 'rolling_uptick', 'high_overall', 'recent_uptick', 'low_n'];
      const breakdown = breakdownOrder
        .map(code => {
          const count = Number.isFinite(reasonCounts[code]) ? Number(reasonCounts[code]) : null;
          if (count == null || count <= 0) return '';
          const label = CALLUP_REASON_LABELS[code] || code;
          return `${count}√ó ${label}`;
        })
        .filter(Boolean);

      if (text && breakdown.length) {
        text += ` ‚Äî Gr√ºnde: ${breakdown.join(' ¬∑ ')}`;
      }

      const rulesText = buildConfigSnapshotText(configSnapshot);
      const parts = [];
      if (text) parts.push(text);
      if (rulesText) parts.push(rulesText);

      if (parts.length) {
        callupNote.textContent = parts.join(' ‚Äî ');
        callupNote.style.display = 'block';
      } else {
        callupNote.textContent = '';
        callupNote.style.display = 'none';
      }
    }

    function formatPercentShort(value) {
      const n = Number(value);
      if (!Number.isFinite(n)) return null;
      return `${Math.round(n * 100)} %`;
    }

    function formatPercentPointsShort(value) {
      const n = Number(value);
      if (!Number.isFinite(n)) return null;
      return `${Math.round(n * 100)} pp`;
    }

    function buildConfigSnapshotText(snapshot) {
      if (!snapshot || typeof snapshot !== 'object') return '';
      const overall = formatPercentShort(snapshot.high_overall_threshold);
      const rolling = formatPercentShort(snapshot.high_rolling_threshold);
      const rollingMin = formatPercentShort(snapshot.rolling_uptick_min);
      const rollingDelta = formatPercentPointsShort(snapshot.rolling_uptick_delta);
      const lowN = Number.isFinite(Number(snapshot.low_n_max_events)) ? Number(snapshot.low_n_max_events) : null;
      const minEvents = Number.isFinite(Number(snapshot.min_events)) ? Number(snapshot.min_events) : null;

      const parts = [];
      if (overall || rolling) {
        const suffix = minEvents != null ? ` (ab ‚â• ${minEvents} Events)` : '';
        if (overall) parts.push(`High overall ‚â• ${overall}${suffix}`);
        if (rolling) parts.push(`High rolling ‚â• ${rolling}${suffix}`);
      }
      const uptickParts = [];
      if (rollingMin) uptickParts.push(rollingMin);
      if (rollingDelta) uptickParts.push(`+${rollingDelta}`);
      if (uptickParts.length) parts.push(`Rolling-Uptick ‚â• ${uptickParts.join(' & ')}`);
      if (lowN != null) parts.push(`Low-N ‚â§ ${lowN} Events`);

      if (!parts.length) return '';
      return `Regeln: ${parts.join(', ')}`;
    }

    function updateCallupExportButton(meta, candidates = []) {
      if (!callupExportBtn) return;
      const recommendedTotal = Number.isFinite(meta?.recommendedTotal) ? Number(meta.recommendedTotal) : null;
      const hasCandidates = Array.isArray(candidates) ? candidates.length > 0 : false;
      const suggestionRows = collectCallupSuggestionRows(state.callupSuggestions);
      const hasSuggestions = suggestionRows.length > 0;
      const enabled = hasSuggestions || hasCandidates || (recommendedTotal != null && recommendedTotal > 0);
      callupExportBtn.disabled = !enabled;
      callupExportBtn.title = enabled
        ? 'Callup-Kandidaten als CSV exportieren'
        : 'Keine Callup-Kandidaten im aktuellen Roster';
    }

    function collectCallupSuggestionRows(suggestions) {
      if (!suggestions || typeof suggestions !== 'object' || !suggestions.teams) return [];
      const rows = [];
      Object.entries(suggestions.teams).forEach(([team, data]) => {
        const list = Array.isArray(data?.suggestions) ? data.suggestions : [];
        list.forEach(item => {
          if (!item || typeof item !== 'object') return;
          rows.push({ ...item, recommended_team: team });
        });
      });
      return rows;
    }

    function extractCallupSuggestions(payload) {
      const block = payload && typeof payload === 'object' ? payload.callup_suggestions : null;
      if (!block || typeof block !== 'object') return null;
      const teams = (block.teams && typeof block.teams === 'object') ? block.teams : {};
      const normalizedTeams = {};
      Object.entries(teams).forEach(([team, data]) => {
        const suggestions = Array.isArray(data?.suggestions) ? data.suggestions : [];
        normalizedTeams[team] = {
          target_count: Number.isFinite(data?.target_count) ? Number(data.target_count) : null,
          suggestions: suggestions.filter(Boolean),
        };
      });
      return {
        schema: block.schema || 1,
        meta: block.meta || {},
        needs: block.needs || {},
        teams: normalizedTeams,
      };
    }

    function renderCallupSuggestions(suggestions) {
      if (!callupSuggestionsSection || !callupSuggestionsContent || !callupSuggestionsNote) return;
      if (!suggestions || !suggestions.teams || !Object.keys(suggestions.teams).length) {
        callupSuggestionsSection.style.display = 'none';
        callupSuggestionsContent.innerHTML = '';
        return;
      }

      const needs = (suggestions && typeof suggestions === 'object' && suggestions.needs) ? suggestions.needs : {};
      const attendance = state.latestPayload?.attendance || {};
      const expectedByTeam = attendance.expected_by_team || {};
      const targets = attendance.targets || {};
      const teamTargets = attendance.targets_by_team || {};
      const teamTargetDiffs = attendance.target_diff || {};
      const thresholdPercent = (() => {
        const raw = Number(suggestions?.meta?.min_attend_prob);
        const fallback = Number(attendance.threshold);
        const val = Number.isFinite(raw) ? raw : (Number.isFinite(fallback) ? fallback : 0.6);
        return Math.round(val * 100);
      })();
      const candidatePool = Number.isFinite(Number(suggestions?.meta?.candidates))
        ? Number(suggestions.meta.candidates)
        : null;

      const fmtNum = (val, digits = 1) => {
        const num = Number(val);
        return Number.isFinite(num) ? num.toFixed(digits) : '‚Äì';
      };
      const fmtInt = (val) => {
        const num = Number(val);
        return Number.isFinite(num) ? num.toFixed(0) : '‚Äì';
      };

      const buildDiff = (expected, target, diffOverride) => {
        const expectedNum = Number(expected);
        const targetNum = Number(target);
        const diffVal = Number.isFinite(diffOverride)
          ? Number(diffOverride)
          : (Number.isFinite(expectedNum) && Number.isFinite(targetNum) ? expectedNum - targetNum : null);
        if (!Number.isFinite(diffVal)) return { direction: null, abs: null };
        if (diffVal === 0) return { direction: 'im Ziel', abs: 0 };
        return { direction: diffVal < 0 ? 'unter' : '√ºber', abs: Math.abs(diffVal) };
      };

      const buildAutoCallupText = () => {
        if (candidatePool == null || candidatePool <= 0) {
          return `keine weiteren Spieler ‚â• ${thresholdPercent} % AttendProb im Pool.`;
        }
        return `${candidatePool} weitere Spieler ‚â• ${thresholdPercent} % AttendProb verf√ºgbar (√ºber Allianz-√úbersicht/Callup-Assistent).`;
      };

      const buildRecommendation = (expected, target) => {
        if (!Number.isFinite(expected) || !Number.isFinite(target)) return '';
        if (expected < 0.8 * target) {
          return 'deutlich unter Ziel ‚Äì aktiv Zusagen einsammeln und als Fixpl√§tze eintragen.';
        }
        if (expected < target) {
          return 'knapp unter Ziel ‚Äì bei Gelegenheit 1‚Äì2 sichere Zusagen zus√§tzlich einholen.';
        }
        return 'Ziel erreicht ‚Äì weitere Zusagen optional, aber nicht n√∂tig.';
      };

      const cards = Object.entries(suggestions.teams).map(([team, data]) => {
        const needMeta = needs[team] || {};
        const plannedSlots = needMeta.planned_slots || {};
        const targetSlots = needMeta.target_slots || {};
        const startersUsed = Number(plannedSlots.Start);
        const benchUsed = Number(plannedSlots.Ersatz);
        const startersTotal = Number(targetSlots.Start);
        const benchTotal = Number(targetSlots.Ersatz);
        const expected = Number(expectedByTeam?.[team]?.total ?? needMeta.expected_attendance?.total);
        const targetFromCallup = Number(data?.target_count);
        const targetRange = targets?.[team];
        const targetAttendance = Number.isFinite(teamTargets?.[team])
          ? Number(teamTargets[team])
          : (Number.isFinite(targetFromCallup) ? targetFromCallup : (Number.isFinite(targetRange?.low) ? targetRange.low : null));
        const diff = buildDiff(expected, targetAttendance, teamTargetDiffs?.[team]);
        const autoCallupText = buildAutoCallupText();
        const recommendation = buildRecommendation(expected, targetAttendance);
        const diffLabel = (() => {
          if (!diff.direction) return '‚Äì';
          if (diff.direction === 'im Ziel') return 'im Ziel';
          return `${diff.abs?.toFixed(1) ?? '‚Äì'} ${diff.direction} Ziel`;
        })();

        return `
          <div class="callup-suggestion-card">
            <h3>Team ${escapeHtml(team)} ‚Äì Anwesenheit (n√§chstes Event)</h3>
            <p style="margin:0 0 4px">Erwartete Anwesenheit: ${fmtNum(expected)} Spieler</p>
            <p style="margin:0 0 4px">Soll-Anwesenheit: ${fmtNum(targetAttendance, 0)} Spieler (${diffLabel})</p>
            <p style="margin:0 0 4px">Slots: Start ${fmtInt(startersUsed)}/${fmtInt(startersTotal)}, Ersatz ${fmtInt(benchUsed)}/${fmtInt(benchTotal)}</p>
            <p style="margin:0 0 4px">Auto-Callup: ${escapeHtml(autoCallupText)}</p>
            <p style="margin:0">Empfehlung: ${escapeHtml(recommendation || '')}</p>
          </div>
        `;
      });

      callupSuggestionsContent.innerHTML = `<div class="callup-suggestion-grid">${cards.join('')}</div>`;
      callupSuggestionsSection.style.display = 'block';
      callupSuggestionsNote.textContent = suggestions.meta?.note || 'Zus√§tzliche Kandidaten zum Auff√ºllen aus Attendance-Sicht (erg√§nzend zu üîî-Badges).';
    }

    function splitCsvLine(line) {
      const out = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (inQuotes) {
          if (char === '"') {
            if (line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            current += char;
          }
        } else if (char === '"') {
          inQuotes = true;
        } else if (char === ',') {
          out.push(current);
          current = "";
        } else {
          current += char;
        }
      }
      out.push(current);
      return out;
    }

    function parseCsv(text) {
      const cleaned = (text || "").replace(/^\ufeff/, "").split(/\r?\n/);
      const lines = cleaned.filter(line => line && line.trim().length);
      if (!lines.length) return [];
      const headers = splitCsvLine(lines.shift()).map(h => h.trim());
      return lines.map(line => {
        const cells = splitCsvLine(line);
        const obj = {};
        headers.forEach((header, idx) => {
          obj[header] = cells[idx] != null ? cells[idx].trim() : "";
        });
        return obj;
      });
    }

    function parseDateOnly(value) {
      if (!value) return null;
      const trimmed = String(value).trim();
      if (!trimmed) return null;
      const date = new Date(trimmed);
      if (Number.isNaN(date.getTime())) return null;
      return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
    }

    function escapeCsvCell(value) {
      const str = value == null ? '' : String(value);
      const escaped = str.replace(/"/g, '""');
      return `"${escaped}"`;
    }

    function buildCallupCsvFilename(payload) {
      const rawStamp = (payload && typeof payload.generated_at === 'string' && payload.generated_at.trim())
        ? payload.generated_at
        : new Date().toISOString();
      const safe = rawStamp.replace(/[:T]/g, '-').replace(/\..*/, '').replace(/Z$/, '');
      return `callup_candidates-${safe}.csv`;
    }

    function collectCallupCandidates(playersArray) {
      const list = Array.isArray(playersArray) ? playersArray : [];
      return list.filter(p => {
        if (!p || typeof p !== 'object') return false;
        const callup = normalizeCallup(p);
        const recommended = callup ? callup.recommended === true : Boolean(p.callup_recommended);
        return recommended;
      });
    }

    function exportCallupCandidatesCsv(payload, candidates) {
      if (!Array.isArray(candidates) || !candidates.length) return;

      const formatRatio = (val) => {
        const num = toNumber(val);
        return num == null ? '' : num.toFixed(3);
      };

      const header = [
        'PlayerName',
        'Group',
        'Role',
        'EventsSeen',
        'NoShowsTotal',
        'NoShowOverall',
        'NoShowRolling',
        'CallupReason',
        'LastSeenDate',
        'LastNoShowDate',
      ];

      const rows = candidates.map(p => {
        const callup = normalizeCallup(p);
        const reason = callup ? formatCallupReasons(callup) : '';
        const eventsSeen = toNumber(p.events_seen) ?? '';
        const noShowCount = toNumber(p.noshow_count_overall ?? p.noshow_count) ?? '';
        const lastSeen = p.last_seen || p.LastSeenDate || '';
        const lastNoShow = p.last_noshow_date || p.LastNoShowDate || '';
        return [
          p.display || p.PlayerName || '',
          p.group || p.Group || '',
          p.role || p.Role || '',
          eventsSeen,
          noShowCount,
          formatRatio(p.noshow_overall ?? p.NoShowOverall),
          formatRatio(p.noshow_rolling ?? p.NoShowRolling),
          reason,
          lastSeen,
          lastNoShow,
        ];
      });

      const csvLines = [header, ...rows]
        .map(line => line.map(escapeCsvCell).join(','))
        .join('\n');

      const blob = new Blob([csvLines], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = buildCallupCsvFilename(payload);
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportSuggestedCallupsCsv(payload, suggestions) {
      const rows = collectCallupSuggestionRows(suggestions);
      if (!rows.length) return false;

      const header = [
        'PlayerName',
        'RecommendedTeam',
        'RecommendedRole',
        'AttendProb',
        'EventsSeen',
        'Risk',
        'NextEventStatus',
        'Reason',
      ];

      const csvLines = [header, ...rows.map(item => [
        item.display || item.canon || '',
        item.recommended_team || '',
        item.recommended_role || '',
        Number.isFinite(Number(item.attend_prob)) ? Number(item.attend_prob).toFixed(3) : '',
        Number.isFinite(Number(item.events_seen)) ? Number(item.events_seen) : '',
        item.risk || '',
        item.next_event_status || '',
        item.reason || '',
      ])].map(line => line.map(escapeCsvCell).join(',')).join('\n');

      const blob = new Blob([csvLines], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = buildCallupCsvFilename(payload).replace('callup_candidates', 'callup_suggestions');
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      return true;
    }

    function normalizeAllianceOverview(block) {
      const players = Array.isArray(block?.players)
        ? block.players.filter(p => p && typeof p === 'object')
        : [];
      const meta = (block && typeof block.meta === 'object') ? block.meta : {};
      return { players, meta };
    }

    function formatPercent(val) {
      const num = toNumber(val);
      if (num == null || Number.isNaN(num)) return '‚Äì';
      return `${Math.round(num * 100)}%`;
    }

    function formatEventStatus(status) {
      switch (status) {
        case 'hard_commitment': return 'Hard-Commit';
        case 'decline': return 'Absage';
        case 'no_response': return 'No-Response';
        case 'signup': return 'Signup';
        default: return '‚Äì';
      }
    }

    function buildAdminLink(playerName) {
      const safeName = encodeURIComponent(playerName || '');
      const href = `${SITE_ROOT}admin/event-assignments.html${safeName ? `?player=${safeName}` : ''}`;
      return `<a class="admin-inline-link" href="${href}" title="Antwort/Zusage im Admin erfassen" target="_blank" rel="noopener">‚úèÔ∏è</a>`;
    }

    function renderContactChip(rec) {
      const value = typeof rec === 'string' ? rec.toLowerCase() : '';
      let cls = 'contact-maybe';
      let icon = '‚ùî';
      let label = value || 'maybe';
      if (value === 'yes') { cls = 'contact-yes'; icon = '‚úÖ'; label = 'yes'; }
      else if (value === 'no') { cls = 'contact-no'; icon = '‚õî'; label = 'no'; }
      else if (value === 'former') { cls = 'contact-former'; icon = 'üëã'; label = 'ex'; }
      return `<span class="contact-chip ${cls}">${icon} ${escapeHtml(label)}</span>`;
    }

    function buildAllianceFilterSummary({ filteredActive, filteredFormer, totalActive, totalFormer, filters }) {
      const parts = [];
      if (filters.contactYesOnly) parts.push('Kontakt=yes');
      if (filters.hideRoster) parts.push('nicht im Roster');
      if (filters.hideAbsent) parts.push('nicht abwesend');
      parts.push(filters.showFormer ? 'Ex-Mitglieder eingeblendet' : 'Ex-Mitglieder ausgeblendet');
      const filterText = parts.length ? `Filter: ${parts.join(', ')}` : 'Keine Filter';
      const baseTotal = Number.isFinite(Number(totalActive)) ? Number(totalActive) : 0;
      const formerTotal = Number.isFinite(Number(totalFormer)) ? Number(totalFormer) : 0;
      const effectiveTotal = baseTotal || (filteredActive + filteredFormer);
      const shownLabel = filteredFormer ? `${filteredActive} (+${filteredFormer} Ex)` : `${filteredActive}`;
      const totalLabel = formerTotal && filters.showFormer ? `${effectiveTotal}` : `${effectiveTotal}`;
      return `${shownLabel} von ${totalLabel} Spielern angezeigt ‚Äì ${filterText}.`;
    }

    function renderAllianceStatus(player) {
      const active = Boolean(player?.in_alliance);
      const label = active ? 'Aktiv' : 'Ex-Mitglied';
      const cls = active ? 'status-active' : 'status-former';
      return `<span class="alliance-status"><span class="${cls}">${label}</span></span>`;
    }

    function buildAllianceRows(players, meta) {
      const filters = state.allianceFilters || {};
      const totalActive = Number.isFinite(Number(meta?.players_active))
        ? Number(meta.players_active)
        : players.filter(p => p && p.in_alliance).length;
      const totalFormer = Number.isFinite(Number(meta?.players_former))
        ? Number(meta.players_former)
        : players.filter(p => p && !p.in_alliance).length;
      const filtered = players.filter(p => {
        if (!filters.showFormer && !p.in_alliance) return false;
        if (filters.contactYesOnly && (p.contact_recommendation || '').toLowerCase() !== 'yes') return false;
        if (filters.hideRoster && p.roster_status && p.roster_status !== '-') return false;
        if (filters.hideAbsent && p.is_absent_next_event) return false;
        return true;
      });

      const filteredActive = filtered.filter(p => p.in_alliance).length;
      const filteredFormer = filtered.length - filteredActive;
      const summaryText = buildAllianceFilterSummary({
        filteredActive,
        filteredFormer,
        totalActive,
        totalFormer,
        filters,
      });

      if (!filtered.length) return { tableHtml: '<p class="muted">Keine Spieler f√ºr die aktuellen Filter.</p>', summaryText };

      const rows = filtered.map(p => {
        const rosterStatus = p.roster_status && p.roster_status !== '-' ? escapeHtml(p.roster_status) : '‚Äì';
        const eventStatus = formatEventStatus(p.event_status);
        const absenceInfo = p.is_absent_next_event
          ? `Abwesend${p.absence?.reason ? ' ‚Äì ' + escapeHtml(p.absence.reason) : ''}`
          : '‚Äì';
        const attendProb = formatPercent(p.attend_prob);
        const nsOverall = formatPercent(p.noshow_overall);
        const nsRolling = formatPercent(p.noshow_rolling);
        const flags = [];
        if (p.flags?.no_data) flags.push('<span class="tag tag-nd" title="Keine Historie">No Data</span>');
        else if (p.flags?.low_n) flags.push('<span class="tag tag-low" title="Wenig Historie">low n</span>');
        const noshowText = `${nsOverall} (${nsRolling} rolling)`;
        const rowClass = p.in_alliance ? '' : ' class="ex-member"';
        return `<tr${rowClass}>
          <td>${escapeHtml(p.display || p.canon || '')}</td>
          <td>${renderAllianceStatus(p)}</td>
          <td>${rosterStatus}</td>
          <td>${escapeHtml(eventStatus)}</td>
          <td>${absenceInfo}</td>
          <td class="num">${attendProb}<br/><span class="muted">No-Show ${noshowText}</span> ${flags.join(' ')}</td>
          <td>${renderContactChip(p.contact_recommendation)}</td>
          <td>${buildAdminLink(p.display || p.canon || '')}</td>
        </tr>`;
      }).join('');

      const thresholdInfo = Number.isFinite(Number(meta?.callup_min_attend_prob))
        ? `<span class="muted">Kontakt = yes ab AttendProb ‚â• ${(Number(meta.callup_min_attend_prob) * 100).toFixed(0)}%, nur aktive Mitglieder ohne Absage/Absenz.</span>`
        : '';

      return {
        tableHtml: `<table>
        <thead>
          <tr><th>Spieler</th><th>Allianz</th><th>Team/Rolle</th><th>Event-Status</th><th>Absenz</th><th>Attendance / No-Show</th><th>Kontakt</th><th>Admin</th></tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>${thresholdInfo ? `<div class="muted" style="margin-top:6px;">${thresholdInfo}</div>` : ''}`,
        summaryText,
      };
    }

    function renderAllianceOverview() {
      if (!allianceTable) return;
      const overview = state.allianceOverview;
      if (!overview || !Array.isArray(overview.players)) {
        allianceTable.textContent = 'Keine Allianz-Daten in latest.json gefunden.';
        if (allianceSummary) allianceSummary.textContent = '';
        return;
      }
      if (!overview.players.length) {
        allianceTable.textContent = 'Keine Allianz-Spieler vorhanden.';
        if (allianceSummary) allianceSummary.textContent = '';
        return;
      }
      const rendered = buildAllianceRows(overview.players, overview.meta);
      allianceTable.innerHTML = rendered.tableHtml;
      if (allianceSummary) {
        allianceSummary.textContent = rendered.summaryText || '';
        allianceSummary.style.display = rendered.summaryText ? 'block' : 'none';
      }
      if (allianceExportBtn) allianceExportBtn.disabled = false;
    }

    function buildAllianceCsvFilename(payload) {
      const rawStamp = (payload && typeof payload.generated_at === 'string' && payload.generated_at.trim())
        ? payload.generated_at
        : new Date().toISOString();
      const safe = rawStamp.replace(/[:T]/g, '-').replace(/\..*/, '').replace(/Z$/, '');
      return `alliance_overview-${safe}.csv`;
    }

    function exportAllianceOverviewCsv() {
      const overview = state.allianceOverview;
      if (!overview || !Array.isArray(overview.players) || !overview.players.length) return;
      const header = ['PlayerName', 'InAlliance', 'RosterStatus', 'EventStatus', 'Absent', 'AttendProb', 'NoShowOverall', 'NoShowRolling', 'EventsSeen', 'ContactRecommendation'];
      const rows = overview.players.map(p => [
        p.display || p.canon || '',
        p.in_alliance ? '1' : '0',
        p.roster_status || '-',
        formatEventStatus(p.event_status),
        p.is_absent_next_event ? 'absent' : '',
        Number.isFinite(Number(p.attend_prob)) ? Number(p.attend_prob).toFixed(3) : '',
        Number.isFinite(Number(p.noshow_overall)) ? Number(p.noshow_overall).toFixed(3) : '',
        Number.isFinite(Number(p.noshow_rolling)) ? Number(p.noshow_rolling).toFixed(3) : '',
        Number.isFinite(Number(p.events_seen)) ? Number(p.events_seen) : '',
        p.contact_recommendation || '',
      ]);
      const csv = [header, ...rows]
        .map(line => line.map(escapeCsvCell).join(','))
        .join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = buildAllianceCsvFilename(state.latestPayload);
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function parseInAllianceFlag(value) {
      if (value == null) return false;
      const normalized = String(value).trim().toLowerCase();
      // "InAlliance" kennzeichnet die Allianz-Mitgliedschaft (1 = im Roster, 0 = ausgetreten).
      return ["1","true","yes","y","aktiv","active"].includes(normalized);
    }

    function normalizeAbsenceFromPayload(row) {
      const playerName = (
        row?.name ?? row?.Name ?? row?.player ?? row?.PlayerName ?? row?.display ?? ""
      ).toString().trim();
      const from = (row?.from ?? row?.From ?? "").toString().trim();
      const to = (row?.to ?? row?.To ?? "").toString().trim();
      const reason = (row?.reason ?? row?.Reason ?? "").toString().trim();
      const inAlliance = row?.in_alliance ?? row?.InAlliance ?? row?.Active ?? row?.active ?? 1;
      const activeFlagRaw = row?.is_active_next_event ?? row?.isActive ?? row?.active;
      const isActiveNextEvent = typeof activeFlagRaw === 'boolean' ? activeFlagRaw : null;
      const scopeRaw = (row?.scope ?? row?.Scope ?? '').toString().trim().toLowerCase();
      return {
        playerName,
        canon: canonicalNameJS(row?.canonical || playerName),
        from,
        to,
        fromDate: parseDateOnly(from),
        toDate: parseDateOnly(to),
        reason,
        inAlliance: parseInAllianceFlag(inAlliance),
        scope: scopeRaw || 'next_event',
        isActiveNextEvent,
      };
    }

    function normalizeAbsenceRow(row) {
      const playerName = (row?.PlayerName ?? row?.playername ?? "").toString().trim();
      const from = (row?.From ?? row?.from ?? "").toString().trim();
      const to = (row?.To ?? row?.to ?? "").toString().trim();
      const reason = (row?.Reason ?? row?.reason ?? "").toString().trim();
      const activeFlag =
        row?.InAlliance ?? row?.inalliance ?? row?.Active ?? row?.active;
      const scopeRaw = (row?.Scope ?? row?.scope ?? '').toString().trim().toLowerCase();
      return {
        playerName,
        canon: canonicalNameJS(playerName),
        from,
        to,
        fromDate: parseDateOnly(from),
        toDate: parseDateOnly(to),
        reason,
        inAlliance: parseInAllianceFlag(activeFlag),
        scope: scopeRaw,
      };
    }

    function todayDateUTC() {
      const now = new Date();
      return new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    }

    function computeActiveAbsences(entries) {
      const today = todayDateUTC();
      const todayMs = today.getTime();
      return entries.filter(entry => {
        if (!entry.inAlliance) {
          return false; // Nur Spieler, die noch zur Allianz geh√∂ren, tauchen in der √úbersicht auf.
        }
        const scopeNext = (entry.scope || '').toString().trim().toLowerCase() === 'next_event';
        const openRange = !entry.fromDate && !entry.toDate;
        if (scopeNext || openRange) {
          return true;
        }
        if (entry.fromDate && entry.fromDate.getTime() > todayMs) {
          return false;
        }
        if (entry.toDate && entry.toDate.getTime() < todayMs) {
          return false;
        }
        return true;
      });
    }

    function formatAbsenceRange(entry) {
      const from = entry.from || "‚Äì";
      const to = entry.to || "‚Äì";
      if (!entry.from && !entry.to) return "‚Äì";
      return `${from} ‚Äì ${to}`;
    }

    function dedupeActiveAbsenceEntries(entries = []) {
      const byCanon = new Map();
      entries.forEach(entry => {
        if (!entry || typeof entry !== 'object') return;
        const isActive = Boolean(entry.is_absent_next_event || entry.isActiveNextEvent);
        if (!isActive) return;
        const canon = canonicalNameJS(entry.canonical || entry.canon || entry.display || entry.name || '');
        if (!canon) return;
        const display = entry.display || entry.name || entry.PlayerName || canon;
        const range = {
          from: entry.from ?? entry.From ?? '',
          to: entry.to ?? entry.To ?? '',
          reason: entry.reason ?? entry.Reason ?? '',
          scope: entry.scope ?? entry.Scope ?? '',
        };
        const existing = byCanon.get(canon);
        if (existing) {
          existing.ranges.push(range);
          if ((!existing.display || existing.display === canon) && display) {
            existing.display = display;
          }
          existing.in_alliance = existing.in_alliance || Boolean(entry.in_alliance || entry.InAlliance || entry.inAlliance);
        } else {
          byCanon.set(canon, {
            canonical: canon,
            display,
            active: true,
            ranges: [range],
            in_alliance: Boolean(entry.in_alliance || entry.InAlliance || entry.inAlliance),
          });
        }
      });
      return Array.from(byCanon.values()).sort((a, b) => {
        const left = (a.display || a.canonical || '').toString();
        const right = (b.display || b.canonical || '').toString();
        return left.localeCompare(right);
      });
    }

    function formatAggregatedRangeLabel(entry) {
      const ranges = Array.isArray(entry?.ranges) ? entry.ranges : [];
      if (!ranges.length) return 'Zeitraum offen';
      const formatted = ranges
        .map(r => formatAbsenceRange({ from: r?.from, to: r?.to }))
        .filter(Boolean);
      if (!formatted.length) return 'Zeitraum offen';
      const suffix = ranges.length > 1 ? ` (${ranges.length} Zeitr√§ume)` : '';
      return `${formatted[0]}${suffix}`;
    }

    function extractAggregatedReason(entry) {
      const ranges = Array.isArray(entry?.ranges) ? entry.ranges : [];
      const reasons = ranges
        .map(r => (r?.reason || '').toString().trim())
        .filter(Boolean);
      if (reasons.length) return reasons[0];
      const fallback = (entry?.reason || '').toString().trim();
      return fallback || '‚Äì';
    }

    function rosterBadgeFor(entry) {
      const meta = state.playersByCanon[entry.canon];
      if (!meta) return "";
      const parts = [];
      if (meta.group) parts.push(`Gruppe ${meta.group}`);
      if (meta.role) parts.push(meta.role);
      const text = parts.join(" ¬∑ ");
      return text ? `<span class="absences-roster-badge">im Roster${text ? ` ¬∑ ${escapeHtml(text)}` : ""}</span>` : "";
    }

    function updateAbsencesUI() {
      if (!absencesContainer) return;
      const { loading, error, active } = state.absences;
      if (loading) {
        absencesContainer.textContent = "Wird geladen ‚Ä¶";
        return;
      }
      if (error) {
        absencesContainer.innerHTML = `<p class="absences-error">Absenzen konnten nicht geladen werden (${escapeHtml(error.message || error)})</p>`;
        return;
      }
      if (!active.length) {
        absencesContainer.innerHTML = '<p class="absences-empty">Aktuell sind keine Absenzen erfasst.</p>';
        return;
      }
      const rows = active.map(entry => {
        const rosterMeta = state.playersByCanon[entry.canon];
        const label = rosterMeta?.display || entry.playerName || "Unbekannt";
        const badge = rosterBadgeFor(entry);
        const status = entry.isActiveNextEvent === false ? "geplant" : "aktiv";
        return `
          <tr>
            <td>${escapeHtml(label)}${badge}</td>
            <td>${escapeHtml(formatAbsenceRange(entry))}</td>
            <td>${entry.reason ? escapeHtml(entry.reason) : "‚Äì"}</td>
            <td>${escapeHtml(status)}</td>
          </tr>
        `;
      }).join("");
      absencesContainer.innerHTML = `
        <table>
          <thead>
            <tr><th>Spieler</th><th>Zeitraum</th><th>Grund</th><th>Status</th></tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;
    }

    function updateEventResponsesUI() {
      if (!eventResponsesContainer) return;
      const data = state.eventResponses || {};
      if (data.loading) {
        eventResponsesContainer.textContent = "Wird geladen ‚Ä¶";
        return;
      }
      if (data.error) {
        eventResponsesContainer.innerHTML = `<p class="absences-error">Event-Antworten konnten nicht geladen werden (${escapeHtml(data.error.message || data.error)})</p>`;
        return;
      }
      const declines = Array.isArray(data.declines) ? data.declines : [];
      const penalties = Array.isArray(data.penalties) ? data.penalties : [];
      const conflicts = Array.isArray(state.eventResponseConflicts) ? state.eventResponseConflicts : [];
      if (!declines.length && !penalties.length && !conflicts.length) {
        eventResponsesContainer.innerHTML = '<p class="absences-empty">Keine event-spezifischen Absagen oder No-Responses erfasst.</p>';
        return;
      }
      let html = '';
      if (declines.length) {
        const items = declines.map(entry => `<li><strong>${escapeHtml(entry.display || entry.canon || 'Unbekannt')}</strong> ‚Äî Absage${entry.source ? ` (${escapeHtml(entry.source)})` : ''}</li>`).join('');
        html += `<p><strong>Absagen (${declines.length})</strong></p><ul class="absence-list">${items}</ul>`;
      }
      if (penalties.length) {
        const items = penalties.map(entry => {
          const penalty = (typeof entry.risk_penalty === 'number') ? ` ¬∑ Risiko+${entry.risk_penalty.toFixed(2)}` : '';
          return `<li><strong>${escapeHtml(entry.display || entry.canon || 'Unbekannt')}</strong> ‚Äî keine Antwort${penalty}${entry.source ? ` (${escapeHtml(entry.source)})` : ''}</li>`;
        }).join('');
        html += `<p><strong>Keine Antwort / Unsicher (${penalties.length})</strong></p><ul class="absence-list">${items}</ul>`;
      }
      if (conflicts.length) {
        const items = conflicts.map(c => `<li><strong>${escapeHtml(c.display || c.canonical || 'Unbekannt')}</strong> ‚Äî Konflikt: ${escapeHtml(c.note || 'hard commitment + event response')}</li>`).join('');
        html += `<p><strong>Konflikte</strong></p><ul class="absence-list">${items}</ul>`;
      }
      const stats = data.stats || {};
      if (stats && typeof stats === 'object') {
        const summary = [
          stats.removed_from_pool ? `${stats.removed_from_pool} nicht ber√ºcksichtigt` : null,
          stats.penalties ? `${stats.penalties} mit Risikoaufschlag` : null,
        ].filter(Boolean).join(' ¬∑ ');
        if (summary) {
          html += `<p class="muted">Wirkung im Roster: ${escapeHtml(summary)}</p>`;
        }
      }
      eventResponsesContainer.innerHTML = html || '<p class="absences-empty">Keine event-spezifischen Antworten erfasst.</p>';
    }

    function renderAbsenceDiagnostics(debugBlock, conflicts = []) {
      if (!absenceDiag) return;
      const hasDebug = debugBlock && typeof debugBlock === 'object';
      if (!hasDebug) {
        absenceDiag.style.display = 'none';
        absenceDiag.innerHTML = '';
        return;
      }

      const stats = (debugBlock.stats && typeof debugBlock.stats === 'object') ? debugBlock.stats : {};
      const rawCount = Number(
        stats.file_entries ?? stats.total_entries ??
        debugBlock.raw_count ?? debugBlock.rawCount ?? debugBlock.total_entries ?? 0
      );
      const activeCount = Number(
        stats.active_for_next_event ??
        debugBlock.active_for_next_event ?? debugBlock.activeEntries ?? debugBlock.active_entries ?? 0
      );
      const uniquePlayers = Number(
        stats.unique_active_players ??
        (Array.isArray(debugBlock.next_event_absences) ? debugBlock.next_event_absences.length : NaN)
      );
      const fileEntries = Array.isArray(debugBlock.file_entries)
        ? debugBlock.file_entries
        : (Array.isArray(debugBlock.players) ? debugBlock.players : []);
      const aggregatedEntries = Array.isArray(debugBlock.next_event_absences)
        ? debugBlock.next_event_absences
        : [];
      const source = (debugBlock.source || '').toString();
      const summaryParts = [];
      if (!Number.isNaN(rawCount)) summaryParts.push(`Datei-Eintr√§ge: ${rawCount}`);
      if (!Number.isNaN(activeCount)) summaryParts.push(`f√ºr n√§chstes Event aktiv: ${activeCount}`);
      if (!Number.isNaN(uniquePlayers)) summaryParts.push(`aktive Spieler: ${uniquePlayers}`);
      if (source) summaryParts.push(`Quelle: ${escapeHtml(source)}`);

      let html = '<h4>Absenzen (n√§chstes Event ‚Äì √úbersicht & Diagnostik)</h4>';
      html += `<p>${summaryParts.join(' ¬∑ ')}</p>`;

      const activeEntries = aggregatedEntries.length ? aggregatedEntries : dedupeActiveAbsenceEntries(fileEntries);
      if (activeEntries.length) {
        const items = activeEntries.map(p => {
          const canon = canonicalNameJS(p?.canonical || p?.canon || '');
          const display = p?.display || canon || 'Unbekannt';
          const range = formatAggregatedRangeLabel(p);
          const reasonRaw = extractAggregatedReason(p);
          const reason = reasonRaw ? escapeHtml(reasonRaw) : '‚Äì';
          const isActive = Boolean(p?.active ?? true);
          const statusLabel = isActive ? 'aktiv' : 'geplant';
          const badgeClass = isActive ? 'tag tag-abs-active' : 'tag tag-abs-planned';
          return `
            <li>
              <strong>${escapeHtml(display)}</strong> <span class="${badgeClass}">${statusLabel}</span><br />
              <span class="muted">${escapeHtml(range)} ¬∑ Grund: ${reason}</span>
            </li>
          `;
        }).join('');
        html += `<ul class="absence-list">${items}</ul>`;
      } else {
        html += '<p class="muted">Keine aktiven Absenzen f√ºr das n√§chste Event laut Builder.</p>';
      }

      const conflictsSafe = Array.isArray(conflicts) ? conflicts : [];
      if (conflictsSafe.length) {
        const items = conflictsSafe.map(c => {
          const canon = canonicalNameJS(c?.canonical || '');
          const label = c?.display || canon || 'Unbekannt';
          return `<li class="warn">${escapeHtml(label)} ‚Äî hard commitment + Absenz</li>`;
        }).join('');
        html += `<p class="warn">Konflikte: Fixplatz & Absenzen</p><ul>${items}</ul>`;
      }

      absenceDiag.innerHTML = html;
      absenceDiag.style.display = 'block';
    }

    function fetchAbsences() {
      state.absenceDebug = null;
      state.absenceConflicts = [];
      renderAbsenceDiagnostics(null, []);
      state.absences.loading = true;
      state.absences.error = null;
      updateAbsencesUI();
      const absencesUrl = `https://raw.githubusercontent.com/its-h4k1/desert-storm-roster-optimizer/${branch}/data/absences.csv${cacheBuster}`;
      fetch(absencesUrl, { cache: "no-store" })
        .then(r => { if (!r.ok) throw new Error(r.status + " " + r.statusText); return r.text(); })
        .then(text => {
          const parsed = parseCsv(text);
          const normalized = parsed.map(normalizeAbsenceRow).filter(row => row.playerName);
          state.absences.entries = normalized;
          state.absences.active = computeActiveAbsences(normalized);
          state.absences.error = null;
        })
        .catch(err => {
          state.absences.entries = [];
          state.absences.active = [];
          state.absences.error = err;
        })
        .finally(() => {
          state.absences.loading = false;
          updateAbsencesUI();
        });
    }

    function applyAbsencesFromPayload(absencesBlock) {
      if (!absencesBlock || typeof absencesBlock !== 'object' || !Array.isArray(absencesBlock.players)) {
        return false;
      }
      const normalized = absencesBlock.players
        .map(normalizeAbsenceFromPayload)
        .filter(entry => entry.playerName);
      const activeFallback = computeActiveAbsences(normalized);
      const activeSet = new Set(activeFallback.map(item => item.canon));
      const active = normalized.filter(entry => {
        if (typeof entry.isActiveNextEvent === 'boolean') return entry.isActiveNextEvent;
        if (entry.scope === 'next_event') return true;
        return activeSet.has(entry.canon);
      });
      state.absences.entries = normalized;
      state.absences.active = active;
      state.absences.error = null;
      state.absences.loading = false;
      updateAbsencesUI();
      return true;
    }

    function applyEventResponsesFromPayload(block) {
      if (!block || typeof block !== 'object') {
        return false;
      }
      const normalizeEntry = (entry) => {
        if (!entry || typeof entry !== 'object') return null;
        return {
          display: entry.display || entry.name || entry.player || '',
          canon: canonicalNameJS(entry.canonical || entry.canon || entry.player || ''),
          status: entry.status || '',
          source: entry.source || '',
          note: entry.note || entry.reason || '',
          risk_penalty: typeof entry.risk_penalty === 'number' ? entry.risk_penalty : null,
        };
      };

      const declines = Array.isArray(block.removed_from_pool) ? block.removed_from_pool.map(normalizeEntry).filter(Boolean) : [];
      const penalties = Array.isArray(block.penalty_applied) ? block.penalty_applied.map(normalizeEntry).filter(Boolean) : [];
      const entries = Array.isArray(block.file_entries) ? block.file_entries.map(normalizeEntry).filter(Boolean) : [];
      state.eventResponses = {
        entries,
        declines,
        penalties,
        stats: block.stats || {},
        source: block.source || '',
        loading: false,
        error: null,
      };
      state.eventResponseConflicts = Array.isArray(block.event_response_conflicts)
        ? block.event_response_conflicts
        : (Array.isArray(block.conflicts) ? block.conflicts : []);
      updateEventResponsesUI();
      return true;
    }

    function extractSignupStats(meta) {
      const toNum = (value) => {
        const n = Number(value);
        return Number.isFinite(n) ? n : null;
      };
      if (!meta || typeof meta !== 'object') {
        return {
          source: '',
          totalEntries: null,
          hardTotal: null,
          hardApplied: null,
          forcedTotal: null,
          forcedInRoster: null,
          forcedOutOfRoster: null,
          hardInvalid: null,
          hardOverbooked: null,
          extraTotal: null,
          extraByGroup: null,
          missingHard: null,
          inRosterHard: null,
        };
      }
      const hardTotal = toNum(meta.hard_commit_rows_total ?? meta.hard_commit_total ?? meta.hard_commitments_total ?? meta.hard_commitments);
      const hardApplied = toNum(meta.hard_commit_applied ?? meta.hard_commitments_applied);
      const hardInvalid = toNum(meta.hard_commit_invalid ?? meta.hard_commitments_invalid);
      const hardOverbooked = toNum(meta.hard_commit_overbooked ?? meta.hard_commitments_overbooked);
      const missingHard = toNum(meta.hard_commit_missing_from_roster ?? meta.hard_commitments_missing_from_roster);
      const forcedTotal = toNum(meta.forced_total);
      const forcedInRoster = toNum(meta.forced_in_roster ?? meta.in_roster_hard_commitments);
      const forcedOutOfRoster = toNum(meta.forced_out_of_roster);

      return {
        source: meta.source || '',
        totalEntries: toNum(
          meta.file_rows_total
          ?? meta.file_entries_total
          ?? meta.processed_entries_total
          ?? meta.total_entries
          ?? meta.rows_with_canon
          ?? meta.rows_with_playername
          ?? meta.raw_rows
        ),
        hardTotal,
        hardApplied,
        forcedTotal,
        forcedInRoster,
        forcedOutOfRoster: forcedOutOfRoster != null
          ? forcedOutOfRoster
          : (Number.isFinite(forcedTotal) && Number.isFinite(forcedInRoster)
            ? Math.max(0, forcedTotal - forcedInRoster)
            : null),
        hardInvalid,
        hardOverbooked,
        extraTotal: toNum(meta.extra_entries_total),
        extraByGroup: (meta.extra_entries_by_group && typeof meta.extra_entries_by_group === 'object') ? meta.extra_entries_by_group : null,
        missingHard,
        inRosterHard: forcedInRoster,
      };
    }

    function renderExtraSignups(extraData, meta, diagnostics = {}) {
      if (!extraRoot) return;
      const groups = ['A','B'];
      const stats = extractSignupStats(meta);
      const extraCount = Number.isFinite(stats.extraTotal)
        ? Number(stats.extraTotal)
        : groups.reduce((sum, g) => sum + (Array.isArray(extraData[g]) ? extraData[g].length : 0), 0);
      const totalEntries = Number.isFinite(stats.totalEntries) ? stats.totalEntries : extraCount;
      const forcedInRoster = Number.isFinite(stats.forcedInRoster)
        ? stats.forcedInRoster
        : (Number.isFinite(stats.inRosterHard)
          ? stats.inRosterHard
          : (Number.isFinite(stats.hardApplied) ? stats.hardApplied : null));
      const forcedOutOfRoster = Number.isFinite(stats.forcedOutOfRoster) ? stats.forcedOutOfRoster : null;
      const summaryParts = [];
      if (Number.isFinite(totalEntries)) summaryParts.push(`${totalEntries} Eintr√§ge`);
      if (Number.isFinite(stats.hardTotal)) {
        const suffixBits = [];
        if (forcedInRoster != null) suffixBits.push(`${forcedInRoster} im Roster`);
        if (forcedOutOfRoster) suffixBits.push(`${forcedOutOfRoster} au√üerhalb`);
        const suffix = suffixBits.length ? ` (${suffixBits.join(', ')})` : '';
        summaryParts.push(`${stats.hardTotal} verbindliche Zusagen${suffix}`);
      }
      if (!extraCount) summaryParts.push('keine zus√§tzlichen Zusagen au√üerhalb des Rosters');
      const summaryText = summaryParts.length ? `Zusage-Pool (n√§chstes Event): ${summaryParts.join(' ¬∑ ')}` : '';
      if (signupInline) {
        signupInline.textContent = summaryText;
        signupInline.style.display = (!extraCount && summaryText) ? 'block' : 'none';
      }

      const hasDiagnostics = Boolean((diagnostics.forced || []).length || (diagnostics.invalid || []).length || (diagnostics.overbooked || []).length);
      const extrasSection = document.getElementById('extras');
      const shouldShowSection = extraCount > 0 || hasDiagnostics || Boolean(summaryText);
      if (!shouldShowSection) {
        if (extrasSection) extrasSection.style.display = 'none';
        extraRoot.innerHTML = '';
        if (extraNote) extraNote.textContent = '';
        return;
      }
      if (extrasSection) extrasSection.style.display = '';

      if (extraNote) {
        const parts = [];
        if (Number.isFinite(totalEntries)) parts.push(`Datei-Eintr√§ge: ${totalEntries}`);
        if (Number.isFinite(stats.hardTotal)) {
          const applied = (forcedInRoster != null) ? ` (${forcedInRoster} im Roster)` : '';
          parts.push(`verbindlich: ${stats.hardTotal}${applied}`);
        }
        if (Number.isFinite(extraCount) && extraCount > 0) parts.push(`au√üerhalb des Rosters: ${extraCount}`);
        if (stats.source) parts.push(`Quelle: ${stats.source}`);
        extraNote.textContent = parts.join(' ¬∑ ') || 'Keine zus√§tzlichen Zusagen erfasst.';
      }

      if (!extraCount) {
        extraRoot.innerHTML = '<p class="muted">Keine zus√§tzlichen Zusagen au√üerhalb der Aufstellung.</p>';
        return;
      }

      extraRoot.innerHTML = '';
      groups.forEach(group => {
        const card = document.createElement('div');
        card.className = 'extra-card';
        const title = document.createElement('h3');
        title.textContent = `Gruppe ${group}`;
        card.appendChild(title);
        const list = document.createElement('ul');
        list.className = 'extra-list';
        const entries = Array.isArray(extraData[group]) ? extraData[group] : [];
        if (!entries.length) {
          const li = document.createElement('li');
          li.textContent = 'Keine Zusagen';
          list.appendChild(li);
        } else {
          entries.forEach(entry => {
            const li = document.createElement('li');
            const name = entry.player || entry.PlayerName || 'Unbekannt';
            const role = entry.role || entry.Role || '';
            const note = entry.note || entry.Note || '';
            const source = entry.source || entry.Source || '';
            const groupPref = entry.group || entry.Group || '';
            const metaParts = [];
            if (groupPref) metaParts.push(`Gruppe ${groupPref}`);
            if (role) metaParts.push(role);
            if (source) metaParts.push(source);
            const metaText = metaParts.length ? ` <span class="extra-meta">(${escapeHtml(metaParts.join(' ¬∑ '))})</span>` : '';
            const noteText = note ? ` <span class="extra-meta">${escapeHtml(note)}</span>` : '';
            li.innerHTML = `${escapeHtml(name)}${metaText}${noteText}`;
            list.appendChild(li);
          });
        }
        card.appendChild(list);
        extraRoot.appendChild(card);
      });
    }

    function renderForcedDiagnostics(diag, meta) {
      const container = document.getElementById('forced-diagnostics');
      if (!container) return;
      const forced = Array.isArray(diag?.forced) ? diag.forced : [];
      const invalid = Array.isArray(diag?.invalid) ? diag.invalid : [];
      const overbooked = Array.isArray(diag?.overbooked) ? diag.overbooked : [];
      const stats = extractSignupStats(meta);

      const summaryParts = [];
      const hardTotal = Number.isFinite(stats.hardTotal) ? stats.hardTotal : null;
      const forcedTotal = Number.isFinite(stats.forcedTotal)
        ? stats.forcedTotal
        : (Number.isFinite(stats.hardApplied) ? stats.hardApplied : forced.length);
      const forcedInRoster = Number.isFinite(stats.forcedInRoster)
        ? stats.forcedInRoster
        : (Number.isFinite(stats.inRosterHard)
          ? stats.inRosterHard
          : (Number.isFinite(stats.hardApplied) ? stats.hardApplied : forced.length));
      const hardInvalid = Number.isFinite(stats.hardInvalid) ? stats.hardInvalid : invalid.length;
      const hardOverbooked = Number.isFinite(stats.hardOverbooked) ? stats.hardOverbooked : overbooked.length;
      const forcedOutOfRoster = Number.isFinite(stats.forcedOutOfRoster) ? stats.forcedOutOfRoster : null;
      if (Number.isFinite(stats.totalEntries)) summaryParts.push(`Datei-Eintr√§ge: ${stats.totalEntries}`);
      if (hardTotal != null) summaryParts.push(`davon verbindliche Zusagen: ${hardTotal}`);
      if (Number.isFinite(forcedTotal)) summaryParts.push(`Fixpl√§tze geplant: ${forcedTotal}`);
      if (Number.isFinite(forcedInRoster)) summaryParts.push(`Fixpl√§tze im Roster: ${forcedInRoster}`);
      if (forcedOutOfRoster) summaryParts.push(`nicht im Roster: ${forcedOutOfRoster}`);
      if (Number.isFinite(hardInvalid) && hardInvalid > 0) summaryParts.push(`ignoriert: ${hardInvalid}`);
      if (Number.isFinite(hardOverbooked) && hardOverbooked > 0) summaryParts.push(`√ºber Kapazit√§t: ${hardOverbooked}`);

      if (!forced.length && !invalid.length && !overbooked.length) {
        container.innerHTML = summaryParts.length
          ? `<p class="muted">${summaryParts.join(' ¬∑ ')}</p>`
          : '<p class="muted">Keine verbindlichen Zusagen im Pool.</p>';
        return;
      }

      const parts = [];
      if (overbooked.length) {
        const items = overbooked
          .map(item => {
            const cap = Number.isFinite(item.capacity) ? Number(item.capacity) : null;
            const excess = Number.isFinite(item.excess_forced) ? Number(item.excess_forced) : null;
            const capText = cap != null ? `Slots: ${cap}` : 'Slots unbekannt';
            const excessText = excess != null ? `√úberbuchung: +${excess}` : '√úberbuchung';
            return `<li class="warn">${escapeHtml(item.group || '?')}/${escapeHtml(item.role || '?')}: ${excessText} (${capText})</li>`;
          })
          .join('');
        parts.push(`<div><h4>√úberbuchungen</h4><ul>${items}</ul></div>`);
      }

      if (invalid.length) {
        const items = invalid
          .map(item => `<li>${escapeHtml(item.player || item.canon || '?')} ‚Äî ${escapeHtml(item.reason || 'ung√ºltig')}</li>`)
          .join('');
        parts.push(`<div><h4>Ignorierte harte Zusagen</h4><ul>${items}</ul></div>`);
      }

      if (forced.length) {
        const items = forced
          .map(item => {
            const over = item.overbooked ? ' ¬∑ <span class="warn">(√ºber Kapazit√§t)</span>' : '';
            return `<li>${escapeHtml(item.player || item.canon || '?')} ‚Üí ${escapeHtml(item.group || '?')}/${escapeHtml(item.role || '?')}${over}</li>`;
          })
          .join('');
        parts.push(`<div><h4>Verbindlich gesetzt</h4><ul>${items}</ul></div>`);
      }

      const summary = summaryParts.length ? `<p class="muted">${summaryParts.join(' ¬∑ ')}</p>` : '';
      container.innerHTML = summary + parts.join('');
    }

    /**
     * Farb-Logik f√ºr No-Show-Badges (bisheriges Verhalten in Klartext):
     * 1. Keine Historie (events_seen=0 oder unbekannt) ‚Üí graue Badge ("nodata").
     * 2. Wer nie gefehlt hat, bleibt gr√ºn, unabh√§ngig von der Rate.
     * 3. low-n (‚â§2 Teilnahmen) wird generell gelb eingeordnet, damit einzelne Ausrei√üer
     *    nicht sofort rot erscheinen.
     * 4. Single-Miss-Spieler: ab 10 Events und Rate <12 % weiterhin gr√ºn, sonst gelb.
     * 5. Alle anderen nutzen die Schwellwerte 20 % (gr√ºn‚Üígelb) und 35 % (gelb‚Üírot).
     * 6. Zus√§tzliche Feinjustierung: Bis 5 Events wird ein eigentlich rotes Rating
     *    auf gelb abgeschw√§cht, um die geringe Stichprobe sichtbar zu machen.
     */
    function classifyNoShowBadge({ rate, eventsSeen, flags = {} }) {
      const { noData=false, neverMissed=false, lowN=false, singleMiss=false } = flags;

      if (noData) {
        return { level: "nodata", reason: "no-data" };
      }

      if (neverMissed) {
        return { level: "good", reason: "never-missed" };
      }

      if (lowN) {
        return { level: "warning", reason: "low-n" };
      }

      const value = (rate != null && Number.isFinite(rate)) ? rate : null;
      if (value == null) {
        return { level: "nodata", reason: "no-rate" };
      }

      if (singleMiss) {
        if ((eventsSeen ?? 0) >= SINGLE_MISS_GREEN_SEEN_MIN && value < SINGLE_MISS_GREEN_RATE_MAX) {
          return { level: "good", reason: "single-miss-soft-green" };
        }
        return { level: "warning", reason: "single-miss-soft-warning" };
      }

      let level;
      if (value < GREEN_TH) level = "good";
      else if (value < YELLOW_TH) level = "warning";
      else level = "bad";

      if (level === "bad" && eventsSeen != null && eventsSeen <= BADGE_SETTINGS.softenBadUntilSeen) {
        return { level: "warning", reason: "small-sample-soften" };
      }

      return { level, reason: "threshold" };
    }

    const BADGE_CLASS_BY_LEVEL = {
      nodata: "chip ns-neutral",
      neutral: "chip ns-neutral",
      good: "chip ns-ok",
      warning: "chip ns-mid",
      bad: "chip ns-bad",
    };

    function buildChipTooltip(p, rRolling, rOverall) {
      const seen   = (p && Number.isFinite(p.events_seen))  ? Number(p.events_seen)  : null;
      const miss   = (p && Number.isFinite(p.noshow_count)) ? Number(p.noshow_count) : null;
      const eb     = (p && p.eb && isFinite(p.eb.p_hat))    ? Number(p.eb.p_hat)     : null;
      const parts = [];
      parts.push(`n=${seen!=null?seen:"‚Äì"}`);
      parts.push(`misses=${miss!=null?miss:"‚Äì"}`);
      if (rRolling!=null && isFinite(rRolling)) parts.push(`rolling=${pc(rRolling)}`);
      if (rOverall!=null && isFinite(rOverall)) parts.push(`overall=${pc(rOverall)}`);
      if (eb!=null) parts.push(`eb‚âà${pc(eb)}`);
      return parts.join(" ¬∑ ");
    }

    function formatDateDisplay(value) {
      const parsed = parseDateOnly(value);
      if (!parsed) return null;
      return `${pad(parsed.getUTCDate())}.${pad(parsed.getUTCMonth() + 1)}.${parsed.getUTCFullYear()}`;
    }

    function buildPlayerMetaText(meta) {
      const eventsSeen = Number.isFinite(meta.eventsSeen) ? Number(meta.eventsSeen) : (meta.eventsSeen === 0 ? 0 : null);
      const noshowCountOverall = Number.isFinite(meta.noshowCountOverall) ? Number(meta.noshowCountOverall) : null;
      const dataNote = meta.dataNote ? meta.dataNote : "";
      const callupReason = meta.callupReason ? meta.callupReason : "";
      const lastSeen = meta.lastSeenDate ? formatDateDisplay(meta.lastSeenDate) : null;
      const lastNoShow = meta.lastNoShowDate ? formatDateDisplay(meta.lastNoShowDate) : null;

      const parts = [];

      if (eventsSeen === 0) {
        parts.push("Events: 0 ¬∑ keine Teilnahme bisher");
      } else if (eventsSeen != null) {
        parts.push(`Events: ${eventsSeen}`);
      } else {
        parts.push("Events: ‚Äì");
      }

      if (noshowCountOverall != null) {
        parts.push(`No-Shows gesamt: ${noshowCountOverall}`);
      }

      if (lastSeen) {
        parts.push(`letzte Teilnahme: ${lastSeen}`);
      }

      if (lastNoShow) {
        parts.push(`letzte No-Show: ${lastNoShow}`);
      }

      if (dataNote) {
        parts.push(dataNote);
      }

      if (callupReason) {
        parts.push(`Callup: ${callupReason}`);
      }

      if (!parts.length) return "Keine zus√§tzlichen Daten verf√ºgbar.";
      return parts.join(" ¬∑ ");
    }

    const FORCED_SOURCE_LABELS = {
      manual: "Manuell",
      "callup-confirmed": "Callup",
    };

    function buildForcedLookup(payload) {
      const forcedList = Array.isArray(payload?.signup_pool?.forced_signups)
        ? payload.signup_pool.forced_signups
        : (Array.isArray(payload?.forced_signups) ? payload.forced_signups : []);
      const map = new Map();
      forcedList.forEach(item => {
        const canon = canonicalNameJS(item?.canon || item?.player || "");
        const group = item?.group || item?.Group;
        const role = item?.role || item?.Role;
        if (!canon || !group || !role) return;
        map.set(`${canon}::${group}::${role}`, normalizeForcedSignup(item));
      });
      return map;
    }

    function resolveForcedSignup({ forcedLookup, player, row, playersByCanon }) {
      const canon = canonicalNameJS(player?.canon || row?.PlayerName || "");
      const playerByCanon = canon && playersByCanon ? playersByCanon[canon] : null;
      const group = row?.Group || player?.group || playerByCanon?.group;
      const role = row?.Role || player?.role || playerByCanon?.role;
      const lookupKey = canon && group && role ? `${canon}::${group}::${role}` : null;
      const fromLookup = lookupKey ? forcedLookup.get(lookupKey) : null;
      if (fromLookup) return fromLookup;

      const candidates = [player, playerByCanon].filter(Boolean);
      for (const cand of candidates) {
        if (cand?.forced_signup) return cand.forced_signup;
      }
      for (const cand of candidates) {
        if (cand?.has_forced_signup) {
          const source = cand?.event_signup?.source || cand?.forced_signup?.source;
          return { commitment: "hard", source };
        }
      }
      return null;
    }

    function normalizeForcedSignup(raw) {
      if (!raw || typeof raw !== "object") return null;
      const commitment = (raw.commitment || raw.Commitment || "").toString().toLowerCase();
      if (commitment !== "hard") return null;
      const source = raw.source || raw.Source || "";
      const note = raw.note || raw.Note || "";
      const overbooked = Boolean(raw.overbooked || raw.Overbooked);
      return { commitment, source, note, overbooked };
    }

    function buildFixBadge(forcedSignup) {
      const normalized = normalizeForcedSignup(forcedSignup);
      if (!normalized) return "";
      const sourceLabel = normalized.source ? (FORCED_SOURCE_LABELS[normalized.source] || normalized.source) : "";
      const label = sourceLabel ? `verbindlich ¬∑ ${sourceLabel}` : "verbindlich";
      const tooltipParts = ["Verbindliche Zusage aus event_signups_next.csv"];
      if (sourceLabel) tooltipParts.push(`Quelle: ${sourceLabel}`);
      if (normalized.overbooked) tooltipParts.push("√ºber Kapazit√§t");
      return `<span class="tag tag-fix" title="${escapeHtml(tooltipParts.join(' ¬∑ '))}">üîí ${escapeHtml(label)}</span>`;
    }

    function writeBucketCounts(key, counts) {
      const h2 = document.querySelector(`#${key} h2`);
      if (!h2) return;
      const base = h2.getAttribute("data-label") || h2.textContent;
      h2.setAttribute("data-label", base);
      const fmt = (value, label) => `${(value==null || !Number.isFinite(value)) ? "‚Äì" : value} ${label}`;
      const suffix = ` ‚Äî ${[fmt(counts.known, "bekannte"), fmt(counts.lown, "low-n"), fmt(counts.nd, "No-Data")].join(" ¬∑ ")}`;
      h2.innerHTML = `${base}<span class="counts">${suffix}</span>`;
    }

    function renderAttendanceSummary(attendance) {
      if (!attendanceSummaryBox) return;
      if (!attendance || typeof attendance !== "object") {
        attendanceSummaryBox.style.display = "none";
        attendanceSummaryBox.innerHTML = "";
        return;
      }

      const schema = Number(attendance.schema);
      const fmtNum = (val, digits = 1) => {
        const num = Number(val);
        return Number.isFinite(num) ? num.toFixed(digits) : "‚Äì";
      };
      const fmtInt = (val) => {
        const num = Number(val);
        return Number.isFinite(num) ? num.toFixed(0) : "0";
      };

      if (Number.isFinite(schema) && schema >= 2) {
        const threshold = Number(attendance.threshold);
        const teams = attendance.teams || {};
        const thresholdLabel = Number.isFinite(threshold)
          ? `Schwelle: ‚â•${(threshold * 100).toFixed(0)}% AttendProb`
          : "Schwelle: ‚Äì";

        const blocks = Object.entries(teams).map(([team, meta]) => {
          const starters = meta?.starters || {};
          const bench = meta?.bench || {};
          const missing = meta?.missing_slots || {};
          const expected = meta?.expected_attendance || {};
          const riskText = meta?.risk_text || "Risiko gering";
          const fallback = Number.isFinite(Number(starters.fallback)) ? Number(starters.fallback) : 0;
          const starterLine = `Starter: ${fmtInt(starters.total)} (‚â• Schwelle: ${fmtInt(starters.at_threshold)}, unter: ${fmtInt(starters.below_threshold)})`;
          const fallbackLine = fallback ? `<span class="muted">Fallback-Starter unter Schwelle: ${fmtInt(fallback)}</span><br />` : '';
          const benchLine = `Ersatz: ${fmtInt(bench.total)} (‚â• Schwelle: ${fmtInt(bench.at_threshold)}, unter: ${fmtInt(bench.below_threshold)})`;
          const expectedLine = `Erwartete Anwesenheit Starter: ${fmtNum(expected.starters)}`;
          const missingLine = (missing.Start || missing.Ersatz)
            ? `Bewusst frei: Start ${fmtInt(missing.Start || 0)} ¬∑ Ersatz ${fmtInt(missing.Ersatz || 0)}`
            : '';
          return `<div style="margin:0 0 10px;">
            <strong>Team ${escapeHtml(team)}</strong><br />
            <span class="muted">${escapeHtml(starterLine)}</span><br />
            ${fallbackLine}
            <span class="muted">${escapeHtml(benchLine)}</span><br />
            ${escapeHtml(expectedLine)}<br />
            ${missingLine ? `<span class="muted">${escapeHtml(missingLine)}</span><br />` : ''}
            <span class="muted">${escapeHtml(riskText)}</span>
          </div>`;
        }).join('');

        const recommendationText = (attendance.recommendation?.text || "").toString();
        const block = [
          `<h3 style="margin:0 0 6px">Erwartete Anwesenheit</h3>`,
          `<p class="muted" style="margin:0 0 4px">${escapeHtml(thresholdLabel)}</p>`,
          `<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:8px;">${blocks}</div>`,
        ];
          if (recommendationText) {
            block.push(`<p style="margin:4px 0 0;"><strong>${escapeHtml(recommendationText)}</strong></p>`);
          }
        attendanceSummaryBox.innerHTML = block.join("");
        attendanceSummaryBox.style.display = "block";
        return;
      }

      const expected = attendance.expected_by_team || {};
      const rec = attendance.recommendation || {};
      const missing = attendance.missing_slots || {};
      const targets = attendance.targets || {};
      const teamTargets = attendance.targets_by_team || {};
      const targetStatus = attendance.target_status || {};
      const callupNeeds = state.callupSuggestions?.needs || {};
      const callupTeams = state.callupSuggestions?.teams || {};

      const statusLabel = (status) => {
        switch ((status || '').toLowerCase()) {
          case 'below_target': return 'unter Ziel';
          case 'at_target':
          case 'above_target': return 'Ziel erf√ºllt';
          default: return '‚Äì';
        }
      };

      const recommendationText = (() => {
        const code = (rec.code || '').toLowerCase();
        if (code === 'a_only') {
          return 'Empfehlung: A-only ‚Äì verl√§ssliche Spieler reichen aktuell nur f√ºr ein Team.';
        }
        if (code === 'ab' || code === 'a_b') {
          return 'Empfehlung: A+B ‚Äì beide Teams erf√ºllen das Attendance-Ziel.';
        }
        if (code === 'a_focus') {
          return 'Empfehlung: A-Team-Fokus ‚Äì Priorisiere Team A, Team B liegt unter Ziel.';
        }
        return rec.reason ? `Empfehlung: ${rec.reason}` : '';
      })();

      const teamBlocks = ['A', 'B'].map(team => {
        const needMeta = callupNeeds[team] || {};
        const plannedSlots = needMeta.planned_slots || {};
        const targetSlots = needMeta.target_slots || {};
        const targetCountFromCallup = Number.isFinite(callupTeams?.[team]?.target_count)
          ? Number(callupTeams[team].target_count)
          : null;
        const targetRange = targets[team];
        const targetFromTeam = Number.isFinite(teamTargets?.[team]) ? Number(teamTargets[team]) : null;
        const targetLabel = Number.isFinite(targetFromTeam)
          ? `Ziel: ‚â•${fmtNum(targetFromTeam, 0)}`
          : (targetCountFromCallup
            ? `Ziel: ‚â•${targetCountFromCallup}`
            : (targetRange && Number.isFinite(targetRange.low)) ? `Ziel: ‚â•${fmtNum(targetRange.low, 0)}` : 'Ziel: ‚Äì');
        const missingSlots = missing?.[team] || {};
        const plannedStart = Number.isFinite(plannedSlots.Start) ? plannedSlots.Start
          : (Number.isFinite(targetSlots.Start) && Number.isFinite(missingSlots.Start) ? targetSlots.Start - missingSlots.Start : null);
        const plannedErsatz = Number.isFinite(plannedSlots.Ersatz) ? plannedSlots.Ersatz
          : (Number.isFinite(targetSlots.Ersatz) && Number.isFinite(missingSlots.Ersatz) ? targetSlots.Ersatz - missingSlots.Ersatz : null);
        const targetStart = Number.isFinite(targetSlots.Start) ? targetSlots.Start : null;
        const targetErsatz = Number.isFinite(targetSlots.Ersatz) ? targetSlots.Ersatz : null;
        const plannedText = (plannedStart != null || plannedErsatz != null)
          ? `Starter ${plannedStart ?? '‚Äì'}/${targetStart ?? '‚Äì'}, Ersatz ${plannedErsatz ?? '‚Äì'}/${targetErsatz ?? '‚Äì'}`
          : 'Kapazit√§t nicht bekannt';
        const expectedTotal = expected?.[team]?.total;
        const expectedLabel = `Erwartet: ${fmtNum(expectedTotal)} Spieler`;
        const status = statusLabel(targetStatus?.[team]);
        return `<div style="margin:0 0 10px;">
          <strong>Team ${team}</strong><br />
          <span class="muted">${plannedText}</span><br />
          ${expectedLabel} ¬∑ ${targetLabel}<br />
          <span class="muted">Status: ${status}</span>
        </div>`;
      }).join('');

      const block = [
        `<h3 style="margin:0 0 6px">Erwartete Anwesenheit</h3>`,
        `<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:8px;">${teamBlocks}</div>`,
      ];
      if (recommendationText) {
        block.push(`<p style="margin:4px 0 0;"><strong>${escapeHtml(recommendationText)}</strong></p>`);
      } else if (rec.code || rec.reason) {
        block.push(`<p style="margin:4px 0 0;"><strong>Empfehlung:</strong> ${escapeHtml(rec.code || rec.reason || '')}</p>`);
      }
      attendanceSummaryBox.innerHTML = block.join("");
      attendanceSummaryBox.style.display = "block";
    }

    function renderOverviewMeta(payload, schema = {}) {
      if (!overviewMeta || !overviewMetaList || !overviewMetaNote) return;

      const generatedAt = (payload && typeof payload.generated_at === "string" && payload.generated_at.trim())
        ? payload.generated_at.trim()
        : "";
      const schemaVersion = Number.isFinite(schema.version) ? Number(schema.version) : null;
      const attendanceSchema = Number.isFinite(payload?.attendance?.schema) ? Number(payload.attendance.schema) : null;
      const signupScopeRaw = payload?.event_signups?.scope || payload?.signup_pool?.scope || "";
      const signupScope = (signupScopeRaw || "").toString();
      const signupSourceRaw = payload?.event_signups?.source;
      const signupSource = typeof signupSourceRaw === "string"
        ? signupSourceRaw
        : (signupSourceRaw && typeof signupSourceRaw.path === "string" ? signupSourceRaw.path : "");
      const recommendationRaw = payload?.attendance?.recommendation;
      const recommendationText = recommendationRaw
        ? (recommendationRaw.text || recommendationRaw.reason || recommendationRaw.code || "").toString().trim()
        : "";

      const items = [];
      const schemaLabel = schemaVersion != null ? ` (Schema v${schemaVersion})` : "";
      if (generatedAt || schemaLabel) {
        items.push(`<li><strong>Stand:</strong> ${escapeHtml(generatedAt || '‚Äì')}${schemaLabel}</li>`);
      }
      if (attendanceSchema != null) {
        items.push(`<li><strong>Attendance-Schema:</strong> v${attendanceSchema}</li>`);
      }
      if (signupScope || signupSource) {
        const parts = [];
        if (signupScope) parts.push(escapeHtml(signupScope));
        if (signupSource) parts.push(`Quelle: ${escapeHtml(signupSource)}`);
        items.push(`<li><strong>Signup-Pool:</strong> ${parts.length ? parts.join(' ¬∑ ') : '‚Äì'}</li>`);
      }
      if (recommendationText) {
        items.push(`<li><strong>Empfehlung:</strong> ${escapeHtml(recommendationText)}</li>`);
      }

      if (items.length) {
        overviewMetaList.innerHTML = items.join('');
        overviewMetaList.style.display = 'grid';
        overviewMetaNote.style.display = 'none';
      } else {
        overviewMetaList.innerHTML = '';
        overviewMetaList.style.display = 'none';
        overviewMetaNote.textContent = 'Keine Metadaten gefunden.';
        overviewMetaNote.style.display = 'block';
      }
    }

    function renderRosterBuckets({ rows, playersMap, playersArray, activeAbsenceSet, ebEnabled, schema, hasEventsSeen }) {
      const observedFromPlayers = playersArray
        .map(p => {
          if (!p || typeof p !== "object") return null;
          const seen = toNumber(p.events_seen);
          const hasData = (seen == null) || (seen > 0);
          if (p.eb && p.eb.p_hat != null && hasData) {
            const v = toNumber(p.eb.p_hat);
            if (v != null) return v;
          }
          if (p.noshow_rolling != null && hasData) {
            const v = toNumber(p.noshow_rolling);
            if (v != null) return v;
          }
          if (p.noshow_overall != null && hasData) {
            const v = toNumber(p.noshow_overall);
            if (v != null) return v;
          }
          return null;
        })
        .filter(v => v != null);

      let observed = observedFromPlayers;
      if (!observed.length) {
        observed = rows.map(r => {
          const seen = toNumber(r.EventsSeen);
          const hasData = (seen == null) || (seen > 0);
          if (r.EB && r.EB.p_hat != null && hasData) {
            const v = toNumber(r.EB.p_hat);
            if (v != null) return v;
          }
          if (r.NoShowRolling != null && hasData) {
            const v = toNumber(r.NoShowRolling);
            if (v != null) return v;
          }
          if (r.NoShowOverall != null && hasData) {
            const v = toNumber(r.NoShowOverall);
            if (v != null) return v;
          }
          return null;
        }).filter(v => v != null);
      }
      const avg = (arr)=> arr.reduce((a,b)=>a+b,0)/Math.max(1,arr.length);
      const fallbackPrior = (schema.prior && schema.prior.fallback != null && isFinite(schema.prior.fallback)) ? Number(schema.prior.fallback) : DEFAULT_PRIOR_FALLBACK;
      const priorPad = (schema.prior && schema.prior.pad != null && isFinite(schema.prior.pad)) ? Number(schema.prior.pad) : DEFAULT_PRIOR_PAD;
      const teamMeanSchema = (schema.prior && schema.prior.team_mean != null && isFinite(schema.prior.team_mean)) ? Number(schema.prior.team_mean) : null;
      const priorValueSchema = (schema.prior && schema.prior.value != null && isFinite(schema.prior.value)) ? Number(schema.prior.value) : null;
      const priorBase = observed.length ? avg(observed) : fallbackPrior;
      const teamMean = (teamMeanSchema != null) ? teamMeanSchema : priorBase;
      const PRIOR_NOSHOW = clamp(priorValueSchema != null ? priorValueSchema : (teamMean + priorPad));

      const effRate = (r) => {
        if (r.EB && r.EB.p_hat != null) {
          const v = toNumber(r.EB.p_hat);
          if (v != null) return clamp(v);
        }
        const rolling = toNumber(r.NoShowRolling);
        if (rolling != null) return clamp(rolling);
        const overall = toNumber(r.NoShowOverall);
        if (overall != null) return clamp(overall);
        return PRIOR_NOSHOW;
      };

      document.getElementById("sort-note").textContent =
        `Sortierung: niedrigste Risiko-Sch√§tzung zuerst (Prim√§r: ${ebEnabled ? "EB pÃÇ" : "rolling"}, Fallback: ${ebEnabled ? "rolling ‚Üí overall" : "overall"}, Prior ‚âà ${(PRIOR_NOSHOW*100).toFixed(1)}%).`;

      const targets = ["A-Start","A-Ersatz","B-Start","B-Ersatz"];
      const buckets = Object.fromEntries(targets.map(k => [k, []]));
      rows.forEach(r=>{
        const canonRow = canonicalNameJS(r.PlayerName || '');
        if (canonRow && activeAbsenceSet.has(canonRow)) return;
        const key = `${r.Group}-${r.Role}`;
        if (buckets[key]) buckets[key].push(r);
      });

      for (const key of targets) {
        buckets[key].sort((a,b)=>{
          const da = effRate(a), db = effRate(b);
          if (Math.abs(da - db) > EPS) return da - db;
          const oaVal = (toNumber(a.NoShowOverall) != null) ? toNumber(a.NoShowOverall) : 1;
          const obVal = (toNumber(b.NoShowOverall) != null) ? toNumber(b.NoShowOverall) : 1;
          const oa = oaVal ?? 1;
          const ob = obVal ?? 1;
          if (Math.abs(oa - ob) > EPS) return oa - ob;
          return (a.PlayerName||"").localeCompare(b.PlayerName||"");
        });
      }

      for (const key of targets) {
        const tbody = document.querySelector(`#${key} tbody`);
        if (!tbody) continue;
        tbody.innerHTML = "";
        (buckets[key] || []).forEach((r, i) => {
          const histOverall = toNumber(r.NoShowOverall);
          const histRolling = toNumber(r.NoShowRolling);
          const p = playersMap[r.PlayerName] || {};

          const seenSource = Number.isFinite(p.events_seen) ? Number(p.events_seen) : null;
          const seenFallback = Object.prototype.hasOwnProperty.call(r, "EventsSeen") ? toNumber(r.EventsSeen) : null;
          const seen = (seenSource != null) ? seenSource : seenFallback;

          const missesSource = Number.isFinite(p.noshow_count) ? Number(p.noshow_count) : null;
          const missesFallback = Object.prototype.hasOwnProperty.call(r, "NoShowCount") ? toNumber(r.NoShowCount) : null;
          const misses = (missesSource != null) ? missesSource : missesFallback;

          const seenKnown = (p && Object.prototype.hasOwnProperty.call(p, "events_seen")) ||
            Object.prototype.hasOwnProperty.call(r, "EventsSeen");
          const annotate = seenKnown || hasEventsSeen;

          const participated = (seen != null && seen > 0);
          const noData = annotate ? !participated : false;
          const lowN = annotate ? (participated && seen <= BADGE_SETTINGS.lowNMax) : false;
          const neverMissed = annotate ? (participated && misses === 0) : false;
          const singleMiss = annotate ? (participated && misses === 1) : false;

          const historyBadge = noData
            ? '<span class="tag tag-nd" title="Keine Historie ‚Äì events_seen = 0">No&nbsp;Data</span>'
            : (lowN ? '<span class="tag tag-low" title="Wenig Historie ‚Äì events_seen ‚àà {1,2}">low&nbsp;n</span>' : '');

          const histRate = (histRolling ?? histOverall);

          const tip = buildChipTooltip(p, histRolling, histOverall);

          const shownOverall = noData ? null : histOverall;
          const shownRolling = noData ? null : histRolling;
          const badge = classifyNoShowBadge({
            rate: histRate,
            eventsSeen: annotate ? seen : null,
            flags: { noData, neverMissed, lowN, singleMiss },
          });
          const chipKlass = BADGE_CLASS_BY_LEVEL[badge.level] || BADGE_CLASS_BY_LEVEL.nodata;
          const reasonHint = badge.reason ? ` ¬∑ badge=${badge.reason}` : "";
          const tooltip = `${tip}${reasonHint}`.replace(/"/g, '&quot;');
          let nameHTML = `${r.PlayerName || ""}`;
          const normalizedCallup = normalizeCallup(p);
          const forcedSource = resolveForcedSignup({
            forcedLookup: state.forcedLookup || new Map(),
            player: p,
            row: r,
            playersByCanon: state.playersByCanon || {},
          });
          const forcedBadge = buildFixBadge(forcedSource);
          const callupBadge = p ? buildCallupBadge(normalizedCallup) : '';
          const hasFixedCommitFlag = hasFixedCommit(p, forcedSource);
          if (historyBadge) nameHTML += ` ${historyBadge}`;
          if (forcedBadge) nameHTML += ` ${forcedBadge}`;
          if (callupBadge) nameHTML += ` ${callupBadge}`;
          if (p && (p.has_event_signup || p.event_signup)) {
            nameHTML += ' <span class="tag tag-event" title="Zusage im Event-Pool (n√§chstes Event)">Event-Zusage</span>';
          }
          const noshowCountOverall = Number.isFinite(p.noshow_count_overall) ? Number(p.noshow_count_overall) :
            (Number.isFinite(p.noshow_count) ? Number(p.noshow_count) :
            (Object.prototype.hasOwnProperty.call(r, "NoShowCount") ? toNumber(r.NoShowCount) : null));
          const dataNote = noData
            ? "Datenlage: keine Historie"
            : (lowN ? "Datenlage: wenig Historie" : "");
          const callupReason = (normalizedCallup && normalizedCallup.recommended) ? formatCallupReasons(normalizedCallup) : "";
          const lastSeenValue = p ? (p.last_seen || p.LastSeenDate) : (r.LastSeenDate || null);
          const lastNoShowValue = p ? (p.last_noshow_date || p.LastNoShowDate) : (r.LastNoShowDate || null);
          const metaText = buildPlayerMetaText({
            eventsSeen: seen,
            noshowCountOverall,
            dataNote,
            callupReason,
            lastSeenDate: lastSeenValue,
            lastNoShowDate: lastNoShowValue,
          });
          const tr = document.createElement("tr");
          tr.dataset.playerRow = "true";
          tr.dataset.fixedCommit = hasFixedCommitFlag ? "true" : "false";
          tr.innerHTML = `
            <td class="num">${pad(i+1)}</td>
            <td>
              <div class="player-name-row">${nameHTML}</div>
              <div class="player-meta-row">${metaText}</div>
            </td>
            <td><span class="${chipKlass}" title="${tooltip}">${pc(shownOverall)}</span></td>
            <td><span class="${chipKlass}" title="${tooltip}">${pc(shownRolling)}</span></td>
          `;
          tbody.appendChild(tr);
        });

        if (!window.__bucketCounts) window.__bucketCounts = {};
        const keyCounts = { known:0, lown:0, nd:0 };
        (buckets[key] || []).forEach(row => {
          const pp = playersMap[row.PlayerName] || {};
          const seenVal = Number.isFinite(pp.events_seen) ? Number(pp.events_seen) :
            (Object.prototype.hasOwnProperty.call(row, "EventsSeen") ? toNumber(row.EventsSeen) : null);
          if (!(seenVal > 0)) { keyCounts.nd++; return; }
          if (seenVal <= BADGE_SETTINGS.lowNMax) { keyCounts.lown++; return; }
          keyCounts.known++;
        });
        window.__bucketCounts[key] = keyCounts;
        writeBucketCounts(key, keyCounts);
      }

      // Ensure visual filters stay applied after re-rendering the roster
      applyRosterFilters();
    }

    function processLatestPayload(payload) {
      const schema = (!Array.isArray(payload) && payload && typeof payload === "object") ? (payload.schema || {}) : {};
      const ebEnabled = Boolean(schema && schema.eb && schema.eb.enabled);

      const toRows = (payload) => {
        if (Array.isArray(payload)) return payload;
        const playersByDisplay = Object.fromEntries((payload.players || []).map(p => [p.display, p]));
        const groups = payload.groups || {};
        const out = [];
        for (const G of ["A","B"]) {
          const g = groups[G] || {};
          for (const R of ["Start","Ersatz"]) {
            const list = (g[R] || []);
            list.forEach((name, idx) => {
              const p = playersByDisplay[name] || {};
              const eb = (p.eb && typeof p.eb === "object") ? {
                p_hat: toNumber(p.eb.p_hat),
                sigma: toNumber(p.eb.sigma),
              } : null;
              out.push({
                Group: G,
                Role: R,
                Slot: idx + 1,
                PlayerName: name,
                NoShowOverall: toNumber(p.noshow_overall),
                NoShowRolling: toNumber(p.noshow_rolling),
                EB: eb,
                EventsSeen: toNumber(p.events_seen),
              });
            });
          }
        }
        return out;
      };

      const rows = toRows(payload);
      const playersArray = (!Array.isArray(payload) && Array.isArray(payload.players)) ? payload.players : [];

      state.callupMeta = extractCallupMeta(payload, playersArray, schema);
      state.latestPayload = payload;
      state.playersArray = playersArray;
      state.callupCandidates = collectCallupCandidates(playersArray);

      safeRenderSection("overview-meta", () => renderOverviewMeta(payload, schema), overviewMeta);
      safeRenderSection("attendance-summary", () => renderAttendanceSummary(payload.attendance), attendanceSummaryBox);

      state.callupSuggestions = extractCallupSuggestions(payload);
      safeRenderSection("callup-suggestions", () => renderCallupSuggestions(state.callupSuggestions), callupSuggestionsContent);

      state.allianceOverview = normalizeAllianceOverview(payload?.alliance_next_event_overview);
      safeRenderSection("alliance-overview", () => renderAllianceOverview(), allianceTable);

      const playersMap = Object.fromEntries(
        playersArray
          .filter(p => p && typeof p === "object" && typeof p.display === "string")
          .map(p => {
            const normalizedCallup = normalizeCallup(p);
            const merged = { ...p };
            if (normalizedCallup) merged.callup = normalizedCallup;
            return [p.display, merged];
          })
      );
      const playersByCanon = {};
      playersArray.forEach(p => {
        if (!p || typeof p !== "object") return;
        const canonSource = typeof p.canon === "string" && p.canon.trim() ? p.canon : p.display;
        const canon = canonicalNameJS(canonSource || "");
        if (!canon) return;
        const normalizedCallup = normalizeCallup(p);
        playersByCanon[canon] = {
          display: p.display,
          group: p.group,
          role: p.role,
          has_event_signup: Boolean(p.has_event_signup || p.event_signup),
          event_signup: p.event_signup || null,
          has_forced_signup: Boolean(p.has_forced_signup || p.forced_signup),
          forced_signup: p.forced_signup || null,
          callup: normalizedCallup,
          callup_recommended: normalizedCallup ? Boolean(normalizedCallup.recommended) : Boolean(p.callup_recommended),
          is_absent_next_event: Boolean(p.is_absent_next_event),
        };
      });
      state.playersByCanon = playersByCanon;
      state.absenceDebug = payload.absence_debug || null;
      state.absenceConflicts = Array.isArray(payload.absence_conflicts) ? payload.absence_conflicts : [];
      safeRenderSection("absence-diagnostics", () => renderAbsenceDiagnostics(state.absenceDebug, state.absenceConflicts), absenceDiag);

      const absencesApplied = applyAbsencesFromPayload(payload.absences);
      if (!absencesApplied) {
        fetchAbsences();
      }

      const responsesApplied = applyEventResponsesFromPayload(payload.event_responses);
      if (!responsesApplied) {
        state.eventResponses.loading = false;
        state.eventResponses.error = new Error('Keine Event-Antworten im Payload');
      }
      state.eventResponseConflicts = Array.isArray(payload.event_response_conflicts)
        ? payload.event_response_conflicts
        : [];
      safeRenderSection("event-responses", () => updateEventResponsesUI(), eventResponsesContainer);

      const activeAbsenceSet = new Set([
        ...((state.absences.active || []).map(a => canonicalNameJS(a?.canon || a?.playerName || ''))),
        ...(playersArray
          .filter(p => p && p.is_absent_next_event)
          .map(p => canonicalNameJS(p.canon || p.display || ''))),
      ].filter(Boolean));
      const extraSignups = {
        A: (payload && payload.groups && Array.isArray(payload.groups.A?.extra_signups)) ? payload.groups.A.extra_signups : [],
        B: (payload && payload.groups && Array.isArray(payload.groups.B?.extra_signups)) ? payload.groups.B.extra_signups : [],
      };
      const signupPoolBlock = (payload && typeof payload.signup_pool === 'object') ? payload.signup_pool : {};
      state.forcedDiagnostics = {
        forced: Array.isArray(signupPoolBlock.forced_signups)
          ? signupPoolBlock.forced_signups
          : (Array.isArray(payload.forced_signups) ? payload.forced_signups : []),
        invalid: Array.isArray(signupPoolBlock.invalid_forced_signups)
          ? signupPoolBlock.invalid_forced_signups
          : (Array.isArray(payload.invalid_forced_signups) ? payload.invalid_forced_signups : []),
        overbooked: Array.isArray(signupPoolBlock.overbooked_forced_signups)
          ? signupPoolBlock.overbooked_forced_signups
          : (Array.isArray(payload.overbooked_forced_signups) ? payload.overbooked_forced_signups : []),
        rows: Array.isArray(signupPoolBlock.file_entries) ? signupPoolBlock.file_entries : [],
      };
      const hasEventsSeen = playersArray.some(p => p && Object.prototype.hasOwnProperty.call(p, "events_seen"));

      state.forcedLookup = buildForcedLookup(payload);

      safeRenderSection("roster", () => renderRosterBuckets({
        rows,
        playersMap,
        playersArray,
        activeAbsenceSet,
        ebEnabled,
        schema,
        hasEventsSeen,
      }), rosterRoot);

      const signupMeta = (signupPoolBlock && typeof signupPoolBlock.stats === 'object')
        ? signupPoolBlock.stats
        : (payload.signup_pool || payload.event_signups || null);
      const filteredExtraSignups = {
        A: (extraSignups.A || []).filter(item => {
          const canon = canonicalNameJS(item?.canon || item?.player || '');
          return !(canon && activeAbsenceSet.has(canon));
        }),
        B: (extraSignups.B || []).filter(item => {
          const canon = canonicalNameJS(item?.canon || item?.player || '');
          return !(canon && activeAbsenceSet.has(canon));
        }),
      };
      safeRenderSection("extra-signups", () => renderExtraSignups(filteredExtraSignups, signupMeta, state.forcedDiagnostics), extraRoot);
      safeRenderSection("forced-diagnostics", () => renderForcedDiagnostics(state.forcedDiagnostics, signupMeta), document.getElementById("forced-diagnostics"));
      safeRenderSection("callup-note", () => updateCallupNote(state.callupMeta), callupNote);
      safeRenderSection("callup-export", () => updateCallupExportButton(state.callupMeta, state.callupCandidates), callupExportBtn);
      safeRenderSection("fixed-commit-filter", () => applyRosterFilters(), commitCallupToggle);

      const ts = new Date().toISOString().replace('T',' ').slice(0,19) + " UTC";
      const schemaVersion = (schema && schema.version != null) ? ` ¬∑ schema v${schema.version}` : "";
      safeRenderSection("stamp", () => {
        document.getElementById("stamp").textContent = `Stand: ${ts}${schemaVersion}`;
      }, document.getElementById("stamp"));
    }

    async function initRosterUI() {
      try {
        const payload = await loadLatestJson();
        clearInitError();
        processLatestPayload(payload);
      } catch (err) {
        console.error("DS_INIT_LATEST_JSON_FAILED", err);
        showInitError("‚ö†Ô∏è Roster konnte nicht geladen werden. Bitte pr√ºfe out/latest.json oder den letzten Build.");
      }
    }

    initRosterUI();
  </script>
</body>
</html>
