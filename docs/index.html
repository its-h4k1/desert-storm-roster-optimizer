<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Desert Storm – Aufstellung (Latest)</title>
  <style>
    :root{
      --fg:#111; --muted:#666; --line:#ddd;
      --ok:#1f9d55; --mid:#c9a227; --bad:#d64545;
      --bg:#fff; --bgth:#fafafa;
    }
    body{font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;margin:24px;color:var(--fg);background:var(--bg)}
    h1{margin:0 0 8px}
    h2{margin:0 0 8px}
    h3{margin:12px 0 6px;font-weight:600}
    .top-bar{display:flex;align-items:flex-start;gap:12px;flex-wrap:wrap;margin:0 0 6px}
    .top-actions{margin-left:auto;display:flex;gap:10px;align-items:flex-start;flex-wrap:wrap}
    .admin-link{display:inline-flex;align-items:center;gap:8px;padding:8px 14px;border:1px solid var(--line);border-radius:10px;text-decoration:none;color:var(--fg);background:#fff;box-shadow:0 4px 12px rgba(0,0,0,0.05);font-weight:600}
    .admin-link:hover{border-color:#c8d5ec;box-shadow:0 6px 16px rgba(0,0,0,0.08)}
    .admin-link:active{transform:translateY(1px)}
    .stamp{display:block;font-size:0.8em;line-height:1.4;margin-top:4px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:24px}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left;vertical-align:top}
    th{background:var(--bgth)}
    .muted{color:var(--muted)}
    .num{font-variant-numeric:tabular-nums}
    .counts{font-size:.9em;color:var(--muted);font-weight:400;margin-left:.25rem}
    .chip{display:inline-block;min-width:52px;text-align:right;padding:2px 8px;border-radius:999px;border:1px solid var(--line)}
    .chip.ns-neutral{background:#f6f7f8;border:1px solid #ccc;color:#555}
    .ns-ok{border-color:#bfe8cc;background:#f3fbf6}
    .ns-mid{background:#fff9e6;border:1px solid #f3d78a}
    .ns-bad{border-color:#f2b7b7;background:#fff5f5}
    .sub{margin:6px 0 18px}
    .wrap{display:grid;grid-template-columns:1fr;gap:28px}
    @media (min-width: 960px){ .wrap{grid-template-columns:1fr 1fr} }
    .tag{display:inline-block;margin-left:6px;padding:2px 7px;border-radius:999px;font-size:0.72em;font-weight:600;vertical-align:middle}
    .tag-nd{background:var(--bad);color:#fff}
    .tag-low{background:#f1e1a8;color:#111}
    .tag-event{background:#ecfeff;border:1px solid #a5f3fc;color:#0f172a}
    .tag-hard{background:#fee2e2;border:1px solid #fecdd3;color:#7f1d1d}
    .legend{font-size:0.85em;margin:12px 0 0}
    .roster-controls{margin:12px 0 20px}
    .player-meta-toggle{font-size:0.9em;color:var(--fg);display:inline-flex;align-items:center;gap:8px;cursor:pointer;user-select:none}
    .player-meta-toggle input{width:16px;height:16px}
    .player-name-row{font-size:14px;font-weight:600}
    .player-meta-row{font-size:11px;color:#777;margin-top:2px;display:none}
    .show-player-meta .player-meta-row{display:block}
    #absences{margin-top:48px;padding-top:24px;border-top:1px solid var(--line)}
    #absences h2{margin:0 0 8px}
    #absences .absences-empty{color:var(--muted);margin:0}
    #absences table{margin-top:12px}
    .absences-roster-badge{display:inline-block;margin-left:6px;padding:2px 8px;border-radius:999px;border:1px solid var(--line);font-size:0.75em;color:var(--muted);background:var(--bgth)}
    .absences-error{color:#b00}
    .extra-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px;margin-top:8px}
    .extra-card{border:1px solid var(--line);border-radius:10px;padding:10px;background:var(--bgth)}
    .extra-card h3{margin:0 0 6px}
    .extra-list{list-style:none;padding:0;margin:0;display:grid;gap:6px}
    .extra-meta{color:var(--muted);font-size:0.85em}
    .diag{margin:10px 0 0;padding:10px;border-radius:10px;border:1px solid var(--line);background:#fff}
    .diag h4{margin:0 0 6px;font-size:1em}
    .diag ul{margin:0;padding-left:20px;color:#444}
    .diag .warn{color:#7f1d1d;font-weight:600}
  </style>
</head>
<body>
  <div class="top-bar">
    <h1>Desert Storm – Aufstellung <span id="stamp" class="muted stamp"></span></h1>
    <div class="top-actions">
      <a class="admin-link" href="admin/index.html">Admin &amp; Tools</a>
    </div>
  </div>
  <p class="muted" id="sort-note" style="margin:0 0 18px"></p>

  <div class="roster-controls">
    <label class="player-meta-toggle">
      <input type="checkbox" id="player-meta-toggle" />
      Detailzeile pro Spieler anzeigen
    </label>
  </div>

  <div id="roster-root" class="grid">
    <section id="A-Start">
      <h2>Gruppe A · Start</h2>
      <table>
        <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
    <section id="A-Ersatz">
      <h2>Gruppe A · Ersatz</h2>
      <table>
        <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
    <section id="B-Start">
      <h2>Gruppe B · Start</h2>
      <table>
        <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
    <section id="B-Ersatz">
      <h2>Gruppe B · Ersatz</h2>
      <table>
        <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
  </div>

  <section id="extras">
    <h2>Zusätzliche Zusagen (Pool nächstes Event)</h2>
    <p class="muted" id="extra-note">Lädt Zusagen …</p>
    <div id="forced-diagnostics" class="diag"></div>
    <div id="extra-root" class="extra-grid"></div>
  </section>

  <p class="muted legend">Legende: <span class="tag tag-nd" title="Keine Historie – events_seen = 0">No&nbsp;Data</span> keine Historie · <span class="tag tag-low" title="Wenig Historie – events_seen ∈ {1,2}">low&nbsp;n</span> wenig Historie<br />Farben basieren auf Historie (rolling→overall), EB wird nur zur Sortierung verwendet.<br />No-Data = nie teilgenommen (grau). low-n ≤2 = gelb. 1 Fehltermin = nie rot.</p>

  <section id="absences">
    <h2>Absenzen</h2>
    <div id="absences-content" class="muted">Wird geladen …</div>
  </section>

  <p class="sub muted">Quelle: <code>out/latest.json</code> (GitHub)</p>

  <script src="shared.js"></script>
  <script>
    // Quelle (mit Cache-Buster)
    const url = new URL(location.href);
    const branchOverride = url.searchParams.get('branch');
    const branch = branchOverride || 'main';
    const cacheBuster = `?v=${Date.now()}`;
    const SITE_ROOT = dsroShared.computeSiteRoot(location.pathname || '/');
    const LATEST_JSON_URL = dsroShared.buildLatestJsonUrl({ branchOverride, cacheBuster, siteRoot: SITE_ROOT });
    const canonicalNameJS = dsroShared.canonicalNameJS;
    const escapeHtml = dsroShared.escapeHtml;
    // Main roster UI expects latest.json at: docs/out/latest.json (served as out/latest.json on GitHub Pages).
    const ABSENCES_RAW = `https://raw.githubusercontent.com/its-h4k1/desert-storm-roster-optimizer/${branch}/data/absences.csv${cacheBuster}`;

    // Konfiguration: Prior-Defaults (werden durch schema.prior überschrieben)
    const DEFAULT_PRIOR_FALLBACK = 0.18;
    const DEFAULT_PRIOR_PAD = 0.02;
    const EPS = 1e-12;

    const state = {
      showPlayerMeta: false,
      absences: { entries: [], active: [], error: null, loading: true },
      playersByCanon: {},
      forcedDiagnostics: { forced: [], invalid: [], overbooked: [] },
    };
    const rosterRoot = document.getElementById("roster-root");
    const playerMetaToggle = document.getElementById("player-meta-toggle");
    const absencesContainer = document.getElementById("absences-content");
    const extraRoot = document.getElementById("extra-root");
    const extraNote = document.getElementById("extra-note");
    if (playerMetaToggle) {
      state.showPlayerMeta = Boolean(playerMetaToggle.checked);
      playerMetaToggle.addEventListener("change", (event) => {
        state.showPlayerMeta = event.target.checked;
        if (rosterRoot) {
          rosterRoot.classList.toggle("show-player-meta", state.showPlayerMeta);
        }
      });
    }
    if (rosterRoot) {
      rosterRoot.classList.toggle("show-player-meta", state.showPlayerMeta);
    }

    // Format & Styling
    const pad = (n)=> String(n).padStart(2,"0");
    const pc  = (x)=> (x==null || isNaN(x)) ? "–" : (Math.round(x*1000)/10).toFixed(1)+"%";
    const BADGE_SETTINGS = {
      thresholds: {
        ok: 0.20,
        warning: 0.35,
      },
      singleMiss: {
        seenMin: 10,
        rateMax: 0.12,
      },
      lowNMax: 2,
      softenBadUntilSeen: 5,
    };
    const GREEN_TH  = BADGE_SETTINGS.thresholds.ok;
    const YELLOW_TH = BADGE_SETTINGS.thresholds.warning;
    const SINGLE_MISS_GREEN_SEEN_MIN = BADGE_SETTINGS.singleMiss.seenMin;
    const SINGLE_MISS_GREEN_RATE_MAX = BADGE_SETTINGS.singleMiss.rateMax;
    const clamp = (x)=> Math.min(1, Math.max(0, x));
    const toNumber = (v)=>{
      if (v==null) return null;
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };

    function splitCsvLine(line) {
      const out = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (inQuotes) {
          if (char === '"') {
            if (line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            current += char;
          }
        } else if (char === '"') {
          inQuotes = true;
        } else if (char === ',') {
          out.push(current);
          current = "";
        } else {
          current += char;
        }
      }
      out.push(current);
      return out;
    }

    function parseCsv(text) {
      const cleaned = (text || "").replace(/^\ufeff/, "").split(/\r?\n/);
      const lines = cleaned.filter(line => line && line.trim().length);
      if (!lines.length) return [];
      const headers = splitCsvLine(lines.shift()).map(h => h.trim());
      return lines.map(line => {
        const cells = splitCsvLine(line);
        const obj = {};
        headers.forEach((header, idx) => {
          obj[header] = cells[idx] != null ? cells[idx].trim() : "";
        });
        return obj;
      });
    }

    function parseDateOnly(value) {
      if (!value) return null;
      const trimmed = String(value).trim();
      if (!trimmed) return null;
      const date = new Date(trimmed);
      if (Number.isNaN(date.getTime())) return null;
      return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
    }

    function parseInAllianceFlag(value) {
      if (value == null) return false;
      const normalized = String(value).trim().toLowerCase();
      // "InAlliance" kennzeichnet die Allianz-Mitgliedschaft (1 = im Roster, 0 = ausgetreten).
      return ["1","true","yes","y","aktiv","active"].includes(normalized);
    }

    function normalizeAbsenceRow(row) {
      const playerName = (row?.PlayerName ?? row?.playername ?? "").toString().trim();
      const from = (row?.From ?? row?.from ?? "").toString().trim();
      const to = (row?.To ?? row?.to ?? "").toString().trim();
      const reason = (row?.Reason ?? row?.reason ?? "").toString().trim();
      const activeFlag =
        row?.InAlliance ?? row?.inalliance ?? row?.Active ?? row?.active;
      return {
        playerName,
        canon: canonicalNameJS(playerName),
        from,
        to,
        fromDate: parseDateOnly(from),
        toDate: parseDateOnly(to),
        reason,
        inAlliance: parseInAllianceFlag(activeFlag),
      };
    }

    function todayDateUTC() {
      const now = new Date();
      return new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    }

    function computeActiveAbsences(entries) {
      const today = todayDateUTC();
      const todayMs = today.getTime();
      return entries.filter(entry => {
        if (!entry.inAlliance) {
          return false; // Nur Spieler, die noch zur Allianz gehören, tauchen in der Übersicht auf.
        }
        if (entry.fromDate && entry.fromDate.getTime() > todayMs) {
          return false;
        }
        if (entry.toDate && entry.toDate.getTime() < todayMs) {
          return false;
        }
        return true;
      });
    }

    function formatAbsenceRange(entry) {
      const from = entry.from || "–";
      const to = entry.to || "–";
      if (!entry.from && !entry.to) return "–";
      return `${from} – ${to}`;
    }

    function rosterBadgeFor(entry) {
      const meta = state.playersByCanon[entry.canon];
      if (!meta) return "";
      const parts = [];
      if (meta.group) parts.push(`Gruppe ${meta.group}`);
      if (meta.role) parts.push(meta.role);
      const text = parts.join(" · ");
      return text ? `<span class="absences-roster-badge">im Roster${text ? ` · ${escapeHtml(text)}` : ""}</span>` : "";
    }

    function updateAbsencesUI() {
      if (!absencesContainer) return;
      const { loading, error, active } = state.absences;
      if (loading) {
        absencesContainer.textContent = "Wird geladen …";
        return;
      }
      if (error) {
        absencesContainer.innerHTML = `<p class="absences-error">Absenzen konnten nicht geladen werden (${escapeHtml(error.message || error)})</p>`;
        return;
      }
      if (!active.length) {
        absencesContainer.innerHTML = '<p class="absences-empty">Aktuell sind keine Absenzen erfasst.</p>';
        return;
      }
      const rows = active.map(entry => {
        const rosterMeta = state.playersByCanon[entry.canon];
        const label = rosterMeta?.display || entry.playerName || "Unbekannt";
        const badge = rosterBadgeFor(entry);
        return `
          <tr>
            <td>${escapeHtml(label)}${badge}</td>
            <td>${escapeHtml(formatAbsenceRange(entry))}</td>
            <td>${entry.reason ? escapeHtml(entry.reason) : "–"}</td>
            <td>aktiv</td>
          </tr>
        `;
      }).join("");
      absencesContainer.innerHTML = `
        <table>
          <thead>
            <tr><th>Spieler</th><th>Zeitraum</th><th>Grund</th><th>Status</th></tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;
    }

    function fetchAbsences() {
      state.absences.loading = true;
      state.absences.error = null;
      updateAbsencesUI();
      fetch(ABSENCES_RAW, { cache: "no-store" })
        .then(r => { if (!r.ok) throw new Error(r.status + " " + r.statusText); return r.text(); })
        .then(text => {
          const parsed = parseCsv(text);
          const normalized = parsed.map(normalizeAbsenceRow).filter(row => row.playerName);
          state.absences.entries = normalized;
          state.absences.active = computeActiveAbsences(normalized);
          state.absences.error = null;
        })
        .catch(err => {
          state.absences.entries = [];
          state.absences.active = [];
          state.absences.error = err;
        })
        .finally(() => {
          state.absences.loading = false;
          updateAbsencesUI();
        });
    }

    function renderExtraSignups(extraData, meta) {
      if (!extraRoot) return;
      const groups = ['A','B'];
      const count = groups.reduce((sum, g) => sum + (Array.isArray(extraData[g]) ? extraData[g].length : 0), 0);
      if (extraNote) {
        const parts = ['Pool für nächstes Event'];
        if (meta && typeof meta.total_entries === 'number') parts.push(`Datei-Einträge: ${meta.total_entries}`);
        if (meta && meta.source) parts.push(`Quelle: ${meta.source}`);
        extraNote.textContent = parts.join(' · ');
      }
      if (!count) {
        extraRoot.innerHTML = '<p class="muted">Keine zusätzlichen Zusagen erfasst.</p>';
        return;
      }
      extraRoot.innerHTML = '';
      groups.forEach(group => {
        const card = document.createElement('div');
        card.className = 'extra-card';
        const title = document.createElement('h3');
        title.textContent = `Gruppe ${group}`;
        card.appendChild(title);
        const list = document.createElement('ul');
        list.className = 'extra-list';
        const entries = Array.isArray(extraData[group]) ? extraData[group] : [];
        if (!entries.length) {
          const li = document.createElement('li');
          li.textContent = 'Keine Zusagen';
          list.appendChild(li);
        } else {
          entries.forEach(entry => {
            const li = document.createElement('li');
            const name = entry.player || entry.PlayerName || 'Unbekannt';
            const role = entry.role || entry.Role || '';
            const note = entry.note || entry.Note || '';
            const source = entry.source || entry.Source || '';
            const metaText = [role, source].filter(Boolean).join(' · ');
            li.innerHTML = `${escapeHtml(name)} <span class="tag tag-event">Event-Zusage</span>` +
              `${metaText ? ` <span class="extra-meta">(${escapeHtml(metaText)})</span>` : ''}` +
              `${note ? ` <span class="extra-meta">${escapeHtml(note)}</span>` : ''}`;
            list.appendChild(li);
          });
        }
        card.appendChild(list);
        extraRoot.appendChild(card);
      });
    }

    function renderForcedDiagnostics(diag) {
      const container = document.getElementById('forced-diagnostics');
      if (!container) return;
      const forced = Array.isArray(diag?.forced) ? diag.forced : [];
      const invalid = Array.isArray(diag?.invalid) ? diag.invalid : [];
      const overbooked = Array.isArray(diag?.overbooked) ? diag.overbooked : [];

      if (!forced.length && !invalid.length && !overbooked.length) {
        container.innerHTML = '<p class="muted">Keine verbindlichen Zusagen im Pool.</p>';
        return;
      }

      const parts = [];
      if (overbooked.length) {
        const items = overbooked
          .map(item => {
            const cap = Number.isFinite(item.capacity) ? Number(item.capacity) : null;
            const excess = Number.isFinite(item.excess_forced) ? Number(item.excess_forced) : null;
            const capText = cap != null ? `Slots: ${cap}` : 'Slots unbekannt';
            const excessText = excess != null ? `Überbuchung: +${excess}` : 'Überbuchung';
            return `<li class="warn">${escapeHtml(item.group || '?')}/${escapeHtml(item.role || '?')}: ${excessText} (${capText})</li>`;
          })
          .join('');
        parts.push(`<div><h4>Überbuchungen</h4><ul>${items}</ul></div>`);
      }

      if (invalid.length) {
        const items = invalid
          .map(item => `<li>${escapeHtml(item.player || item.canon || '?')} — ${escapeHtml(item.reason || 'ungültig')}</li>`)
          .join('');
        parts.push(`<div><h4>Ignorierte harte Zusagen</h4><ul>${items}</ul></div>`);
      }

      if (forced.length) {
        const items = forced
          .map(item => {
            const over = item.overbooked ? ' · <span class="warn">(über Kapazität)</span>' : '';
            return `<li>${escapeHtml(item.player || item.canon || '?')} → ${escapeHtml(item.group || '?')}/${escapeHtml(item.role || '?')}${over}</li>`;
          })
          .join('');
        parts.push(`<div><h4>Verbindlich gesetzt</h4><ul>${items}</ul></div>`);
      }

      container.innerHTML = parts.join('');
    }

    fetchAbsences();

    /**
     * Farb-Logik für No-Show-Badges (bisheriges Verhalten in Klartext):
     * 1. Keine Historie (events_seen=0 oder unbekannt) → graue Badge ("nodata").
     * 2. Wer nie gefehlt hat, bleibt grün, unabhängig von der Rate.
     * 3. low-n (≤2 Teilnahmen) wird generell gelb eingeordnet, damit einzelne Ausreißer
     *    nicht sofort rot erscheinen.
     * 4. Single-Miss-Spieler: ab 10 Events und Rate <12 % weiterhin grün, sonst gelb.
     * 5. Alle anderen nutzen die Schwellwerte 20 % (grün→gelb) und 35 % (gelb→rot).
     * 6. Zusätzliche Feinjustierung: Bis 5 Events wird ein eigentlich rotes Rating
     *    auf gelb abgeschwächt, um die geringe Stichprobe sichtbar zu machen.
     */
    function classifyNoShowBadge({ rate, eventsSeen, flags = {} }) {
      const { noData=false, neverMissed=false, lowN=false, singleMiss=false } = flags;

      if (noData) {
        return { level: "nodata", reason: "no-data" };
      }

      if (neverMissed) {
        return { level: "good", reason: "never-missed" };
      }

      if (lowN) {
        return { level: "warning", reason: "low-n" };
      }

      const value = (rate != null && Number.isFinite(rate)) ? rate : null;
      if (value == null) {
        return { level: "nodata", reason: "no-rate" };
      }

      if (singleMiss) {
        if ((eventsSeen ?? 0) >= SINGLE_MISS_GREEN_SEEN_MIN && value < SINGLE_MISS_GREEN_RATE_MAX) {
          return { level: "good", reason: "single-miss-soft-green" };
        }
        return { level: "warning", reason: "single-miss-soft-warning" };
      }

      let level;
      if (value < GREEN_TH) level = "good";
      else if (value < YELLOW_TH) level = "warning";
      else level = "bad";

      if (level === "bad" && eventsSeen != null && eventsSeen <= BADGE_SETTINGS.softenBadUntilSeen) {
        return { level: "warning", reason: "small-sample-soften" };
      }

      return { level, reason: "threshold" };
    }

    const BADGE_CLASS_BY_LEVEL = {
      nodata: "chip ns-neutral",
      neutral: "chip ns-neutral",
      good: "chip ns-ok",
      warning: "chip ns-mid",
      bad: "chip ns-bad",
    };

    function buildChipTooltip(p, rRolling, rOverall) {
      const seen   = (p && Number.isFinite(p.events_seen))  ? Number(p.events_seen)  : null;
      const miss   = (p && Number.isFinite(p.noshow_count)) ? Number(p.noshow_count) : null;
      const eb     = (p && p.eb && isFinite(p.eb.p_hat))    ? Number(p.eb.p_hat)     : null;
      const parts = [];
      parts.push(`n=${seen!=null?seen:"–"}`);
      parts.push(`misses=${miss!=null?miss:"–"}`);
      if (rRolling!=null && isFinite(rRolling)) parts.push(`rolling=${pc(rRolling)}`);
      if (rOverall!=null && isFinite(rOverall)) parts.push(`overall=${pc(rOverall)}`);
      if (eb!=null) parts.push(`eb≈${pc(eb)}`);
      return parts.join(" · ");
    }

    function buildPlayerMetaText(meta) {
      const eventsSeen = Number.isFinite(meta.eventsSeen) ? Number(meta.eventsSeen) : (meta.eventsSeen === 0 ? 0 : null);
      const noshowCountOverall = Number.isFinite(meta.noshowCountOverall) ? Number(meta.noshowCountOverall) : null;
      const noshowRateOverall = Number.isFinite(meta.noshowRateOverall) ? Number(meta.noshowRateOverall) : null;
      const noshowRateRolling = Number.isFinite(meta.noshowRateRolling) ? Number(meta.noshowRateRolling) : null;

      if (eventsSeen === 0) {
        return "0 Events · noch nie teilgenommen";
      }

      const parts = [];

      if (eventsSeen != null) {
        parts.push(`${eventsSeen} ${eventsSeen === 1 ? "Event" : "Events"}`);
      } else {
        parts.push("Events unbekannt");
      }

      if (noshowCountOverall != null) {
        let noshowText = `${noshowCountOverall} No-Show${noshowCountOverall === 1 ? "" : "s"} overall`;
        if (noshowRateOverall != null) {
          noshowText += ` (${pc(noshowRateOverall)})`;
        }
        parts.push(noshowText);
      } else if (noshowRateOverall != null) {
        parts.push(`No-Show overall ${pc(noshowRateOverall)}`);
      } else {
        parts.push("No-Show-Daten fehlen");
      }

      if (noshowRateRolling != null) {
        parts.push(`rolling ${pc(noshowRateRolling)}`);
      }

      if (eventsSeen != null && eventsSeen > 0 && eventsSeen <= 2) {
        parts.push("Schätzung unsicher");
      }

      return parts.join(" · ");
    }

    function writeBucketCounts(key, counts) {
      const h2 = document.querySelector(`#${key} h2`);
      if (!h2) return;
      const base = h2.getAttribute("data-label") || h2.textContent;
      h2.setAttribute("data-label", base);
      const fmt = (value, label) => `${(value==null || !Number.isFinite(value)) ? "–" : value} ${label}`;
      const suffix = ` — ${[fmt(counts.known, "bekannte"), fmt(counts.lown, "low-n"), fmt(counts.nd, "No-Data")].join(" · ")}`;
      h2.innerHTML = `${base}<span class="counts">${suffix}</span>`;
    }

    fetch(LATEST_JSON_URL, { cache: "no-store" })
      .then(r=>{ if(!r.ok) throw new Error(r.status+" "+r.statusText); return r.json(); })
      .then(payload => {
        const schema = (!Array.isArray(payload) && payload && typeof payload === "object") ? (payload.schema || {}) : {};
        const ebEnabled = Boolean(schema && schema.eb && schema.eb.enabled);

        // -------- payload -> rows (kompatibel zu alter Struktur) --------
        const toRows = (payload) => {
          if (Array.isArray(payload)) return payload; // alte Struktur weiterhin akzeptieren
          const playersByDisplay = Object.fromEntries((payload.players || []).map(p => [p.display, p]));
          const groups = payload.groups || {};
          const out = [];
          for (const G of ["A","B"]) {
            const g = groups[G] || {};
            for (const R of ["Start","Ersatz"]) {
              const list = (g[R] || []);
              list.forEach((name, idx) => {
                const p = playersByDisplay[name] || {};
                const eb = (p.eb && typeof p.eb === "object") ? {
                  p_hat: toNumber(p.eb.p_hat),
                  sigma: toNumber(p.eb.sigma),
                } : null;
                out.push({
                  Group: G,
                  Role: R,
                  Slot: idx + 1,
                  PlayerName: name,
                  NoShowOverall: toNumber(p.noshow_overall),
                  NoShowRolling: toNumber(p.noshow_rolling),
                  EB: eb,
                  EventsSeen: toNumber(p.events_seen),
                });
              });
            }
          }
          return out;
        };
        const rows = toRows(payload);

        const playersArray = (!Array.isArray(payload) && Array.isArray(payload.players)) ? payload.players : [];
        const playersMap = Object.fromEntries(
          playersArray
            .filter(p => p && typeof p === "object" && typeof p.display === "string")
            .map(p => [p.display, p])
        );
        const playersByCanon = {};
        playersArray.forEach(p => {
          if (!p || typeof p !== "object") return;
          const canonSource = typeof p.canon === "string" && p.canon.trim() ? p.canon : p.display;
          const canon = canonicalNameJS(canonSource || "");
          if (!canon) return;
          playersByCanon[canon] = {
            display: p.display,
            group: p.group,
            role: p.role,
            has_event_signup: Boolean(p.has_event_signup || p.event_signup),
            event_signup: p.event_signup || null,
            has_forced_signup: Boolean(p.has_forced_signup || p.forced_signup),
            forced_signup: p.forced_signup || null,
          };
        });
        state.playersByCanon = playersByCanon;
        updateAbsencesUI();
        const extraSignups = {
          A: (payload && payload.groups && Array.isArray(payload.groups.A?.extra_signups)) ? payload.groups.A.extra_signups : [],
          B: (payload && payload.groups && Array.isArray(payload.groups.B?.extra_signups)) ? payload.groups.B.extra_signups : [],
        };
        state.forcedDiagnostics = {
          forced: Array.isArray(payload.forced_signups) ? payload.forced_signups : [],
          invalid: Array.isArray(payload.invalid_forced_signups) ? payload.invalid_forced_signups : [],
          overbooked: Array.isArray(payload.overbooked_forced_signups) ? payload.overbooked_forced_signups : [],
        };
        const hasEventsSeen = playersArray.some(p => p && Object.prototype.hasOwnProperty.call(p, "events_seen"));

        const observedFromPlayers = playersArray
          .map(p => {
            if (!p || typeof p !== "object") return null;
            const seen = toNumber(p.events_seen);
            const hasData = (seen == null) || (seen > 0);
            if (p.eb && p.eb.p_hat != null && hasData) {
              const v = toNumber(p.eb.p_hat);
              if (v != null) return v;
            }
            if (p.noshow_rolling != null && hasData) {
              const v = toNumber(p.noshow_rolling);
              if (v != null) return v;
            }
            if (p.noshow_overall != null && hasData) {
              const v = toNumber(p.noshow_overall);
              if (v != null) return v;
            }
            return null;
          })
          .filter(v => v != null);

        // -------- Prior (für No-Data-Spieler) dynamisch bestimmen --------
        // Schätze den Mittelwert der beobachteten Raten (EB bevorzugt, sonst rolling → overall)
        let observed = observedFromPlayers;
        if (!observed.length) {
          observed = rows.map(r => {
            const seen = toNumber(r.EventsSeen);
            const hasData = (seen == null) || (seen > 0);
            if (r.EB && r.EB.p_hat != null && hasData) {
              const v = toNumber(r.EB.p_hat);
              if (v != null) return v;
            }
            if (r.NoShowRolling != null && hasData) {
              const v = toNumber(r.NoShowRolling);
              if (v != null) return v;
            }
            if (r.NoShowOverall != null && hasData) {
              const v = toNumber(r.NoShowOverall);
              if (v != null) return v;
            }
            return null;
          }).filter(v => v != null);
        }
        const avg = (arr)=> arr.reduce((a,b)=>a+b,0)/Math.max(1,arr.length);
        const fallbackPrior = (schema.prior && schema.prior.fallback != null && isFinite(schema.prior.fallback)) ? Number(schema.prior.fallback) : DEFAULT_PRIOR_FALLBACK;
        const priorPad = (schema.prior && schema.prior.pad != null && isFinite(schema.prior.pad)) ? Number(schema.prior.pad) : DEFAULT_PRIOR_PAD;
        const teamMeanSchema = (schema.prior && schema.prior.team_mean != null && isFinite(schema.prior.team_mean)) ? Number(schema.prior.team_mean) : null;
        const priorValueSchema = (schema.prior && schema.prior.value != null && isFinite(schema.prior.value)) ? Number(schema.prior.value) : null;
        const priorBase = observed.length ? avg(observed) : fallbackPrior;
        const teamMean = (teamMeanSchema != null) ? teamMeanSchema : priorBase;
        const PRIOR_NOSHOW = clamp(priorValueSchema != null ? priorValueSchema : (teamMean + priorPad));

        // -------- Effektive Rate je Spieler für Sortierung --------
        const effRate = (r) => {
          if (r.EB && r.EB.p_hat != null) {
            const v = toNumber(r.EB.p_hat);
            if (v != null) return clamp(v);
          }
          const rolling = toNumber(r.NoShowRolling);
          if (rolling != null) return clamp(rolling);
          const overall = toNumber(r.NoShowOverall);
          if (overall != null) return clamp(overall);
          return PRIOR_NOSHOW;
        };

        // Sort-Hinweis im UI
        document.getElementById("sort-note").textContent =
          `Sortierung: niedrigste Risiko-Schätzung zuerst (Primär: ${ebEnabled ? "EB p̂" : "rolling"}, Fallback: ${ebEnabled ? "rolling → overall" : "overall"}, Prior ≈ ${(PRIOR_NOSHOW*100).toFixed(1)}%).`;

        // -------- Buckets bilden --------
        const targets = ["A-Start","A-Ersatz","B-Start","B-Ersatz"];
        const buckets = Object.fromEntries(targets.map(k => [k, []]));
        rows.forEach(r=>{
          const key = `${r.Group}-${r.Role}`;
          if (buckets[key]) buckets[key].push(r);
        });

        // -------- Buckets nach No-Show (aufsteigend) sortieren --------
        for (const key of targets) {
          buckets[key].sort((a,b)=>{
            const da = effRate(a), db = effRate(b);
            if (Math.abs(da - db) > EPS) return da - db;              // 1) No-Show (ASC)
            const oaVal = (toNumber(a.NoShowOverall) != null) ? toNumber(a.NoShowOverall) : 1;
            const obVal = (toNumber(b.NoShowOverall) != null) ? toNumber(b.NoShowOverall) : 1;
            const oa = oaVal ?? 1;
            const ob = obVal ?? 1;
            if (Math.abs(oa - ob) > EPS) return oa - ob;              // 2) Overall (ASC) als Tiebreak
            return (a.PlayerName||"").localeCompare(b.PlayerName||""); // 3) Name
          });
        }

        // -------- Render --------
        for (const key of targets) {
          const tbody = document.querySelector(`#${key} tbody`);
          tbody.innerHTML = "";
          (buckets[key] || []).forEach((r, i) => {
            const histOverall = toNumber(r.NoShowOverall);
            const histRolling = toNumber(r.NoShowRolling);
            const p = playersMap[r.PlayerName] || {};

            const seenSource = Number.isFinite(p.events_seen) ? Number(p.events_seen) : null;
            const seenFallback = Object.prototype.hasOwnProperty.call(r, "EventsSeen") ? toNumber(r.EventsSeen) : null;
            const seen = (seenSource != null) ? seenSource : seenFallback;

            const missesSource = Number.isFinite(p.noshow_count) ? Number(p.noshow_count) : null;
            const missesFallback = Object.prototype.hasOwnProperty.call(r, "NoShowCount") ? toNumber(r.NoShowCount) : null;
            const misses = (missesSource != null) ? missesSource : missesFallback;

            const seenKnown = (p && Object.prototype.hasOwnProperty.call(p, "events_seen")) ||
              Object.prototype.hasOwnProperty.call(r, "EventsSeen");
            const annotate = seenKnown || hasEventsSeen;

            const participated = (seen != null && seen > 0);
            const noData = annotate ? !participated : false;
            const lowN = annotate ? (participated && seen <= BADGE_SETTINGS.lowNMax) : false;
            const neverMissed = annotate ? (participated && misses === 0) : false;
            const singleMiss = annotate ? (participated && misses === 1) : false;

            const histRate = (histRolling ?? histOverall);

            const tip = buildChipTooltip(p, histRolling, histOverall);

            const shownOverall = noData ? null : histOverall;
            const shownRolling = noData ? null : histRolling;
            const badge = classifyNoShowBadge({
              rate: histRate,
              eventsSeen: annotate ? seen : null,
              flags: { noData, neverMissed, lowN, singleMiss },
            });
            const chipKlass = BADGE_CLASS_BY_LEVEL[badge.level] || BADGE_CLASS_BY_LEVEL.nodata;
            const reasonHint = badge.reason ? ` · badge=${badge.reason}` : "";
            const tooltip = `${tip}${reasonHint}`.replace(/"/g, '&quot;');
            let nameHTML = `${r.PlayerName || ""}`;
            if (noData) {
              nameHTML += ' <span class="tag tag-nd" title="Keine Historie – events_seen = 0">No&nbsp;Data</span>';
            }
            if (lowN) {
              nameHTML += ' <span class="tag tag-low" title="Wenig Historie – events_seen ∈ {1,2}">low&nbsp;n</span>';
            }
            if (p && (p.has_forced_signup || p.forced_signup)) {
              nameHTML += ' <span class="tag tag-hard" title="Verbindliche Zusage (hart gesetzt)">verbindlich</span>';
            }
            if (p && (p.has_event_signup || p.event_signup)) {
              nameHTML += ' <span class="tag tag-event" title="Zusage im Event-Pool (nächstes Event)">Event-Zusage</span>';
            }
            const noshowCountOverall = Number.isFinite(p.noshow_count_overall) ? Number(p.noshow_count_overall) :
              (Number.isFinite(p.noshow_count) ? Number(p.noshow_count) :
              (Object.prototype.hasOwnProperty.call(r, "NoShowCount") ? toNumber(r.NoShowCount) : null));
            const metaText = buildPlayerMetaText({
              eventsSeen: seen,
              noshowCountOverall,
              noshowRateOverall: histOverall,
              noshowRateRolling: histRolling,
            });
            const tr = document.createElement("tr");
            tr.innerHTML = `
              <td class="num">${pad(i+1)}</td>
              <td>
                <div class="player-name-row">${nameHTML}</div>
                <div class="player-meta-row">${metaText}</div>
              </td>
              <td><span class="${chipKlass}" title="${tooltip}">${pc(shownOverall)}</span></td>
              <td><span class="${chipKlass}" title="${tooltip}">${pc(shownRolling)}</span></td>
            `;
            tbody.appendChild(tr);
          });

          if (!window.__bucketCounts) window.__bucketCounts = {};
          const keyCounts = { known:0, lown:0, nd:0 };
          (buckets[key] || []).forEach(row => {
            const pp = playersMap[row.PlayerName] || {};
            const seenVal = Number.isFinite(pp.events_seen) ? Number(pp.events_seen) :
              (Object.prototype.hasOwnProperty.call(row, "EventsSeen") ? toNumber(row.EventsSeen) : null);
            if (!(seenVal > 0)) { keyCounts.nd++; return; }
            if (seenVal <= BADGE_SETTINGS.lowNMax) { keyCounts.lown++; return; }
            keyCounts.known++;
          });
          window.__bucketCounts[key] = keyCounts;
          writeBucketCounts(key, keyCounts);
        }

        renderExtraSignups(extraSignups, payload.event_signups || null);
        renderForcedDiagnostics(state.forcedDiagnostics);

        const ts = new Date().toISOString().replace('T',' ').slice(0,19) + " UTC";
        const schemaVersion = (schema && schema.version != null) ? ` · schema v${schema.version}` : "";
        document.getElementById("stamp").textContent = `Stand: ${ts}${schemaVersion}`;
      })
      .catch(err=>{
        document.body.insertAdjacentHTML("beforeend",
          `<p style="color:#b00">Fehler beim Laden von <code>latest.json</code>: ${String(err)}</p>`);
      });
  </script>
</body>
</html>
