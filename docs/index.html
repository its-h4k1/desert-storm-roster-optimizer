<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Desert Storm â€“ Aufstellung (Latest)</title>
  <style>
    :root{
      --fg:#111; --muted:#666; --line:#ddd;
      --ok:#1f9d55; --mid:#c9a227; --bad:#d64545;
      --bg:#fff; --bgth:#fafafa;
    }
    body{font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial,"Noto Sans",sans-serif;margin:24px;color:var(--fg);background:var(--bg)}
    h1{margin:0 0 8px}
    h2{margin:0 0 8px}
    h3{margin:12px 0 6px;font-weight:600}
    .top-bar{display:flex;align-items:flex-start;gap:12px;flex-wrap:wrap;margin:0 0 6px}
    .top-actions{margin-left:auto;display:flex;gap:10px;align-items:flex-start;flex-wrap:wrap}
    .admin-link{display:inline-flex;align-items:center;gap:8px;padding:8px 14px;border:1px solid var(--line);border-radius:10px;text-decoration:none;color:var(--fg);background:#fff;box-shadow:0 4px 12px rgba(0,0,0,0.05);font-weight:600}
    .admin-link:hover{border-color:#c8d5ec;box-shadow:0 6px 16px rgba(0,0,0,0.08)}
    .admin-link:active{transform:translateY(1px)}
    .stamp{display:block;font-size:0.8em;line-height:1.4;margin-top:4px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:24px}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left;vertical-align:top}
    th{background:var(--bgth)}
    .muted{color:var(--muted)}
    .num{font-variant-numeric:tabular-nums}
    .counts{font-size:.9em;color:var(--muted);font-weight:400;margin-left:.25rem}
    .chip{display:inline-block;min-width:52px;text-align:right;padding:2px 8px;border-radius:999px;border:1px solid var(--line)}
    .chip.ns-neutral{background:#f6f7f8;border:1px solid #ccc;color:#555}
    .ns-ok{border-color:#bfe8cc;background:#f3fbf6}
    .ns-mid{background:#fff9e6;border:1px solid #f3d78a}
    .ns-bad{border-color:#f2b7b7;background:#fff5f5}
    .sub{margin:6px 0 18px}
    .wrap{display:grid;grid-template-columns:1fr;gap:28px}
    @media (min-width: 960px){ .wrap{grid-template-columns:1fr 1fr} }
    .tag{display:inline-block;margin-left:6px;padding:2px 7px;border-radius:999px;font-size:0.72em;font-weight:600;vertical-align:middle}
    .tag-abs-active{background:#ecfdf3;border:1px solid #bbf7d0;color:#166534}
    .tag-abs-planned{background:#eef2ff;border:1px solid #c7d2fe;color:#312e81}
    .tag-nd{background:var(--bad);color:#fff}
    .tag-low{background:#f1e1a8;color:#111}
    .tag-event{background:#ecfeff;border:1px solid #a5f3fc;color:#0f172a}
    .tag-hard{background:#fee2e2;border:1px solid #fecdd3;color:#7f1d1d}
    .tag-fix{background:#f5f5f5;border:1px solid #d4d4d8;color:#3f3f46;display:inline-flex;align-items:center;gap:4px;letter-spacing:0.01em}
    .tag-callup{background:#eff6ff;border:1px solid #bfdbfe;color:#1d4ed8;display:inline-flex;align-items:center;gap:4px;letter-spacing:0.01em;font-weight:600}
    .legend{font-size:0.85em;margin:32px 0 0}
    .legend + .legend{margin-top:6px}
    .roster-controls{margin:12px 0 20px;display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .player-meta-toggle{font-size:0.9em;color:var(--fg);display:inline-flex;align-items:center;gap:8px;cursor:pointer;user-select:none}
    .player-meta-toggle input{width:16px;height:16px}
    .btn{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);background:#fff;border-radius:8px;padding:7px 10px;font-weight:600;cursor:pointer;color:var(--fg);box-shadow:0 4px 10px rgba(0,0,0,0.04)}
    .btn:disabled{opacity:0.55;cursor:not-allowed;box-shadow:none}
    .player-name-row{font-size:14px;font-weight:600}
    .player-meta-row{font-size:11px;color:#777;margin-top:2px;display:none}
    .show-player-meta .player-meta-row{display:block}
    .hide-callups .callup-badge{display:none}
    #absences{margin-top:48px;padding-top:24px;border-top:1px solid var(--line)}
    #absences h2{margin:0 0 8px}
    #absences .absences-empty{color:var(--muted);margin:0}
    #absences table{margin-top:12px}
    .absences-roster-badge{display:inline-block;margin-left:6px;padding:2px 8px;border-radius:999px;border:1px solid var(--line);font-size:0.75em;color:var(--muted);background:var(--bgth)}
    .absences-error{color:#b00}
    .extra-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px;margin-top:8px}
    .extra-card{border:1px solid var(--line);border-radius:10px;padding:10px;background:var(--bgth)}
    .extra-card h3{margin:0 0 6px}
    .extra-list{list-style:none;padding:0;margin:0;display:grid;gap:6px}
    .extra-meta{color:var(--muted);font-size:0.85em}
    .diag{margin:10px 0 0;padding:10px;border-radius:10px;border:1px solid var(--line);background:#fff}
    .diag h4{margin:0 0 6px;font-size:1em}
    .diag ul{margin:0;padding-left:20px;color:#444}
    .diag .warn{color:#7f1d1d;font-weight:600}
    #extras{margin-top:48px;padding-top:24px;border-top:1px solid var(--line)}
    #extras h2{margin-top:0}
    #signup-inline{display:none;margin-top:8px}
  </style>
</head>
<body>
  <div class="top-bar">
    <h1>Desert Storm â€“ Aufstellung <span id="stamp" class="muted stamp"></span></h1>
    <div class="top-actions">
      <a class="admin-link" href="admin/index.html">Admin &amp; Tools</a>
    </div>
  </div>
  <p class="muted" id="sort-note" style="margin:0 0 18px"></p>

  <div class="roster-controls">
    <label class="player-meta-toggle">
      <input type="checkbox" id="player-meta-toggle" />
      Detailzeile pro Spieler anzeigen
    </label>
    <label class="player-meta-toggle">
      <input type="checkbox" id="callup-toggle" checked />
      Callup-Empfehlungen anzeigen
    </label>
    <button id="callup-export" class="btn" type="button" disabled title="Keine Callup-Kandidaten im aktuellen Roster">
      ðŸ“¥ Callup-Kandidaten als CSV exportieren
    </button>
  </div>

  <p class="muted" id="callup-note" style="margin:0 0 18px; display:none"></p>

  <div id="roster-root" class="grid">
    <section id="A-Start">
      <h2>Gruppe A Â· Start</h2>
      <table>
        <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
    <section id="A-Ersatz">
      <h2>Gruppe A Â· Ersatz</h2>
      <table>
        <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
    <section id="B-Start">
      <h2>Gruppe B Â· Start</h2>
      <table>
        <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
    <section id="B-Ersatz">
      <h2>Gruppe B Â· Ersatz</h2>
      <table>
        <thead><tr><th>#</th><th>Spieler</th><th>No-Show (overall)</th><th>No-Show (rolling)</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>
  </div>

  <section id="extras">
    <h2>ZusÃ¤tzliche Zusagen (Pool nÃ¤chstes Event)</h2>
    <p class="muted" id="extra-note">LÃ¤dt Zusagen â€¦</p>
    <div id="forced-diagnostics" class="diag"></div>
    <div id="extra-root" class="extra-grid"></div>
  </section>

  <p class="muted legend">Legende: <span class="tag tag-nd" title="Keine Historie â€“ events_seen = 0">No&nbsp;Data</span> keine Historie Â· <span class="tag tag-low" title="Wenig Historie â€“ events_seen âˆˆ {1,2}">low&nbsp;n</span> wenig Historie Â· <span class="tag tag-fix">ðŸ”’ verbindlich</span> verbindliche Zusage (Commitment=hard) Â· <span class="tag tag-callup callup-badge">ðŸ”” Callup</span> Spieler, fÃ¼r die eine Erinnerung empfohlen wird<br />Farben basieren auf Historie (rollingâ†’overall), EB wird nur zur Sortierung verwendet.<br />No-Data = nie teilgenommen (grau). low-n â‰¤2 = gelb. 1 Fehltermin = nie rot.</p>
  <p class="muted legend" id="signup-inline"></p>

  <section id="absence-diagnostics" class="diag" style="display:none"></section>

  <section id="absences">
    <h2>Absenzen</h2>
    <div id="absences-content" class="muted">Wird geladen â€¦</div>
  </section>

  <p class="sub muted">Quelle: <code>out/latest.json</code> (GitHub)</p>

  <script src="shared.js"></script>
  <script>
    // Quelle (mit Cache-Buster)
    const url = new URL(location.href);
    const branchOverride = url.searchParams.get('branch');
    const branch = branchOverride || 'main';
    const cacheBuster = `?v=${Date.now()}`;
    const SITE_ROOT = dsroShared.computeSiteRoot(location.pathname || '/');
    const LATEST_JSON_URL = dsroShared.buildLatestJsonUrl({ branchOverride, cacheBuster, siteRoot: SITE_ROOT });
    const canonicalNameJS = dsroShared.canonicalNameJS;
    const escapeHtml = dsroShared.escapeHtml;
    // Main roster UI expects latest.json at: docs/out/latest.json (served as out/latest.json on GitHub Pages).
    // Konfiguration: Prior-Defaults (werden durch schema.prior Ã¼berschrieben)
    const DEFAULT_PRIOR_FALLBACK = 0.18;
    const DEFAULT_PRIOR_PAD = 0.02;
    const EPS = 1e-12;

    const state = {
      showPlayerMeta: false,
      showCallups: true,
      absences: { entries: [], active: [], error: null, loading: true },
      absenceDebug: null,
      absenceConflicts: [],
      playersByCanon: {},
      forcedDiagnostics: { forced: [], invalid: [], overbooked: [] },
      callupMeta: { available: false, recommendedTotal: null, reasonCounts: {}, fromStats: false, hasStats: false },
      callupCandidates: [],
      latestPayload: null,
      playersArray: [],
    };
    const rosterRoot = document.getElementById("roster-root");
    const playerMetaToggle = document.getElementById("player-meta-toggle");
    const callupToggle = document.getElementById("callup-toggle");
    const callupNote = document.getElementById("callup-note");
    const callupExportBtn = document.getElementById("callup-export");
    const absencesContainer = document.getElementById("absences-content");
    const absenceDiag = document.getElementById("absence-diagnostics");
    const extraRoot = document.getElementById("extra-root");
    const extraNote = document.getElementById("extra-note");
    const signupInline = document.getElementById("signup-inline");
    if (playerMetaToggle) {
      state.showPlayerMeta = Boolean(playerMetaToggle.checked);
      playerMetaToggle.addEventListener("change", (event) => {
        state.showPlayerMeta = event.target.checked;
        if (rosterRoot) {
          rosterRoot.classList.toggle("show-player-meta", state.showPlayerMeta);
        }
      });
    }
    if (callupToggle) {
      state.showCallups = Boolean(callupToggle.checked);
      callupToggle.addEventListener("change", (event) => {
        state.showCallups = event.target.checked;
        if (rosterRoot) {
          rosterRoot.classList.toggle("hide-callups", !state.showCallups);
        }
        document.body.classList.toggle("hide-callups", !state.showCallups);
        updateCallupNote(state.callupMeta);
      });
    }
    if (callupExportBtn) {
      callupExportBtn.addEventListener("click", () => {
        const candidates = state.callupCandidates || [];
        if (!candidates.length) {
          callupExportBtn.title = 'Keine Callup-Kandidaten im aktuellen Roster';
          return;
        }
        exportCallupCandidatesCsv(state.latestPayload, candidates);
      });
    }
    if (rosterRoot) {
      rosterRoot.classList.toggle("show-player-meta", state.showPlayerMeta);
      rosterRoot.classList.toggle("hide-callups", !state.showCallups);
    }
    document.body.classList.toggle("hide-callups", !state.showCallups);
    updateCallupNote(state.callupMeta);
    updateCallupExportButton(state.callupMeta, state.callupCandidates);

    // Format & Styling
    const pad = (n)=> String(n).padStart(2,"0");
    const pc  = (x)=> (x==null || isNaN(x)) ? "â€“" : (Math.round(x*1000)/10).toFixed(1)+"%";
    const BADGE_SETTINGS = {
      thresholds: {
        ok: 0.20,
        warning: 0.35,
      },
      singleMiss: {
        seenMin: 10,
        rateMax: 0.12,
      },
      lowNMax: 2,
      softenBadUntilSeen: 5,
    };
    const GREEN_TH  = BADGE_SETTINGS.thresholds.ok;
    const YELLOW_TH = BADGE_SETTINGS.thresholds.warning;
    const SINGLE_MISS_GREEN_SEEN_MIN = BADGE_SETTINGS.singleMiss.seenMin;
    const SINGLE_MISS_GREEN_RATE_MAX = BADGE_SETTINGS.singleMiss.rateMax;
    const clamp = (x)=> Math.min(1, Math.max(0, x));
    const toNumber = (v)=>{
      if (v==null) return null;
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };

    const CALLUP_REASON_LABELS = {
      high_overall: "Hohe No-Show overall",
      high_rolling: "Hohe No-Show rolling",
      rolling_uptick: "Rolling-Uptick (rolling > overall)",
      recent_uptick: "Rolling-Uptick (rolling > overall)",
      low_n: "Low-N (wenig Events)",
    };

    function formatCallupReasons(callup) {
      if (!callup) return "";
      const rawReasons = Array.isArray(callup.reasons) ? callup.reasons : [];
      const codes = new Set();
      const fallbackLabels = [];
      rawReasons.forEach(r => {
        if (!r) return;
        const code = (typeof r === "string") ? r : (r.code || r.label || "");
        const normalized = String(code || "").trim();
        if (normalized) {
          codes.add(normalized);
        } else if (typeof r.label === "string") {
          fallbackLabels.push(r.label.trim());
        }
      });

      const labels = [];
      const hasHighOverall = codes.has("high_overall");
      const hasHighRolling = codes.has("high_rolling");
      const hasRollingUptick = codes.has("rolling_uptick") || codes.has("recent_uptick");
      const hasLowN = codes.has("low_n");

      if (hasHighOverall && hasHighRolling) {
        labels.push("Hohe No-Show (overall + rolling)");
      } else {
        if (hasHighOverall) labels.push(CALLUP_REASON_LABELS.high_overall);
        if (hasHighRolling) labels.push(CALLUP_REASON_LABELS.high_rolling);
      }
      if (hasRollingUptick) {
        labels.push(CALLUP_REASON_LABELS.rolling_uptick);
      }
      if (hasLowN) labels.push(CALLUP_REASON_LABELS.low_n);

      if (!labels.length && fallbackLabels.length) {
        labels.push(...fallbackLabels);
      }

      return labels.join(" Â· ");
    }

    function normalizeCallup(player) {
      const p = (player && typeof player === 'object') ? player : null;
      const rawCallup = (p && p.callup && typeof p.callup === 'object') ? p.callup : null;
      const base = rawCallup && typeof rawCallup === 'object' ? { ...rawCallup } : {};
      const recommendedRaw = (rawCallup && typeof rawCallup.recommended === 'boolean') ? Boolean(rawCallup.recommended) : null;
      const recommendedFlag = (p && typeof p.callup_recommended === 'boolean') ? Boolean(p.callup_recommended) : null;

      const normalizedReasons = [];
      const seenCodes = new Set();
      const rawReasons = Array.isArray(rawCallup?.reasons) ? rawCallup.reasons : [];
      rawReasons.forEach(reason => {
        if (!reason || typeof reason !== 'object') return;
        const code = String(reason.code || '').trim();
        const label = CALLUP_REASON_LABELS[code] || reason.label || code || 'Callup empfohlen';
        if (code) seenCodes.add(code);
        normalizedReasons.push({ code: code || 'unknown', label });
      });

      const reasonCodes = Array.isArray(p?.callup_reason_codes) ? p.callup_reason_codes : [];
      const singleReason = (p && typeof p.callup_reason === 'string' && p.callup_reason.trim()) ? [p.callup_reason] : [];
      [...reasonCodes, ...singleReason].forEach(code => {
        if (code === null || code === undefined) return;
        const normalized = String(code || 'unknown').trim() || 'unknown';
        if (normalized && !seenCodes.has(normalized)) {
          seenCodes.add(normalized);
          normalizedReasons.push({ code: normalized, label: CALLUP_REASON_LABELS[normalized] || normalized });
        }
      });

      const recommended = (recommendedRaw !== null)
        ? recommendedRaw
        : (recommendedFlag !== null ? recommendedFlag : normalizedReasons.length > 0);

      if (!recommended && normalizedReasons.length === 0 && !rawCallup && recommendedFlag === null) {
        return null;
      }

      base.recommended = Boolean(recommended);
      base.reasons = normalizedReasons;
      return base;
    }

    function buildCallupBadge(callup) {
      if (!callup || !callup.recommended) return "";
      const reasonText = formatCallupReasons(callup);
      const label = "Callup";
      const title = reasonText ? `Callup empfohlen: ${reasonText}` : "Callup empfohlen";
      return `<span class="tag tag-callup callup-badge" title="${escapeHtml(title)}">ðŸ”” ${escapeHtml(label)}</span>`;
    }

    function extractCallupMeta(payload, playersArray, schema = {}) {
      const schemaVersion = Number.isFinite(schema.version) ? Number(schema.version) : null;
      const stats = payload && typeof payload === 'object' && payload.callup_stats && typeof payload.callup_stats === 'object'
        ? payload.callup_stats
        : null;
      const statsCountRaw = stats && Object.prototype.hasOwnProperty.call(stats, 'recommended_total')
        ? Number(stats.recommended_total)
        : null;
      const statsCount = Number.isFinite(statsCountRaw) ? statsCountRaw : null;
      const statsReasons = (stats && stats.reasons && typeof stats.reasons === 'object') ? stats.reasons : null;
      const hasStats = Boolean(stats);
      const configSnapshot = (stats && typeof stats.config_snapshot === 'object') ? stats.config_snapshot : null;

      let derivedCount = 0;
      const derivedReasons = {};
      playersArray.forEach(p => {
        if (!p || typeof p !== 'object') return;
        const callup = normalizeCallup(p);
        const recommended = Boolean(callup && callup.recommended === true);
        if (!recommended) return;
        derivedCount += 1;
        if (Array.isArray(callup.reasons)) {
          callup.reasons.forEach(reason => {
            if (!reason || typeof reason !== 'object') return;
            const code = String(reason.code || 'unknown');
            derivedReasons[code] = (derivedReasons[code] || 0) + 1;
          });
        }
      });

      const recommendedTotal = statsCount != null ? statsCount : derivedCount;
      const reasonCounts = statsReasons || derivedReasons;
      const available = Boolean(hasStats || derivedCount > 0 || playersArray.some(p => normalizeCallup(p)));

      return { available, recommendedTotal, reasonCounts, fromStats: Boolean(hasStats && statsCount != null), hasStats, schemaVersion, configSnapshot };
    }

    function updateCallupNote(meta) {
      if (!callupNote) return;
      const show = state.showCallups;
      if (!show) {
        callupNote.style.display = 'none';
        return;
      }

      const hasStats = Boolean(meta && meta.hasStats);
      const recommendedTotal = Number.isFinite(meta?.recommendedTotal) ? Number(meta.recommendedTotal) : null;
      const reasonCounts = meta?.reasonCounts || {};
      const configSnapshot = meta?.configSnapshot;

      let text = '';
      if (!hasStats) {
        text = 'Callup-Empfehlungen: nicht verfÃ¼gbar (Ã¤ltere schema-Version).';
      } else if (recommendedTotal === 0) {
        text = 'Callup-Empfehlungen: keine Spieler empfohlen.';
      } else if (recommendedTotal != null && recommendedTotal > 0) {
        text = `Callup-Empfehlungen: ${recommendedTotal} Spieler empfohlen.`;
      }

      const breakdownOrder = ['high_rolling', 'rolling_uptick', 'high_overall', 'recent_uptick', 'low_n'];
      const breakdown = breakdownOrder
        .map(code => {
          const count = Number.isFinite(reasonCounts[code]) ? Number(reasonCounts[code]) : null;
          if (count == null || count <= 0) return '';
          const label = CALLUP_REASON_LABELS[code] || code;
          return `${count}Ã— ${label}`;
        })
        .filter(Boolean);

      if (text && breakdown.length) {
        text += ` â€” GrÃ¼nde: ${breakdown.join(' Â· ')}`;
      }

      const rulesText = buildConfigSnapshotText(configSnapshot);
      const parts = [];
      if (text) parts.push(text);
      if (rulesText) parts.push(rulesText);

      if (parts.length) {
        callupNote.textContent = parts.join(' â€” ');
        callupNote.style.display = 'block';
      } else {
        callupNote.textContent = '';
        callupNote.style.display = 'none';
      }
    }

    function formatPercentShort(value) {
      const n = Number(value);
      if (!Number.isFinite(n)) return null;
      return `${Math.round(n * 100)} %`;
    }

    function formatPercentPointsShort(value) {
      const n = Number(value);
      if (!Number.isFinite(n)) return null;
      return `${Math.round(n * 100)} pp`;
    }

    function buildConfigSnapshotText(snapshot) {
      if (!snapshot || typeof snapshot !== 'object') return '';
      const overall = formatPercentShort(snapshot.high_overall_threshold);
      const rolling = formatPercentShort(snapshot.high_rolling_threshold);
      const rollingMin = formatPercentShort(snapshot.rolling_uptick_min);
      const rollingDelta = formatPercentPointsShort(snapshot.rolling_uptick_delta);
      const lowN = Number.isFinite(Number(snapshot.low_n_max_events)) ? Number(snapshot.low_n_max_events) : null;
      const minEvents = Number.isFinite(Number(snapshot.min_events)) ? Number(snapshot.min_events) : null;

      const parts = [];
      if (overall || rolling) {
        const suffix = minEvents != null ? ` (ab â‰¥ ${minEvents} Events)` : '';
        if (overall) parts.push(`High overall â‰¥ ${overall}${suffix}`);
        if (rolling) parts.push(`High rolling â‰¥ ${rolling}${suffix}`);
      }
      const uptickParts = [];
      if (rollingMin) uptickParts.push(rollingMin);
      if (rollingDelta) uptickParts.push(`+${rollingDelta}`);
      if (uptickParts.length) parts.push(`Rolling-Uptick â‰¥ ${uptickParts.join(' & ')}`);
      if (lowN != null) parts.push(`Low-N â‰¤ ${lowN} Events`);

      if (!parts.length) return '';
      return `Regeln: ${parts.join(', ')}`;
    }

    function updateCallupExportButton(meta, candidates = []) {
      if (!callupExportBtn) return;
      const recommendedTotal = Number.isFinite(meta?.recommendedTotal) ? Number(meta.recommendedTotal) : null;
      const hasCandidates = Array.isArray(candidates) ? candidates.length > 0 : false;
      const enabled = hasCandidates || (recommendedTotal != null && recommendedTotal > 0);
      callupExportBtn.disabled = !enabled;
      callupExportBtn.title = enabled
        ? 'Callup-Kandidaten als CSV exportieren'
        : 'Keine Callup-Kandidaten im aktuellen Roster';
    }

    function splitCsvLine(line) {
      const out = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (inQuotes) {
          if (char === '"') {
            if (line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            current += char;
          }
        } else if (char === '"') {
          inQuotes = true;
        } else if (char === ',') {
          out.push(current);
          current = "";
        } else {
          current += char;
        }
      }
      out.push(current);
      return out;
    }

    function parseCsv(text) {
      const cleaned = (text || "").replace(/^\ufeff/, "").split(/\r?\n/);
      const lines = cleaned.filter(line => line && line.trim().length);
      if (!lines.length) return [];
      const headers = splitCsvLine(lines.shift()).map(h => h.trim());
      return lines.map(line => {
        const cells = splitCsvLine(line);
        const obj = {};
        headers.forEach((header, idx) => {
          obj[header] = cells[idx] != null ? cells[idx].trim() : "";
        });
        return obj;
      });
    }

    function parseDateOnly(value) {
      if (!value) return null;
      const trimmed = String(value).trim();
      if (!trimmed) return null;
      const date = new Date(trimmed);
      if (Number.isNaN(date.getTime())) return null;
      return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
    }

    function escapeCsvCell(value) {
      const str = value == null ? '' : String(value);
      const escaped = str.replace(/"/g, '""');
      return `"${escaped}"`;
    }

    function buildCallupCsvFilename(payload) {
      const rawStamp = (payload && typeof payload.generated_at === 'string' && payload.generated_at.trim())
        ? payload.generated_at
        : new Date().toISOString();
      const safe = rawStamp.replace(/[:T]/g, '-').replace(/\..*/, '').replace(/Z$/, '');
      return `callup_candidates-${safe}.csv`;
    }

    function collectCallupCandidates(playersArray) {
      const list = Array.isArray(playersArray) ? playersArray : [];
      return list.filter(p => {
        if (!p || typeof p !== 'object') return false;
        const callup = normalizeCallup(p);
        const recommended = callup ? callup.recommended === true : Boolean(p.callup_recommended);
        return recommended;
      });
    }

    function exportCallupCandidatesCsv(payload, candidates) {
      if (!Array.isArray(candidates) || !candidates.length) return;

      const formatRatio = (val) => {
        const num = toNumber(val);
        return num == null ? '' : num.toFixed(3);
      };

      const header = [
        'PlayerName',
        'Group',
        'Role',
        'EventsSeen',
        'NoShowsTotal',
        'NoShowOverall',
        'NoShowRolling',
        'CallupReason',
        'LastSeenDate',
        'LastNoShowDate',
      ];

      const rows = candidates.map(p => {
        const callup = normalizeCallup(p);
        const reason = callup ? formatCallupReasons(callup) : '';
        const eventsSeen = toNumber(p.events_seen) ?? '';
        const noShowCount = toNumber(p.noshow_count_overall ?? p.noshow_count) ?? '';
        const lastSeen = p.last_seen || p.LastSeenDate || '';
        const lastNoShow = p.last_noshow_date || p.LastNoShowDate || '';
        return [
          p.display || p.PlayerName || '',
          p.group || p.Group || '',
          p.role || p.Role || '',
          eventsSeen,
          noShowCount,
          formatRatio(p.noshow_overall ?? p.NoShowOverall),
          formatRatio(p.noshow_rolling ?? p.NoShowRolling),
          reason,
          lastSeen,
          lastNoShow,
        ];
      });

      const csvLines = [header, ...rows]
        .map(line => line.map(escapeCsvCell).join(','))
        .join('\n');

      const blob = new Blob([csvLines], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = buildCallupCsvFilename(payload);
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function parseInAllianceFlag(value) {
      if (value == null) return false;
      const normalized = String(value).trim().toLowerCase();
      // "InAlliance" kennzeichnet die Allianz-Mitgliedschaft (1 = im Roster, 0 = ausgetreten).
      return ["1","true","yes","y","aktiv","active"].includes(normalized);
    }

    function normalizeAbsenceFromPayload(row) {
      const playerName = (
        row?.name ?? row?.Name ?? row?.player ?? row?.PlayerName ?? row?.display ?? ""
      ).toString().trim();
      const from = (row?.from ?? row?.From ?? "").toString().trim();
      const to = (row?.to ?? row?.To ?? "").toString().trim();
      const reason = (row?.reason ?? row?.Reason ?? "").toString().trim();
      const inAlliance = row?.in_alliance ?? row?.InAlliance ?? row?.Active ?? row?.active ?? 1;
      const activeFlagRaw = row?.is_active_next_event ?? row?.isActive ?? row?.active;
      const isActiveNextEvent = typeof activeFlagRaw === 'boolean' ? activeFlagRaw : null;
      const scopeRaw = (row?.scope ?? row?.Scope ?? '').toString().trim().toLowerCase();
      return {
        playerName,
        canon: canonicalNameJS(row?.canonical || playerName),
        from,
        to,
        fromDate: parseDateOnly(from),
        toDate: parseDateOnly(to),
        reason,
        inAlliance: parseInAllianceFlag(inAlliance),
        scope: scopeRaw || 'next_event',
        isActiveNextEvent,
      };
    }

    function normalizeAbsenceRow(row) {
      const playerName = (row?.PlayerName ?? row?.playername ?? "").toString().trim();
      const from = (row?.From ?? row?.from ?? "").toString().trim();
      const to = (row?.To ?? row?.to ?? "").toString().trim();
      const reason = (row?.Reason ?? row?.reason ?? "").toString().trim();
      const activeFlag =
        row?.InAlliance ?? row?.inalliance ?? row?.Active ?? row?.active;
      const scopeRaw = (row?.Scope ?? row?.scope ?? '').toString().trim().toLowerCase();
      return {
        playerName,
        canon: canonicalNameJS(playerName),
        from,
        to,
        fromDate: parseDateOnly(from),
        toDate: parseDateOnly(to),
        reason,
        inAlliance: parseInAllianceFlag(activeFlag),
        scope: scopeRaw,
      };
    }

    function todayDateUTC() {
      const now = new Date();
      return new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    }

    function computeActiveAbsences(entries) {
      const today = todayDateUTC();
      const todayMs = today.getTime();
      return entries.filter(entry => {
        if (!entry.inAlliance) {
          return false; // Nur Spieler, die noch zur Allianz gehÃ¶ren, tauchen in der Ãœbersicht auf.
        }
        const scopeNext = (entry.scope || '').toString().trim().toLowerCase() === 'next_event';
        const openRange = !entry.fromDate && !entry.toDate;
        if (scopeNext || openRange) {
          return true;
        }
        if (entry.fromDate && entry.fromDate.getTime() > todayMs) {
          return false;
        }
        if (entry.toDate && entry.toDate.getTime() < todayMs) {
          return false;
        }
        return true;
      });
    }

    function formatAbsenceRange(entry) {
      const from = entry.from || "â€“";
      const to = entry.to || "â€“";
      if (!entry.from && !entry.to) return "â€“";
      return `${from} â€“ ${to}`;
    }

    function dedupeActiveAbsenceEntries(entries = []) {
      const byCanon = new Map();
      entries.forEach(entry => {
        if (!entry || typeof entry !== 'object') return;
        const isActive = Boolean(entry.is_absent_next_event || entry.isActiveNextEvent);
        if (!isActive) return;
        const canon = canonicalNameJS(entry.canonical || entry.canon || entry.display || entry.name || '');
        if (!canon) return;
        const display = entry.display || entry.name || entry.PlayerName || canon;
        const range = {
          from: entry.from ?? entry.From ?? '',
          to: entry.to ?? entry.To ?? '',
          reason: entry.reason ?? entry.Reason ?? '',
          scope: entry.scope ?? entry.Scope ?? '',
        };
        const existing = byCanon.get(canon);
        if (existing) {
          existing.ranges.push(range);
          if ((!existing.display || existing.display === canon) && display) {
            existing.display = display;
          }
          existing.in_alliance = existing.in_alliance || Boolean(entry.in_alliance || entry.InAlliance || entry.inAlliance);
        } else {
          byCanon.set(canon, {
            canonical: canon,
            display,
            active: true,
            ranges: [range],
            in_alliance: Boolean(entry.in_alliance || entry.InAlliance || entry.inAlliance),
          });
        }
      });
      return Array.from(byCanon.values()).sort((a, b) => {
        const left = (a.display || a.canonical || '').toString();
        const right = (b.display || b.canonical || '').toString();
        return left.localeCompare(right);
      });
    }

    function formatAggregatedRangeLabel(entry) {
      const ranges = Array.isArray(entry?.ranges) ? entry.ranges : [];
      if (!ranges.length) return 'Zeitraum offen';
      const formatted = ranges
        .map(r => formatAbsenceRange({ from: r?.from, to: r?.to }))
        .filter(Boolean);
      if (!formatted.length) return 'Zeitraum offen';
      const suffix = ranges.length > 1 ? ` (${ranges.length} ZeitrÃ¤ume)` : '';
      return `${formatted[0]}${suffix}`;
    }

    function extractAggregatedReason(entry) {
      const ranges = Array.isArray(entry?.ranges) ? entry.ranges : [];
      const reasons = ranges
        .map(r => (r?.reason || '').toString().trim())
        .filter(Boolean);
      if (reasons.length) return reasons[0];
      const fallback = (entry?.reason || '').toString().trim();
      return fallback || 'â€“';
    }

    function rosterBadgeFor(entry) {
      const meta = state.playersByCanon[entry.canon];
      if (!meta) return "";
      const parts = [];
      if (meta.group) parts.push(`Gruppe ${meta.group}`);
      if (meta.role) parts.push(meta.role);
      const text = parts.join(" Â· ");
      return text ? `<span class="absences-roster-badge">im Roster${text ? ` Â· ${escapeHtml(text)}` : ""}</span>` : "";
    }

    function updateAbsencesUI() {
      if (!absencesContainer) return;
      const { loading, error, active } = state.absences;
      if (loading) {
        absencesContainer.textContent = "Wird geladen â€¦";
        return;
      }
      if (error) {
        absencesContainer.innerHTML = `<p class="absences-error">Absenzen konnten nicht geladen werden (${escapeHtml(error.message || error)})</p>`;
        return;
      }
      if (!active.length) {
        absencesContainer.innerHTML = '<p class="absences-empty">Aktuell sind keine Absenzen erfasst.</p>';
        return;
      }
      const rows = active.map(entry => {
        const rosterMeta = state.playersByCanon[entry.canon];
        const label = rosterMeta?.display || entry.playerName || "Unbekannt";
        const badge = rosterBadgeFor(entry);
        const status = entry.isActiveNextEvent === false ? "geplant" : "aktiv";
        return `
          <tr>
            <td>${escapeHtml(label)}${badge}</td>
            <td>${escapeHtml(formatAbsenceRange(entry))}</td>
            <td>${entry.reason ? escapeHtml(entry.reason) : "â€“"}</td>
            <td>${escapeHtml(status)}</td>
          </tr>
        `;
      }).join("");
      absencesContainer.innerHTML = `
        <table>
          <thead>
            <tr><th>Spieler</th><th>Zeitraum</th><th>Grund</th><th>Status</th></tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;
    }

    function renderAbsenceDiagnostics(debugBlock, conflicts = []) {
      if (!absenceDiag) return;
      const hasDebug = debugBlock && typeof debugBlock === 'object';
      if (!hasDebug) {
        absenceDiag.style.display = 'none';
        absenceDiag.innerHTML = '';
        return;
      }

      const stats = (debugBlock.stats && typeof debugBlock.stats === 'object') ? debugBlock.stats : {};
      const rawCount = Number(
        stats.file_entries ?? stats.total_entries ??
        debugBlock.raw_count ?? debugBlock.rawCount ?? debugBlock.total_entries ?? 0
      );
      const activeCount = Number(
        stats.active_for_next_event ??
        debugBlock.active_for_next_event ?? debugBlock.activeEntries ?? debugBlock.active_entries ?? 0
      );
      const uniquePlayers = Number(
        stats.unique_active_players ??
        (Array.isArray(debugBlock.next_event_absences) ? debugBlock.next_event_absences.length : NaN)
      );
      const fileEntries = Array.isArray(debugBlock.file_entries)
        ? debugBlock.file_entries
        : (Array.isArray(debugBlock.players) ? debugBlock.players : []);
      const aggregatedEntries = Array.isArray(debugBlock.next_event_absences)
        ? debugBlock.next_event_absences
        : [];
      const source = (debugBlock.source || '').toString();
      const summaryParts = [];
      if (!Number.isNaN(rawCount)) summaryParts.push(`Datei-EintrÃ¤ge: ${rawCount}`);
      if (!Number.isNaN(activeCount)) summaryParts.push(`fÃ¼r nÃ¤chstes Event aktiv: ${activeCount}`);
      if (!Number.isNaN(uniquePlayers)) summaryParts.push(`aktive Spieler: ${uniquePlayers}`);
      if (source) summaryParts.push(`Quelle: ${escapeHtml(source)}`);

      let html = '<h4>Absenzen (nÃ¤chstes Event â€“ Ãœbersicht & Diagnostik)</h4>';
      html += `<p>${summaryParts.join(' Â· ')}</p>`;

      const activeEntries = aggregatedEntries.length ? aggregatedEntries : dedupeActiveAbsenceEntries(fileEntries);
      if (activeEntries.length) {
        const items = activeEntries.map(p => {
          const canon = canonicalNameJS(p?.canonical || p?.canon || '');
          const display = p?.display || canon || 'Unbekannt';
          const range = formatAggregatedRangeLabel(p);
          const reasonRaw = extractAggregatedReason(p);
          const reason = reasonRaw ? escapeHtml(reasonRaw) : 'â€“';
          const isActive = Boolean(p?.active ?? true);
          const statusLabel = isActive ? 'aktiv' : 'geplant';
          const badgeClass = isActive ? 'tag tag-abs-active' : 'tag tag-abs-planned';
          return `
            <li>
              <strong>${escapeHtml(display)}</strong> <span class="${badgeClass}">${statusLabel}</span><br />
              <span class="muted">${escapeHtml(range)} Â· Grund: ${reason}</span>
            </li>
          `;
        }).join('');
        html += `<ul class="absence-list">${items}</ul>`;
      } else {
        html += '<p class="muted">Keine aktiven Absenzen fÃ¼r das nÃ¤chste Event laut Builder.</p>';
      }

      const conflictsSafe = Array.isArray(conflicts) ? conflicts : [];
      if (conflictsSafe.length) {
        const items = conflictsSafe.map(c => {
          const canon = canonicalNameJS(c?.canonical || '');
          const label = c?.display || canon || 'Unbekannt';
          return `<li class="warn">${escapeHtml(label)} â€” hard commitment + Absenz</li>`;
        }).join('');
        html += `<p class="warn">Konflikte: Fixplatz & Absenzen</p><ul>${items}</ul>`;
      }

      absenceDiag.innerHTML = html;
      absenceDiag.style.display = 'block';
    }

    function fetchAbsences() {
      state.absenceDebug = null;
      state.absenceConflicts = [];
      renderAbsenceDiagnostics(null, []);
      state.absences.loading = true;
      state.absences.error = null;
      updateAbsencesUI();
      const absencesUrl = `https://raw.githubusercontent.com/its-h4k1/desert-storm-roster-optimizer/${branch}/data/absences.csv${cacheBuster}`;
      fetch(absencesUrl, { cache: "no-store" })
        .then(r => { if (!r.ok) throw new Error(r.status + " " + r.statusText); return r.text(); })
        .then(text => {
          const parsed = parseCsv(text);
          const normalized = parsed.map(normalizeAbsenceRow).filter(row => row.playerName);
          state.absences.entries = normalized;
          state.absences.active = computeActiveAbsences(normalized);
          state.absences.error = null;
        })
        .catch(err => {
          state.absences.entries = [];
          state.absences.active = [];
          state.absences.error = err;
        })
        .finally(() => {
          state.absences.loading = false;
          updateAbsencesUI();
        });
    }

    function applyAbsencesFromPayload(absencesBlock) {
      if (!absencesBlock || typeof absencesBlock !== 'object' || !Array.isArray(absencesBlock.players)) {
        return false;
      }
      const normalized = absencesBlock.players
        .map(normalizeAbsenceFromPayload)
        .filter(entry => entry.playerName);
      const activeFallback = computeActiveAbsences(normalized);
      const activeSet = new Set(activeFallback.map(item => item.canon));
      const active = normalized.filter(entry => {
        if (typeof entry.isActiveNextEvent === 'boolean') return entry.isActiveNextEvent;
        if (entry.scope === 'next_event') return true;
        return activeSet.has(entry.canon);
      });
      state.absences.entries = normalized;
      state.absences.active = active;
      state.absences.error = null;
      state.absences.loading = false;
      updateAbsencesUI();
      return true;
    }

    function extractSignupStats(meta) {
      const toNum = (value) => {
        const n = Number(value);
        return Number.isFinite(n) ? n : null;
      };
      if (!meta || typeof meta !== 'object') {
        return {
          source: '',
          totalEntries: null,
          hardTotal: null,
          hardApplied: null,
          hardInvalid: null,
          hardOverbooked: null,
          extraTotal: null,
          extraByGroup: null,
          missingHard: null,
          inRosterHard: null,
        };
      }
      return {
        source: meta.source || '',
        totalEntries: toNum(meta.rows_with_canon ?? meta.total_entries ?? meta.rows_with_playername ?? meta.raw_rows),
        hardTotal: toNum(meta.hard_commitments_total ?? meta.hard_commitments),
        hardApplied: toNum(meta.hard_commitments_applied),
        hardInvalid: toNum(meta.hard_commitments_invalid),
        hardOverbooked: toNum(meta.hard_commitments_overbooked),
        extraTotal: toNum(meta.extra_entries_total),
        extraByGroup: (meta.extra_entries_by_group && typeof meta.extra_entries_by_group === 'object') ? meta.extra_entries_by_group : null,
        missingHard: toNum(meta.hard_commitments_missing_from_roster),
        inRosterHard: toNum(meta.in_roster_hard_commitments),
      };
    }

    function renderExtraSignups(extraData, meta, diagnostics = {}) {
      if (!extraRoot) return;
      const groups = ['A','B'];
      const stats = extractSignupStats(meta);
      const extraCount = Number.isFinite(stats.extraTotal)
        ? Number(stats.extraTotal)
        : groups.reduce((sum, g) => sum + (Array.isArray(extraData[g]) ? extraData[g].length : 0), 0);
      const totalEntries = Number.isFinite(stats.totalEntries) ? stats.totalEntries : extraCount;
      const inRosterHard = Number.isFinite(stats.inRosterHard)
        ? stats.inRosterHard
        : (Number.isFinite(stats.hardApplied) ? stats.hardApplied : null);
      const summaryParts = [];
      if (Number.isFinite(totalEntries)) summaryParts.push(`${totalEntries} EintrÃ¤ge`);
      if (Number.isFinite(stats.hardTotal)) {
        const suffix = (inRosterHard != null) ? ` (${inRosterHard} im Roster)` : '';
        summaryParts.push(`${stats.hardTotal} verbindliche Zusagen${suffix}`);
      }
      if (!extraCount) summaryParts.push('keine zusÃ¤tzlichen Zusagen auÃŸerhalb des Rosters');
      const summaryText = summaryParts.length ? `Zusage-Pool (nÃ¤chstes Event): ${summaryParts.join(' Â· ')}` : '';
      if (signupInline) {
        signupInline.textContent = summaryText;
        signupInline.style.display = (!extraCount && summaryText) ? 'block' : 'none';
      }

      const hasDiagnostics = Boolean((diagnostics.forced || []).length || (diagnostics.invalid || []).length || (diagnostics.overbooked || []).length);
      const extrasSection = document.getElementById('extras');
      const shouldShowSection = extraCount > 0 || hasDiagnostics;
      if (!shouldShowSection) {
        if (extrasSection) extrasSection.style.display = 'none';
        extraRoot.innerHTML = '';
        if (extraNote) extraNote.textContent = '';
        return;
      }
      if (extrasSection) extrasSection.style.display = '';

      if (extraNote) {
        const parts = [];
        if (Number.isFinite(totalEntries)) parts.push(`Datei-EintrÃ¤ge: ${totalEntries}`);
        if (Number.isFinite(stats.hardTotal)) {
          const applied = (inRosterHard != null) ? ` (${inRosterHard} im Roster)` : '';
          parts.push(`verbindlich: ${stats.hardTotal}${applied}`);
        }
        if (Number.isFinite(extraCount) && extraCount > 0) parts.push(`auÃŸerhalb des Rosters: ${extraCount}`);
        if (stats.source) parts.push(`Quelle: ${stats.source}`);
        extraNote.textContent = parts.join(' Â· ') || 'Keine zusÃ¤tzlichen Zusagen erfasst.';
      }

      if (!extraCount) {
        extraRoot.innerHTML = '<p class="muted">Keine zusÃ¤tzlichen Zusagen auÃŸerhalb der Aufstellung.</p>';
        return;
      }

      extraRoot.innerHTML = '';
      groups.forEach(group => {
        const card = document.createElement('div');
        card.className = 'extra-card';
        const title = document.createElement('h3');
        title.textContent = `Gruppe ${group}`;
        card.appendChild(title);
        const list = document.createElement('ul');
        list.className = 'extra-list';
        const entries = Array.isArray(extraData[group]) ? extraData[group] : [];
        if (!entries.length) {
          const li = document.createElement('li');
          li.textContent = 'Keine Zusagen';
          list.appendChild(li);
        } else {
          entries.forEach(entry => {
            const li = document.createElement('li');
            const name = entry.player || entry.PlayerName || 'Unbekannt';
            const role = entry.role || entry.Role || '';
            const note = entry.note || entry.Note || '';
            const source = entry.source || entry.Source || '';
            const groupPref = entry.group || entry.Group || '';
            const metaParts = [];
            if (groupPref) metaParts.push(`Gruppe ${groupPref}`);
            if (role) metaParts.push(role);
            if (source) metaParts.push(source);
            const metaText = metaParts.length ? ` <span class="extra-meta">(${escapeHtml(metaParts.join(' Â· '))})</span>` : '';
            const noteText = note ? ` <span class="extra-meta">${escapeHtml(note)}</span>` : '';
            li.innerHTML = `${escapeHtml(name)}${metaText}${noteText}`;
            list.appendChild(li);
          });
        }
        card.appendChild(list);
        extraRoot.appendChild(card);
      });
    }

    function renderForcedDiagnostics(diag, meta) {
      const container = document.getElementById('forced-diagnostics');
      if (!container) return;
      const forced = Array.isArray(diag?.forced) ? diag.forced : [];
      const invalid = Array.isArray(diag?.invalid) ? diag.invalid : [];
      const overbooked = Array.isArray(diag?.overbooked) ? diag.overbooked : [];
      const stats = extractSignupStats(meta);

      const summaryParts = [];
      const hardTotal = Number.isFinite(stats.hardTotal) ? stats.hardTotal : null;
      const hardApplied = Number.isFinite(stats.hardApplied) ? stats.hardApplied : forced.length;
      const hardInvalid = Number.isFinite(stats.hardInvalid) ? stats.hardInvalid : invalid.length;
      const hardOverbooked = Number.isFinite(stats.hardOverbooked) ? stats.hardOverbooked : overbooked.length;
      if (Number.isFinite(stats.totalEntries)) summaryParts.push(`Datei-EintrÃ¤ge: ${stats.totalEntries}`);
      if (hardTotal != null) summaryParts.push(`davon verbindliche Zusagen: ${hardTotal}`);
      if (Number.isFinite(hardApplied)) summaryParts.push(`FixplÃ¤tze im Roster: ${hardApplied}`);
      if (Number.isFinite(hardInvalid) && hardInvalid > 0) summaryParts.push(`ignoriert: ${hardInvalid}`);
      if (Number.isFinite(hardOverbooked) && hardOverbooked > 0) summaryParts.push(`Ã¼ber KapazitÃ¤t: ${hardOverbooked}`);

      if (!forced.length && !invalid.length && !overbooked.length) {
        container.innerHTML = summaryParts.length
          ? `<p class="muted">${summaryParts.join(' Â· ')}</p>`
          : '<p class="muted">Keine verbindlichen Zusagen im Pool.</p>';
        return;
      }

      const parts = [];
      if (overbooked.length) {
        const items = overbooked
          .map(item => {
            const cap = Number.isFinite(item.capacity) ? Number(item.capacity) : null;
            const excess = Number.isFinite(item.excess_forced) ? Number(item.excess_forced) : null;
            const capText = cap != null ? `Slots: ${cap}` : 'Slots unbekannt';
            const excessText = excess != null ? `Ãœberbuchung: +${excess}` : 'Ãœberbuchung';
            return `<li class="warn">${escapeHtml(item.group || '?')}/${escapeHtml(item.role || '?')}: ${excessText} (${capText})</li>`;
          })
          .join('');
        parts.push(`<div><h4>Ãœberbuchungen</h4><ul>${items}</ul></div>`);
      }

      if (invalid.length) {
        const items = invalid
          .map(item => `<li>${escapeHtml(item.player || item.canon || '?')} â€” ${escapeHtml(item.reason || 'ungÃ¼ltig')}</li>`)
          .join('');
        parts.push(`<div><h4>Ignorierte harte Zusagen</h4><ul>${items}</ul></div>`);
      }

      if (forced.length) {
        const items = forced
          .map(item => {
            const over = item.overbooked ? ' Â· <span class="warn">(Ã¼ber KapazitÃ¤t)</span>' : '';
            return `<li>${escapeHtml(item.player || item.canon || '?')} â†’ ${escapeHtml(item.group || '?')}/${escapeHtml(item.role || '?')}${over}</li>`;
          })
          .join('');
        parts.push(`<div><h4>Verbindlich gesetzt</h4><ul>${items}</ul></div>`);
      }

      const summary = summaryParts.length ? `<p class="muted">${summaryParts.join(' Â· ')}</p>` : '';
      container.innerHTML = summary + parts.join('');
    }

    /**
     * Farb-Logik fÃ¼r No-Show-Badges (bisheriges Verhalten in Klartext):
     * 1. Keine Historie (events_seen=0 oder unbekannt) â†’ graue Badge ("nodata").
     * 2. Wer nie gefehlt hat, bleibt grÃ¼n, unabhÃ¤ngig von der Rate.
     * 3. low-n (â‰¤2 Teilnahmen) wird generell gelb eingeordnet, damit einzelne AusreiÃŸer
     *    nicht sofort rot erscheinen.
     * 4. Single-Miss-Spieler: ab 10 Events und Rate <12 % weiterhin grÃ¼n, sonst gelb.
     * 5. Alle anderen nutzen die Schwellwerte 20 % (grÃ¼nâ†’gelb) und 35 % (gelbâ†’rot).
     * 6. ZusÃ¤tzliche Feinjustierung: Bis 5 Events wird ein eigentlich rotes Rating
     *    auf gelb abgeschwÃ¤cht, um die geringe Stichprobe sichtbar zu machen.
     */
    function classifyNoShowBadge({ rate, eventsSeen, flags = {} }) {
      const { noData=false, neverMissed=false, lowN=false, singleMiss=false } = flags;

      if (noData) {
        return { level: "nodata", reason: "no-data" };
      }

      if (neverMissed) {
        return { level: "good", reason: "never-missed" };
      }

      if (lowN) {
        return { level: "warning", reason: "low-n" };
      }

      const value = (rate != null && Number.isFinite(rate)) ? rate : null;
      if (value == null) {
        return { level: "nodata", reason: "no-rate" };
      }

      if (singleMiss) {
        if ((eventsSeen ?? 0) >= SINGLE_MISS_GREEN_SEEN_MIN && value < SINGLE_MISS_GREEN_RATE_MAX) {
          return { level: "good", reason: "single-miss-soft-green" };
        }
        return { level: "warning", reason: "single-miss-soft-warning" };
      }

      let level;
      if (value < GREEN_TH) level = "good";
      else if (value < YELLOW_TH) level = "warning";
      else level = "bad";

      if (level === "bad" && eventsSeen != null && eventsSeen <= BADGE_SETTINGS.softenBadUntilSeen) {
        return { level: "warning", reason: "small-sample-soften" };
      }

      return { level, reason: "threshold" };
    }

    const BADGE_CLASS_BY_LEVEL = {
      nodata: "chip ns-neutral",
      neutral: "chip ns-neutral",
      good: "chip ns-ok",
      warning: "chip ns-mid",
      bad: "chip ns-bad",
    };

    function buildChipTooltip(p, rRolling, rOverall) {
      const seen   = (p && Number.isFinite(p.events_seen))  ? Number(p.events_seen)  : null;
      const miss   = (p && Number.isFinite(p.noshow_count)) ? Number(p.noshow_count) : null;
      const eb     = (p && p.eb && isFinite(p.eb.p_hat))    ? Number(p.eb.p_hat)     : null;
      const parts = [];
      parts.push(`n=${seen!=null?seen:"â€“"}`);
      parts.push(`misses=${miss!=null?miss:"â€“"}`);
      if (rRolling!=null && isFinite(rRolling)) parts.push(`rolling=${pc(rRolling)}`);
      if (rOverall!=null && isFinite(rOverall)) parts.push(`overall=${pc(rOverall)}`);
      if (eb!=null) parts.push(`ebâ‰ˆ${pc(eb)}`);
      return parts.join(" Â· ");
    }

    function formatDateDisplay(value) {
      const parsed = parseDateOnly(value);
      if (!parsed) return null;
      return `${pad(parsed.getUTCDate())}.${pad(parsed.getUTCMonth() + 1)}.${parsed.getUTCFullYear()}`;
    }

    function buildPlayerMetaText(meta) {
      const eventsSeen = Number.isFinite(meta.eventsSeen) ? Number(meta.eventsSeen) : (meta.eventsSeen === 0 ? 0 : null);
      const noshowCountOverall = Number.isFinite(meta.noshowCountOverall) ? Number(meta.noshowCountOverall) : null;
      const dataNote = meta.dataNote ? meta.dataNote : "";
      const callupReason = meta.callupReason ? meta.callupReason : "";
      const lastSeen = meta.lastSeenDate ? formatDateDisplay(meta.lastSeenDate) : null;
      const lastNoShow = meta.lastNoShowDate ? formatDateDisplay(meta.lastNoShowDate) : null;

      const parts = [];

      if (eventsSeen === 0) {
        parts.push("Events: 0 Â· keine Teilnahme bisher");
      } else if (eventsSeen != null) {
        parts.push(`Events: ${eventsSeen}`);
      } else {
        parts.push("Events: â€“");
      }

      if (noshowCountOverall != null) {
        parts.push(`No-Shows gesamt: ${noshowCountOverall}`);
      }

      if (lastSeen) {
        parts.push(`letzte Teilnahme: ${lastSeen}`);
      }

      if (lastNoShow) {
        parts.push(`letzte No-Show: ${lastNoShow}`);
      }

      if (dataNote) {
        parts.push(dataNote);
      }

      if (callupReason) {
        parts.push(`Callup: ${callupReason}`);
      }

      if (!parts.length) return "Keine zusÃ¤tzlichen Daten verfÃ¼gbar.";
      return parts.join(" Â· ");
    }

    const FORCED_SOURCE_LABELS = {
      manual: "Manuell",
      "callup-confirmed": "Callup",
    };

    function normalizeForcedSignup(raw) {
      if (!raw || typeof raw !== "object") return null;
      const commitment = (raw.commitment || raw.Commitment || "").toString().toLowerCase();
      if (commitment !== "hard") return null;
      const source = raw.source || raw.Source || "";
      const note = raw.note || raw.Note || "";
      const overbooked = Boolean(raw.overbooked || raw.Overbooked);
      return { commitment, source, note, overbooked };
    }

    function buildFixBadge(forcedSignup) {
      const normalized = normalizeForcedSignup(forcedSignup);
      if (!normalized) return "";
      const sourceLabel = normalized.source ? (FORCED_SOURCE_LABELS[normalized.source] || normalized.source) : "";
      const label = sourceLabel ? `verbindlich Â· ${sourceLabel}` : "verbindlich";
      const tooltipParts = ["Verbindliche Zusage aus event_signups_next.csv"];
      if (sourceLabel) tooltipParts.push(`Quelle: ${sourceLabel}`);
      if (normalized.overbooked) tooltipParts.push("Ã¼ber KapazitÃ¤t");
      return `<span class="tag tag-fix" title="${escapeHtml(tooltipParts.join(' Â· '))}">ðŸ”’ ${escapeHtml(label)}</span>`;
    }

    function writeBucketCounts(key, counts) {
      const h2 = document.querySelector(`#${key} h2`);
      if (!h2) return;
      const base = h2.getAttribute("data-label") || h2.textContent;
      h2.setAttribute("data-label", base);
      const fmt = (value, label) => `${(value==null || !Number.isFinite(value)) ? "â€“" : value} ${label}`;
      const suffix = ` â€” ${[fmt(counts.known, "bekannte"), fmt(counts.lown, "low-n"), fmt(counts.nd, "No-Data")].join(" Â· ")}`;
      h2.innerHTML = `${base}<span class="counts">${suffix}</span>`;
    }

    fetch(LATEST_JSON_URL, { cache: "no-store" })
      .then(r=>{ if(!r.ok) throw new Error(r.status+" "+r.statusText); return r.json(); })
      .then(payload => {
        const schema = (!Array.isArray(payload) && payload && typeof payload === "object") ? (payload.schema || {}) : {};
        const ebEnabled = Boolean(schema && schema.eb && schema.eb.enabled);

        // -------- payload -> rows (kompatibel zu alter Struktur) --------
        const toRows = (payload) => {
          if (Array.isArray(payload)) return payload; // alte Struktur weiterhin akzeptieren
          const playersByDisplay = Object.fromEntries((payload.players || []).map(p => [p.display, p]));
          const groups = payload.groups || {};
          const out = [];
          for (const G of ["A","B"]) {
            const g = groups[G] || {};
            for (const R of ["Start","Ersatz"]) {
              const list = (g[R] || []);
              list.forEach((name, idx) => {
                const p = playersByDisplay[name] || {};
                const eb = (p.eb && typeof p.eb === "object") ? {
                  p_hat: toNumber(p.eb.p_hat),
                  sigma: toNumber(p.eb.sigma),
                } : null;
                out.push({
                  Group: G,
                  Role: R,
                  Slot: idx + 1,
                  PlayerName: name,
                  NoShowOverall: toNumber(p.noshow_overall),
                  NoShowRolling: toNumber(p.noshow_rolling),
                  EB: eb,
                  EventsSeen: toNumber(p.events_seen),
                });
              });
            }
          }
          return out;
        };
        const rows = toRows(payload);

        const playersArray = (!Array.isArray(payload) && Array.isArray(payload.players)) ? payload.players : [];
        state.callupMeta = extractCallupMeta(payload, playersArray, schema);
        state.latestPayload = payload;
        state.playersArray = playersArray;
        state.callupCandidates = collectCallupCandidates(playersArray);
        // Datengrundlage (latest.json):
        // - forced_signups (Array) sowie players[].forced_signup markieren verbindliche Zusagen aus event_signups_next.csv
        //   inkl. commitment (hard), source (manual/callup-confirmed), note & overbooked-Flag.
        // - players[].event_signup + has_event_signup spiegeln die ursprÃ¼nglichen Event-Pool-EintrÃ¤ge.
        const playersMap = Object.fromEntries(
          playersArray
            .filter(p => p && typeof p === "object" && typeof p.display === "string")
            .map(p => {
              const normalizedCallup = normalizeCallup(p);
              const merged = { ...p };
              if (normalizedCallup) merged.callup = normalizedCallup;
              return [p.display, merged];
            })
        );
        const playersByCanon = {};
        playersArray.forEach(p => {
          if (!p || typeof p !== "object") return;
          const canonSource = typeof p.canon === "string" && p.canon.trim() ? p.canon : p.display;
          const canon = canonicalNameJS(canonSource || "");
          if (!canon) return;
          const normalizedCallup = normalizeCallup(p);
          playersByCanon[canon] = {
            display: p.display,
            group: p.group,
            role: p.role,
            has_event_signup: Boolean(p.has_event_signup || p.event_signup),
            event_signup: p.event_signup || null,
            has_forced_signup: Boolean(p.has_forced_signup || p.forced_signup),
            forced_signup: p.forced_signup || null,
            callup: normalizedCallup,
            callup_recommended: normalizedCallup ? Boolean(normalizedCallup.recommended) : Boolean(p.callup_recommended),
            is_absent_next_event: Boolean(p.is_absent_next_event),
          };
        });
        state.playersByCanon = playersByCanon;
        state.absenceDebug = payload.absence_debug || null;
        state.absenceConflicts = Array.isArray(payload.absence_conflicts) ? payload.absence_conflicts : [];
        renderAbsenceDiagnostics(state.absenceDebug, state.absenceConflicts);
        const absencesApplied = applyAbsencesFromPayload(payload.absences);
        if (!absencesApplied) {
          fetchAbsences();
        }
        const activeAbsenceSet = new Set([
          ...((state.absences.active || []).map(a => canonicalNameJS(a?.canon || a?.playerName || ''))),
          ...(playersArray
            .filter(p => p && p.is_absent_next_event)
            .map(p => canonicalNameJS(p.canon || p.display || ''))),
        ].filter(Boolean));
        const extraSignups = {
          A: (payload && payload.groups && Array.isArray(payload.groups.A?.extra_signups)) ? payload.groups.A.extra_signups : [],
          B: (payload && payload.groups && Array.isArray(payload.groups.B?.extra_signups)) ? payload.groups.B.extra_signups : [],
        };
        state.forcedDiagnostics = {
          forced: Array.isArray(payload.forced_signups) ? payload.forced_signups : [],
          invalid: Array.isArray(payload.invalid_forced_signups) ? payload.invalid_forced_signups : [],
          overbooked: Array.isArray(payload.overbooked_forced_signups) ? payload.overbooked_forced_signups : [],
        };
        const hasEventsSeen = playersArray.some(p => p && Object.prototype.hasOwnProperty.call(p, "events_seen"));

        const observedFromPlayers = playersArray
          .map(p => {
            if (!p || typeof p !== "object") return null;
            const seen = toNumber(p.events_seen);
            const hasData = (seen == null) || (seen > 0);
            if (p.eb && p.eb.p_hat != null && hasData) {
              const v = toNumber(p.eb.p_hat);
              if (v != null) return v;
            }
            if (p.noshow_rolling != null && hasData) {
              const v = toNumber(p.noshow_rolling);
              if (v != null) return v;
            }
            if (p.noshow_overall != null && hasData) {
              const v = toNumber(p.noshow_overall);
              if (v != null) return v;
            }
            return null;
          })
          .filter(v => v != null);

        // -------- Prior (fÃ¼r No-Data-Spieler) dynamisch bestimmen --------
        // SchÃ¤tze den Mittelwert der beobachteten Raten (EB bevorzugt, sonst rolling â†’ overall)
        let observed = observedFromPlayers;
        if (!observed.length) {
          observed = rows.map(r => {
            const seen = toNumber(r.EventsSeen);
            const hasData = (seen == null) || (seen > 0);
            if (r.EB && r.EB.p_hat != null && hasData) {
              const v = toNumber(r.EB.p_hat);
              if (v != null) return v;
            }
            if (r.NoShowRolling != null && hasData) {
              const v = toNumber(r.NoShowRolling);
              if (v != null) return v;
            }
            if (r.NoShowOverall != null && hasData) {
              const v = toNumber(r.NoShowOverall);
              if (v != null) return v;
            }
            return null;
          }).filter(v => v != null);
        }
        const avg = (arr)=> arr.reduce((a,b)=>a+b,0)/Math.max(1,arr.length);
        const fallbackPrior = (schema.prior && schema.prior.fallback != null && isFinite(schema.prior.fallback)) ? Number(schema.prior.fallback) : DEFAULT_PRIOR_FALLBACK;
        const priorPad = (schema.prior && schema.prior.pad != null && isFinite(schema.prior.pad)) ? Number(schema.prior.pad) : DEFAULT_PRIOR_PAD;
        const teamMeanSchema = (schema.prior && schema.prior.team_mean != null && isFinite(schema.prior.team_mean)) ? Number(schema.prior.team_mean) : null;
        const priorValueSchema = (schema.prior && schema.prior.value != null && isFinite(schema.prior.value)) ? Number(schema.prior.value) : null;
        const priorBase = observed.length ? avg(observed) : fallbackPrior;
        const teamMean = (teamMeanSchema != null) ? teamMeanSchema : priorBase;
        const PRIOR_NOSHOW = clamp(priorValueSchema != null ? priorValueSchema : (teamMean + priorPad));

        // -------- Effektive Rate je Spieler fÃ¼r Sortierung --------
        const effRate = (r) => {
          if (r.EB && r.EB.p_hat != null) {
            const v = toNumber(r.EB.p_hat);
            if (v != null) return clamp(v);
          }
          const rolling = toNumber(r.NoShowRolling);
          if (rolling != null) return clamp(rolling);
          const overall = toNumber(r.NoShowOverall);
          if (overall != null) return clamp(overall);
          return PRIOR_NOSHOW;
        };

        // Sort-Hinweis im UI
        document.getElementById("sort-note").textContent =
          `Sortierung: niedrigste Risiko-SchÃ¤tzung zuerst (PrimÃ¤r: ${ebEnabled ? "EB pÌ‚" : "rolling"}, Fallback: ${ebEnabled ? "rolling â†’ overall" : "overall"}, Prior â‰ˆ ${(PRIOR_NOSHOW*100).toFixed(1)}%).`;

        // -------- Buckets bilden --------
        const targets = ["A-Start","A-Ersatz","B-Start","B-Ersatz"];
        const buckets = Object.fromEntries(targets.map(k => [k, []]));
        rows.forEach(r=>{
          const canonRow = canonicalNameJS(r.PlayerName || '');
          if (canonRow && activeAbsenceSet.has(canonRow)) return;
          const key = `${r.Group}-${r.Role}`;
          if (buckets[key]) buckets[key].push(r);
        });

        // -------- Buckets nach No-Show (aufsteigend) sortieren --------
        for (const key of targets) {
          buckets[key].sort((a,b)=>{
            const da = effRate(a), db = effRate(b);
            if (Math.abs(da - db) > EPS) return da - db;              // 1) No-Show (ASC)
            const oaVal = (toNumber(a.NoShowOverall) != null) ? toNumber(a.NoShowOverall) : 1;
            const obVal = (toNumber(b.NoShowOverall) != null) ? toNumber(b.NoShowOverall) : 1;
            const oa = oaVal ?? 1;
            const ob = obVal ?? 1;
            if (Math.abs(oa - ob) > EPS) return oa - ob;              // 2) Overall (ASC) als Tiebreak
            return (a.PlayerName||"").localeCompare(b.PlayerName||""); // 3) Name
          });
        }

        // -------- Render --------
        for (const key of targets) {
          const tbody = document.querySelector(`#${key} tbody`);
          tbody.innerHTML = "";
          (buckets[key] || []).forEach((r, i) => {
            const histOverall = toNumber(r.NoShowOverall);
            const histRolling = toNumber(r.NoShowRolling);
            const p = playersMap[r.PlayerName] || {};

            const seenSource = Number.isFinite(p.events_seen) ? Number(p.events_seen) : null;
            const seenFallback = Object.prototype.hasOwnProperty.call(r, "EventsSeen") ? toNumber(r.EventsSeen) : null;
            const seen = (seenSource != null) ? seenSource : seenFallback;

            const missesSource = Number.isFinite(p.noshow_count) ? Number(p.noshow_count) : null;
            const missesFallback = Object.prototype.hasOwnProperty.call(r, "NoShowCount") ? toNumber(r.NoShowCount) : null;
            const misses = (missesSource != null) ? missesSource : missesFallback;

            const seenKnown = (p && Object.prototype.hasOwnProperty.call(p, "events_seen")) ||
              Object.prototype.hasOwnProperty.call(r, "EventsSeen");
            const annotate = seenKnown || hasEventsSeen;

            const participated = (seen != null && seen > 0);
            const noData = annotate ? !participated : false;
            const lowN = annotate ? (participated && seen <= BADGE_SETTINGS.lowNMax) : false;
            const neverMissed = annotate ? (participated && misses === 0) : false;
            const singleMiss = annotate ? (participated && misses === 1) : false;

            const historyBadge = noData
              ? '<span class="tag tag-nd" title="Keine Historie â€“ events_seen = 0">No&nbsp;Data</span>'
              : (lowN ? '<span class="tag tag-low" title="Wenig Historie â€“ events_seen âˆˆ {1,2}">low&nbsp;n</span>' : '');

            const histRate = (histRolling ?? histOverall);

            const tip = buildChipTooltip(p, histRolling, histOverall);

            const shownOverall = noData ? null : histOverall;
            const shownRolling = noData ? null : histRolling;
            const badge = classifyNoShowBadge({
              rate: histRate,
              eventsSeen: annotate ? seen : null,
              flags: { noData, neverMissed, lowN, singleMiss },
            });
            const chipKlass = BADGE_CLASS_BY_LEVEL[badge.level] || BADGE_CLASS_BY_LEVEL.nodata;
            const reasonHint = badge.reason ? ` Â· badge=${badge.reason}` : "";
            const tooltip = `${tip}${reasonHint}`.replace(/"/g, '&quot;');
            let nameHTML = `${r.PlayerName || ""}`;
            const normalizedCallup = normalizeCallup(p);
            const forcedBadge = p ? buildFixBadge(p.forced_signup || (p.has_forced_signup ? { commitment: 'hard', source: p.event_signup?.source } : null)) : '';
            const callupBadge = p ? buildCallupBadge(normalizedCallup) : '';
            if (historyBadge) nameHTML += ` ${historyBadge}`;
            if (forcedBadge) nameHTML += ` ${forcedBadge}`;
            if (callupBadge) nameHTML += ` ${callupBadge}`;
            if (p && (p.has_event_signup || p.event_signup)) {
              nameHTML += ' <span class="tag tag-event" title="Zusage im Event-Pool (nÃ¤chstes Event)">Event-Zusage</span>';
            }
            const noshowCountOverall = Number.isFinite(p.noshow_count_overall) ? Number(p.noshow_count_overall) :
              (Number.isFinite(p.noshow_count) ? Number(p.noshow_count) :
              (Object.prototype.hasOwnProperty.call(r, "NoShowCount") ? toNumber(r.NoShowCount) : null));
            const dataNote = noData
              ? "Datenlage: keine Historie"
              : (lowN ? "Datenlage: wenig Historie" : "");
            const callupReason = (normalizedCallup && normalizedCallup.recommended) ? formatCallupReasons(normalizedCallup) : "";
            const lastSeenValue = p ? (p.last_seen || p.LastSeenDate) : (r.LastSeenDate || null);
            const lastNoShowValue = p ? (p.last_noshow_date || p.LastNoShowDate) : (r.LastNoShowDate || null);
            const metaText = buildPlayerMetaText({
              eventsSeen: seen,
              noshowCountOverall,
              dataNote,
              callupReason,
              lastSeenDate: lastSeenValue,
              lastNoShowDate: lastNoShowValue,
            });
            const tr = document.createElement("tr");
            tr.innerHTML = `
              <td class="num">${pad(i+1)}</td>
              <td>
                <div class="player-name-row">${nameHTML}</div>
                <div class="player-meta-row">${metaText}</div>
              </td>
              <td><span class="${chipKlass}" title="${tooltip}">${pc(shownOverall)}</span></td>
              <td><span class="${chipKlass}" title="${tooltip}">${pc(shownRolling)}</span></td>
            `;
            tbody.appendChild(tr);
          });

          if (!window.__bucketCounts) window.__bucketCounts = {};
          const keyCounts = { known:0, lown:0, nd:0 };
          (buckets[key] || []).forEach(row => {
            const pp = playersMap[row.PlayerName] || {};
            const seenVal = Number.isFinite(pp.events_seen) ? Number(pp.events_seen) :
              (Object.prototype.hasOwnProperty.call(row, "EventsSeen") ? toNumber(row.EventsSeen) : null);
            if (!(seenVal > 0)) { keyCounts.nd++; return; }
            if (seenVal <= BADGE_SETTINGS.lowNMax) { keyCounts.lown++; return; }
            keyCounts.known++;
          });
          window.__bucketCounts[key] = keyCounts;
          writeBucketCounts(key, keyCounts);
        }

        const signupMeta = payload.signup_pool || payload.event_signups || null;
        const filteredExtraSignups = {
          A: (extraSignups.A || []).filter(item => {
            const canon = canonicalNameJS(item?.canon || item?.player || '');
            return !(canon && activeAbsenceSet.has(canon));
          }),
          B: (extraSignups.B || []).filter(item => {
            const canon = canonicalNameJS(item?.canon || item?.player || '');
            return !(canon && activeAbsenceSet.has(canon));
          }),
        };
        renderExtraSignups(filteredExtraSignups, signupMeta, state.forcedDiagnostics);
        renderForcedDiagnostics(state.forcedDiagnostics, signupMeta);
        updateCallupNote(state.callupMeta);
        updateCallupExportButton(state.callupMeta, state.callupCandidates);

        const ts = new Date().toISOString().replace('T',' ').slice(0,19) + " UTC";
        const schemaVersion = (schema && schema.version != null) ? ` Â· schema v${schema.version}` : "";
        document.getElementById("stamp").textContent = `Stand: ${ts}${schemaVersion}`;
      })
      .catch(err=>{
        document.body.insertAdjacentHTML("beforeend",
          `<p style="color:#b00">Fehler beim Laden von <code>latest.json</code>: ${String(err)}</p>`);
      });
  </script>
</body>
</html>
