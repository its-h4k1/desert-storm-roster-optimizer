<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>Roster Events verwalten</title>
  <link rel="stylesheet" href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator.min.css">
  <style>
    :root {
      color-scheme: light dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f6f7f9;
      color: #1a1c1f;
    }

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: white;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
      padding: 1rem 1.5rem;
      position: sticky;
      top: 0;
      z-index: 100;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: flex-end;
    }

    header h1 {
      flex-basis: 100%;
      margin: 0 0 0.5rem;
      font-size: 1.5rem;
    }

    main {
      flex: 1;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    fieldset {
      border: 1px solid rgba(0, 0, 0, 0.1);
      border-radius: 0.75rem;
      padding: 1rem;
      min-width: min(400px, 100%);
      background: white;
    }

    legend {
      font-weight: 600;
      padding: 0 0.5rem;
    }

    label {
      display: flex;
      flex-direction: column;
      font-size: 0.85rem;
      gap: 0.35rem;
    }

    input[type="text"],
    input[type="url"],
    input[type="password"],
    select {
      font: inherit;
      padding: 0.5rem 0.65rem;
      border-radius: 0.6rem;
      border: 1px solid rgba(0, 0, 0, 0.2);
      min-width: 12rem;
    }

    input[type="text"]:focus,
    input[type="url"]:focus,
    input[type="password"]:focus,
    select:focus {
      outline: 2px solid #0b63f6;
      outline-offset: 1px;
    }

    button {
      font: inherit;
      padding: 0.55rem 1.1rem;
      border-radius: 0.6rem;
      border: none;
      background: #0b63f6;
      color: white;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    button[disabled] {
      background: #adb5bd;
      cursor: not-allowed;
    }

    .secondary-button {
      background: #4b4f56;
    }

    .danger-button {
      background: #c62828;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .controls-row > * {
      flex: 1 1 200px;
    }

    .inline {
      flex-direction: row;
      align-items: center;
    }

    .inline label {
      flex: none;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .inline input[type="text"] {
      flex: none;
    }

    .dropzone {
      border: 2px dashed #0b63f6;
      border-radius: 0.75rem;
      padding: 1.5rem;
      background: rgba(11, 99, 246, 0.08);
      text-align: center;
      font-weight: 500;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .dropzone.dragover {
      border-color: #093a9b;
      background: rgba(9, 58, 155, 0.15);
    }

    .tabulator {
      border-radius: 0.75rem;
      border: 1px solid rgba(0, 0, 0, 0.15);
      background: white;
    }

    .tabulator .tabulator-header {
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .tabulator-row-invalid {
      background: rgba(198, 40, 40, 0.08);
    }

    .statusbar {
      display: flex;
      gap: 1rem;
      align-items: center;
      padding: 0.75rem 1rem;
      background: white;
      border-radius: 0.75rem;
      border: 1px solid rgba(0, 0, 0, 0.1);
      font-size: 0.9rem;
    }

    .statusbar span {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .status-ok {
      color: #256029;
    }

    .status-warn {
      color: #b8860b;
    }

    .status-error {
      color: #c62828;
    }

    .toast-container {
      position: fixed;
      right: 1rem;
      bottom: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      z-index: 200;
    }

    .toast {
      padding: 0.75rem 1rem;
      border-radius: 0.75rem;
      background: rgba(33, 37, 41, 0.9);
      color: white;
      min-width: 18rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      opacity: 0.95;
      transform: translateY(0);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .toast.fade-out {
      opacity: 0;
      transform: translateY(10px);
    }

    .hidden {
      display: none !important;
    }

    .duplicate-cell {
      background: rgba(198, 40, 40, 0.15);
    }

    .error-banner {
      background: rgba(198, 40, 40, 0.15);
      border: 1px solid rgba(198, 40, 40, 0.35);
      color: #5b1717;
      padding: 0.75rem 1rem;
      border-radius: 0.6rem;
    }

    .flex-gap {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .name-summary {
      background: white;
      border-radius: 0.75rem;
      border: 1px solid rgba(0, 0, 0, 0.1);
      padding: 0.75rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .name-summary-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      font-weight: 600;
    }

    .name-summary-pending,
    .name-summary-resolutions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      font-size: 0.85rem;
    }

    .name-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(198, 40, 40, 0.35);
      background: rgba(198, 40, 40, 0.12);
      color: #5b1717;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .name-chip::before {
      content: "⚠";
      font-size: 0.8rem;
    }

    .name-chip:hover {
      background: rgba(198, 40, 40, 0.2);
    }

    .name-summary-resolutions .resolution-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(11, 99, 246, 0.35);
      background: rgba(11, 99, 246, 0.08);
      color: #0b3a9b;
      font-size: 0.8rem;
    }

    .name-summary-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }

    .playername-known {
      background: rgba(37, 96, 41, 0.08);
    }

    .playername-alias {
      background: rgba(11, 99, 246, 0.08);
    }

    .playername-new-player {
      background: rgba(11, 99, 246, 0.12);
    }

    .playername-unresolved {
      background: rgba(198, 40, 40, 0.12);
    }

    .playername-cell {
      padding: 0.15rem 0.35rem;
      border-radius: 0.5rem;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }

    .playername-cell strong {
      font-weight: 600;
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.2rem 0.35rem;
      border-radius: 0.5rem;
      font-size: 0.8rem;
    }

    .status-known {
      background: rgba(37, 96, 41, 0.1);
      color: #256029;
    }

    .status-unknown {
      background: rgba(198, 40, 40, 0.1);
      color: #5b1717;
    }

    .status-neutral {
      background: rgba(108, 117, 125, 0.12);
      color: #4b4f56;
    }

    .name-status-cell {
      cursor: pointer;
    }

    .name-status-cell.name-status-known,
    .name-status-cell.name-status-alias,
    .name-status-cell.name-status-new-player {
      background: rgba(37, 96, 41, 0.1);
      color: #256029;
    }

    .name-status-cell.name-status-unresolved {
      background: rgba(198, 40, 40, 0.1);
      color: #5b1717;
    }

    .name-status-cell.name-status-empty {
      background: rgba(108, 117, 125, 0.12);
      color: #4b4f56;
    }

    .name-status-cell .name-status-label {
      font-weight: 600;
    }

    .name-status-note {
      font-size: 0.75rem;
      opacity: 0.8;
    }

    .name-status-cell.name-status-empty,
    .name-status-cell.status-neutral {
      cursor: default;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15, 18, 26, 0.55);
      backdrop-filter: blur(2px);
      z-index: 300;
    }

    .modal {
      position: fixed;
      inset: 50% auto auto 50%;
      transform: translate(-50%, -50%);
      width: min(520px, 92vw);
      max-height: 90vh;
      overflow-y: auto;
      background: white;
      border-radius: 0.9rem;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.25);
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      z-index: 400;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.1rem;
    }

    .modal-body {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      font-size: 0.9rem;
    }

    .modal-body label {
      font-size: 0.8rem;
      font-weight: 600;
    }

    .modal-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .modal hr {
      border: none;
      border-top: 1px solid rgba(0, 0, 0, 0.08);
      margin: 0.5rem 0;
    }

    .modal-note {
      font-size: 0.8rem;
      color: #4b4f56;
    }

    .modal-error {
      font-size: 0.8rem;
      color: #c62828;
    }

    .modal-suggestions {
      margin-top: 0.35rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .chip-button {
      border: 1px solid rgba(11, 99, 246, 0.35);
      background: rgba(11, 99, 246, 0.08);
      color: #0b3a9b;
      border-radius: 999px;
      padding: 0.2rem 0.75rem;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .chip-button:hover,
    .chip-button:focus-visible {
      background: rgba(11, 99, 246, 0.15);
      color: #093a9b;
    }
  </style>
</head>
<body>
  <header>
    <h1>Events hochladen (Tabellen-Editor)</h1>
    <div class="controls-row">
      <fieldset>
        <legend>Event</legend>
        <div class="flex-gap">
          <label>
            Event ID
            <input type="text" id="event-id" placeholder="DS-2024-05-01-A" autocomplete="off">
          </label>
          <button type="button" id="derive-event">aus Datei ableiten</button>
        </div>
        <small>Format: DS-YYYY-MM-DD-A/B</small>
      </fieldset>
      <fieldset>
        <legend>Import</legend>
        <div class="dropzone" id="dropzone">CSV hierher ziehen (Mehrfach möglich)</div>
        <button type="button" id="paste-btn" style="margin-top:0.5rem; width:100%">Aus Zwischenablage einfügen</button>
      </fieldset>
      <fieldset>
        <legend>Branch &amp; Commit</legend>
        <label>
          Ziel-Branch
          <select id="branch-select">
            <option value="main">main</option>
            <option value="ops/events">ops/events</option>
            <option value="__custom">Custom…</option>
          </select>
        </label>
        <label id="custom-branch-wrapper" class="hidden">
          Custom-Branch
          <input type="text" id="custom-branch" placeholder="feature/my-branch">
        </label>
        <label>
          Strategie
          <select id="strategy-select">
            <option value="replace">replace (überschreiben)</option>
            <option value="merge">merge (zusammenführen)</option>
            <option value="abort-if-exists">abort-if-exists</option>
          </select>
        </label>
      </fieldset>
      <fieldset>
        <legend>Worker</legend>
        <label>
          Worker URL
          <input type="url" id="worker-url" value="/write-file">
        </label>
        <label>
          Admin Key (X-Admin-Key)
          <input type="password" id="admin-key" placeholder="••••••">
        </label>
        <label class="inline">
          <input type="checkbox" id="remember-settings">
          <span>Einstellungen merken</span>
        </label>
      </fieldset>
    </div>
    <div class="controls-row">
      <button type="button" id="save-btn" disabled>Speichern</button>
      <button type="button" id="build-btn" class="secondary-button" disabled>Roster neu bauen</button>
      <button type="button" id="reset-btn" class="danger-button">Rückgängig</button>
      <div id="actions-links" style="display:flex; align-items:center; gap:0.75rem;"></div>
    </div>
  </header>
  <main>
    <div id="error-banner" class="error-banner hidden"></div>
    <div id="table"></div>
    <div class="statusbar">
      <span id="row-count">Zeilen: 0</span>
      <span id="duplicate-count" class="status-ok">Duplikate: 0</span>
      <span id="error-count" class="status-ok">Fehler: 0</span>
    </div>
    <div id="name-validation" class="name-summary hidden">
      <div class="name-summary-header">
        <span>Namensvalidierung</span>
        <span id="name-validation-status"></span>
      </div>
      <div id="name-validation-pending" class="name-summary-pending hidden"></div>
      <div id="name-validation-resolutions" class="name-summary-resolutions hidden"></div>
      <div id="name-validation-actions" class="name-summary-actions hidden">
        <button type="button" id="force-save-btn" class="secondary-button">Speichern trotz offener Namen</button>
      </div>
    </div>
  </main>
  <div class="toast-container" id="toast-container"></div>

  <div id="resolver-backdrop" class="modal-backdrop hidden"></div>
  <div id="resolver-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="resolver-title">
    <div class="modal-header">
      <h2 id="resolver-title">Unbekannter Spieler</h2>
      <button type="button" id="resolver-close" class="secondary-button">Schließen</button>
    </div>
    <div class="modal-body">
      <div>
        <div class="modal-note">Bitte ordne den Namen zu oder lege einen neuen Spieler an.</div>
      </div>
      <div>
        <label for="resolver-canonical">Alias einem bekannten Spieler zuordnen</label>
        <input type="text" id="resolver-canonical" list="resolver-canonical-list" placeholder="Bekannten Spieler suchen" autocomplete="off">
        <datalist id="resolver-canonical-list"></datalist>
        <div id="resolver-suggestions" class="modal-suggestions hidden"></div>
        <div class="modal-actions">
          <button type="button" id="resolver-alias-btn">Alias anlegen</button>
        </div>
      </div>
      <hr>
      <div>
        <label for="resolver-new-player">Neuen Spieler aufnehmen</label>
        <input type="text" id="resolver-new-player" autocomplete="off">
        <div class="modal-actions">
          <button type="button" id="resolver-new-player-btn" class="secondary-button">Neuen Spieler vormerken</button>
        </div>
      </div>
      <div class="modal-actions">
        <button type="button" id="resolver-reset" class="secondary-button">Zuordnung entfernen</button>
      </div>
      <div id="resolver-error" class="modal-error"></div>
    </div>
  </div>

  <script src="https://unpkg.com/dayjs@1.11.10/dayjs.min.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/tabulator-tables@5.5.2/dist/js/tabulator.min.js"></script>
  <script>
    const repoOwner = "its-h4k1";
    const repoName = "desert-storm-roster-optimizer";

    const elements = {
      eventId: document.getElementById("event-id"),
      deriveEvent: document.getElementById("derive-event"),
      dropzone: document.getElementById("dropzone"),
      pasteBtn: document.getElementById("paste-btn"),
      branchSelect: document.getElementById("branch-select"),
      customBranchWrapper: document.getElementById("custom-branch-wrapper"),
      customBranch: document.getElementById("custom-branch"),
      strategy: document.getElementById("strategy-select"),
      workerUrl: document.getElementById("worker-url"),
      adminKey: document.getElementById("admin-key"),
      remember: document.getElementById("remember-settings"),
      saveBtn: document.getElementById("save-btn"),
      buildBtn: document.getElementById("build-btn"),
      resetBtn: document.getElementById("reset-btn"),
      actionsLinks: document.getElementById("actions-links"),
      errorBanner: document.getElementById("error-banner"),
      rowCount: document.getElementById("row-count"),
      duplicateCount: document.getElementById("duplicate-count"),
      errorCount: document.getElementById("error-count"),
      toastContainer: document.getElementById("toast-container"),
      nameValidation: document.getElementById("name-validation"),
      nameValidationStatus: document.getElementById("name-validation-status"),
      nameValidationPending: document.getElementById("name-validation-pending"),
      nameValidationResolutions: document.getElementById("name-validation-resolutions"),
      nameValidationActions: document.getElementById("name-validation-actions"),
      forceSaveBtn: document.getElementById("force-save-btn"),
    };

    const resolverElements = {
      modal: document.getElementById("resolver-modal"),
      backdrop: document.getElementById("resolver-backdrop"),
      close: document.getElementById("resolver-close"),
      canonicalInput: document.getElementById("resolver-canonical"),
      canonicalList: document.getElementById("resolver-canonical-list"),
      aliasButton: document.getElementById("resolver-alias-btn"),
      newPlayerInput: document.getElementById("resolver-new-player"),
      newPlayerButton: document.getElementById("resolver-new-player-btn"),
      resetButton: document.getElementById("resolver-reset"),
      title: document.getElementById("resolver-title"),
      error: document.getElementById("resolver-error"),
    };

    const EVENT_ID_PATTERN = /^DS-\d{4}-\d{2}-\d{2}-[A-Z]$/;

    let originalData = [];
    let originalEventId = "";
    let duplicateSlots = new Set();
    let validationErrors = [];
    let lastBuildUrl = null;
    const playerDirectory = {
      canonicalByKey: new Map(),
      aliasToCanonical: new Map(),
      canonicalList: [],
    };
    const nameResolutions = new Map();

    function setNameResolution(key, value) {
      if (!key) return;
      nameResolutions.set(key, value);
      updateNameStatusCells();
    }

    function deleteNameResolution(key) {
      if (!key) return;
      if (nameResolutions.delete(key)) {
        updateNameStatusCells();
      }
    }
    let allowSaveOverride = false;
    let lastNameValidation = {
      total: 0,
      unresolved: [],
      aliasResolutions: [],
      newPlayers: [],
    };
    let activeResolveKey = null;
    let activeResolveName = "";

    const table = new Tabulator("#table", {
      height: "calc(100vh - 280px)",
      layout: "fitDataStretch",
      resizableColumns: true,
      placeholder: "Noch keine Daten. CSV importieren oder einfügen.",
      clipboard: true,
      history: true,
      columns: [
        {
          title: "Slot",
          field: "Slot",
          editor: "number",
          editorParams: { min: 1, max: 30, step: 1 },
          validator: ["required", customSlotValidator],
          formatter: duplicateSlotFormatter,
          headerSort: false,
        },
        {
          title: "Name-Status",
          field: "PlayerName",
          headerSort: false,
          width: 170,
          hozAlign: "left",
          formatter: playerNameStatusFormatter,
          cellClick: (e, cell) => {
            const name = cell.getRow().getData().PlayerName;
            const status = getNameStatus(name);
            if (status.status === "empty") return;
            if (status.status === "known" && !nameResolutions.has(normalizePlayerKey(name))) {
              return;
            }
            openNameResolver(name);
          },
        },
        {
          title: "PlayerName",
          field: "PlayerName",
          editor: "input",
          mutatorEdit: trimValue,
          headerSort: false,
          cellClick: (e, cell) => {
            const name = cell.getRow().getData().PlayerName;
            const status = getNameStatus(name);
            if (status.status === "empty") return;
            if (status.status === "known" && !nameResolutions.has(normalizePlayerKey(name))) {
              return;
            }
            openNameResolver(name);
          },
        },
        {
          title: "RoleAtRegistration",
          field: "RoleAtRegistration",
          editor: "select",
          editorParams: { values: { Start: "Start", Ersatz: "Ersatz" } },
          validator: ["required", roleValidator],
          headerSort: false,
        },
        {
          title: "Teilgenommen",
          field: "Teilgenommen",
          editor: "tickCross",
          editorParams: { tristate: false },
          mutator: boolToIntMutator,
          mutatorEdit: boolToIntMutator,
          formatter: "tickCross",
          formatterParams: { crossElement: "✘", tickElement: "✔" },
          validator: [participatedValidator],
          headerSort: false,
        },
        {
          title: "Punkte",
          field: "Punkte",
          editor: "number",
          editorParams: { min: 0, step: 1 },
          validator: [pointsValidator],
          headerSort: false,
        },
        {
          title: "Warnungen",
          field: "Warnungen",
          editor: "input",
          mutatorEdit: trimValue,
          headerSort: false,
        },
      ],
      rowFormatter: function(row) {
        const data = row.getData();
        if (!isRowValid(data)) {
          row.getElement().classList.add("tabulator-row-invalid");
        } else {
          row.getElement().classList.remove("tabulator-row-invalid");
        }
      },
      dataChanged: () => {
        allowSaveOverride = false;
        refreshValidationState();
      },
      cellEdited: () => {
        allowSaveOverride = false;
        refreshValidationState();
      },
    });

    function customSlotValidator(cell, value) {
      if (value === null || value === undefined || value === "") return false;
      const num = Number(value);
      return Number.isInteger(num) && num >= 1 && num <= 30;
    }

    function roleValidator(cell, value) {
      return value === "Start" || value === "Ersatz";
    }

    function participatedValidator(cell, value) {
      const normalized = normalizeTeilgenommen(value);
      return normalized === 0 || normalized === 1;
    }

    function pointsValidator(cell, value) {
      if (value === null || value === undefined || value === "") return true;
      const num = Number(value);
      return Number.isFinite(num) && num >= 0;
    }

    function duplicateSlotFormatter(cell, params) {
      const value = cell.getValue();
      const el = cell.getElement();
      const rowData = cell.getRow().getData();
      const role = (rowData.RoleAtRegistration || "").toString().trim();
      const slot = Number(value);
      const key = Number.isInteger(slot) && role ? `${slot}::${role}` : null;

      if (key && duplicateSlots.has(key)) {
        el.classList.add("duplicate-cell");
      } else {
        el.classList.remove("duplicate-cell");
      }
      return value;
    }

    function trimValue(value) {
      if (typeof value === "string") {
        return value.trim();
      }
      return value;
    }

    function boolToIntMutator(value) {
      return normalizeTeilgenommen(value);
    }

    function normalizeTeilgenommen(value) {
      if (value === true || value === "true") return 1;
      if (value === false || value === "false") return 0;
      if (value === "1" || value === 1) return 1;
      if (value === "0" || value === 0) return 0;
      return 0;
    }

    function normalizePlayerKey(name) {
      if (name === null || name === undefined) return "";
      return name
        .toString()
        .normalize("NFKC")
        .replace(/\s+/g, " ")
        .trim()
        .toLowerCase();
    }

    function similarity(a, b) {
      const keyA = normalizePlayerKey(a);
      const keyB = normalizePlayerKey(b);
      if (!keyA || !keyB) return 0;
      const maxPrefix = Math.min(keyA.length, keyB.length);
      let common = 0;
      while (common < maxPrefix && keyA[common] === keyB[common]) {
        common += 1;
      }
      return (2 * common) / (keyA.length + keyB.length);
    }

    function suggestCanonicalNames(unknownName, maxResults = 5, minScore = 0.4) {
      const source = (playerDirectory.canonicalList || []);
      const scored = source
        .map(name => ({ name, score: similarity(unknownName, name) }))
        .filter(item => item.score >= minScore && item.score > 0)
        .sort((a, b) => b.score - a.score)
        .slice(0, maxResults)
        .map(item => item.name);
      return scored;
    }

    function renderCanonicalSuggestions(suggestions) {
      const container = document.getElementById("resolver-suggestions");
      if (!container) return;
      container.innerHTML = "";
      if (!Array.isArray(suggestions) || !suggestions.length) {
        container.classList.add("hidden");
        return;
      }
      container.classList.remove("hidden");
      suggestions.forEach(name => {
        const button = document.createElement("button");
        button.type = "button";
        button.className = "chip-button";
        button.textContent = name;
        button.addEventListener("click", () => {
          resolverElements.canonicalInput.value = name;
          setResolverError("");
        });
        container.appendChild(button);
      });
    }

    function getNameStatus(name) {
      const trimmed = (name || "").toString().trim();
      if (!trimmed) {
        return { status: "empty" };
      }
      const key = normalizePlayerKey(trimmed);
      if (nameResolutions.has(key)) {
        const resolution = nameResolutions.get(key);
        if (resolution && typeof resolution === "object" && resolution.status === "alias-resolved") {
          const canonicalName = resolution.canonical || resolution.newPlayerName || trimmed;
          return {
            status: "alias-resolved",
            canonical: canonicalName,
            alias: trimmed,
            key,
          };
        }
        if (typeof resolution === "string") {
          return {
            status: "alias-resolved",
            canonical: resolution,
            alias: trimmed,
            key,
          };
        }
      }
      return getNameStatusByKey(key, trimmed);
    }

    function getNameStatusByKey(key, original) {
      if (!key) {
        return { status: "empty" };
      }
      if (nameResolutions.has(key)) {
        const resolution = nameResolutions.get(key);
        if (resolution && typeof resolution === "object") {
          if (resolution.status === "alias") {
            return {
              status: "alias",
              canonical: resolution.canonical,
              alias: resolution.alias,
              key,
            };
          }
          if (resolution.status === "new-player") {
            return {
              status: "new-player",
              canonical: resolution.newPlayerName,
              alias: resolution.alias,
              key,
            };
          }
          if (resolution.status === "alias-resolved") {
            return {
              status: "alias-resolved",
              canonical: resolution.canonical || resolution.newPlayerName || original,
              alias: original,
              key,
            };
          }
        }
        if (typeof resolution === "string") {
          return {
            status: "alias-resolved",
            canonical: resolution,
            alias: original,
            key,
          };
        }
      }
      if (playerDirectory.aliasToCanonical.has(key)) {
        return {
          status: "known",
          canonical: playerDirectory.aliasToCanonical.get(key),
          alias: original,
          key,
        };
      }
      return {
        status: "unresolved",
        alias: original,
        key,
      };
    }

    function playerNameStatusFormatter(cell) {
      const status = getNameStatus(cell.getValue());
      const statusKey = status.status || "empty";
      const wrapper = document.createElement("div");
      wrapper.className = `name-status-cell status-badge name-status-${statusKey}`;
      if (statusKey === "known" || statusKey === "alias" || statusKey === "new-player" || statusKey === "alias-resolved") {
        wrapper.classList.add("status-known");
      } else if (statusKey === "unresolved") {
        wrapper.classList.add("status-unknown");
      } else if (statusKey === "empty") {
        wrapper.classList.add("status-neutral");
      }
      if (statusKey === "empty") {
        wrapper.textContent = "–";
        wrapper.title = "Kein Name";
        return wrapper;
      }
      const label = document.createElement("span");
      label.className = "name-status-label";
      const note = document.createElement("span");
      note.className = "name-status-note";
      switch (statusKey) {
        case "known":
          label.textContent = "OK";
          if (status.canonical && status.canonical !== status.alias) {
            note.textContent = `→ ${status.canonical}`;
          } else {
            note.textContent = "bekannt";
          }
          wrapper.title = status.canonical ? `Bekannt als ${status.canonical}` : "Bekannter Spieler";
          break;
        case "alias-resolved":
          label.textContent = "OK";
          if (status.canonical && status.canonical !== status.alias) {
            note.textContent = `→ ${status.canonical}`;
          } else {
            note.textContent = "bekannt";
          }
          wrapper.title = status.canonical
            ? `Alias auf ${status.canonical} aufgelöst`
            : "Alias aufgelöst";
          break;
        case "alias":
          label.textContent = "Alias von";
          note.textContent = status.canonical || "";
          wrapper.title = `Alias wird als ${status.canonical} gespeichert`;
          break;
        case "new-player":
          label.textContent = "Neuer Spieler";
          note.textContent = status.canonical || "";
          wrapper.title = status.canonical ? `Neuer Spieler ${status.canonical}` : "Neuer Spieler";
          break;
        case "unresolved":
          label.textContent = "Unbekannt";
          note.textContent = "Klicken zum Zuordnen";
          wrapper.title = "Unbekannter Spieler – Zuordnung erforderlich";
          break;
        default:
          label.textContent = statusKey;
          note.textContent = "";
      }
      wrapper.appendChild(label);
      if (note.textContent) {
        wrapper.appendChild(note);
      }
      return wrapper;
    }

    function updatePlayerNameCells() {
      const playerColumns = table
        .getColumns()
        .filter(col => col.getDefinition().field === "PlayerName" && col.getDefinition().title === "PlayerName");
      playerColumns.forEach(column => {
        column.getCells().forEach(cell => {
          const status = getNameStatus(cell.getValue());
          const el = cell.getElement();
          el.classList.remove("playername-known", "playername-unresolved", "playername-alias", "playername-new-player");
          if (status.status === "known" || status.status === "alias-resolved") {
            el.classList.add("playername-known");
          } else if (status.status === "alias") {
            el.classList.add("playername-alias");
          } else if (status.status === "new-player") {
            el.classList.add("playername-new-player");
          } else if (status.status === "unresolved") {
            el.classList.add("playername-unresolved");
          }
          if (status.status === "alias") {
            el.title = `Alias von ${status.canonical}`;
          } else if (status.status === "known" && status.canonical && status.canonical !== cell.getValue()) {
            el.title = `Alias von ${status.canonical}`;
          } else if (status.status === "alias-resolved" && status.canonical && status.canonical !== cell.getValue()) {
            el.title = `Alias auf ${status.canonical} aufgelöst`;
          } else if (status.status === "new-player" && status.canonical) {
            el.title = `Neuer Spieler: ${status.canonical}`;
          } else {
            el.title = "";
          }
        });
      });
    }

    function updateNameStatusCells() {
      table.getColumns().forEach(column => {
        if (column.getDefinition().formatter === playerNameStatusFormatter) {
          column.getCells().forEach(cell => cell.render());
        }
      });
      updatePlayerNameCells();
    }

    function showToast(message, timeout = 4000) {
      const toast = document.createElement("div");
      toast.className = "toast";
      toast.textContent = message;
      elements.toastContainer.appendChild(toast);
      setTimeout(() => {
        toast.classList.add("fade-out");
        toast.addEventListener("transitionend", () => toast.remove(), { once: true });
      }, timeout);
    }

    function setErrorBanner(message) {
      if (message) {
        elements.errorBanner.textContent = message;
        elements.errorBanner.classList.remove("hidden");
      } else {
        elements.errorBanner.classList.add("hidden");
        elements.errorBanner.textContent = "";
      }
    }

    function getBranchValue() {
      const selection = elements.branchSelect.value;
      if (selection === "__custom") {
        return elements.customBranch.value.trim();
      }
      return selection;
    }

    function validateEventId(value) {
      if (!EVENT_ID_PATTERN.test(value || "")) {
        return false;
      }
      const [, year, month, day] = value.split("-");
      const parsed = dayjs(`${year}-${month}-${day}`);
      return parsed.isValid() && parsed.format("YYYY") === year && parsed.format("MM") === month && parsed.format("DD") === day;
    }

    function isRowValid(row) {
      const slotValid = Number.isInteger(Number(row.Slot)) && Number(row.Slot) >= 1 && Number(row.Slot) <= 30;
      const roleValid = row.RoleAtRegistration === "Start" || row.RoleAtRegistration === "Ersatz";
      const teil = normalizeTeilgenommen(row.Teilgenommen);
      const teilValid = teil === 0 || teil === 1;
      const points = Number(row.Punkte);
      const pointsValid = row.Punkte === "" || (Number.isFinite(points) && points >= 0);
      return slotValid && roleValid && teilValid && pointsValid;
    }

    function refreshValidationState() {
      const data = table.getData().map(normalizeRow);
      duplicateSlots = calculateDuplicateSlots(data);
      validationErrors = collectValidationErrors(data);

      table.getColumns().forEach(col => col.getCells().forEach(cell => {
        if (cell.getField() === "Slot") {
          duplicateSlotFormatter(cell);
        }
      }));

      const eventId = elements.eventId.value.trim();
      const eventIdValid = validateEventId(eventId);
      if (!eventIdValid) {
        validationErrors.push({ type: "event", message: "Event ID ungültig (DS-YYYY-MM-DD-A/B)" });
      }

      const branch = getBranchValue();
      if (!branch) {
        validationErrors.push({ type: "branch", message: "Branch darf nicht leer sein" });
      }

      const workerUrl = elements.workerUrl.value.trim();
      if (!workerUrl) {
        validationErrors.push({ type: "worker", message: "Worker URL darf nicht leer sein" });
      }

      lastNameValidation = collectNameValidationState(data);
      if (lastNameValidation.unresolved.length) {
        const unresolvedType = allowSaveOverride ? "warning" : "names";
        validationErrors.push({ type: unresolvedType, message: `Namensvalidierung: ${lastNameValidation.unresolved.length} offen` });
      }

      updateStatusBar(data, eventIdValid);
      updateNameSummary(lastNameValidation);
      updateNameStatusCells();

      if (lastNameValidation.unresolved.length === 0) {
        allowSaveOverride = false;
      }

      if (validationErrors.length) {
        const critical = validationErrors.filter(isCriticalError);
        if (critical.length) {
          setErrorBanner(critical.map(v => v.message).join(" · "));
        } else {
          setErrorBanner("");
        }
      } else {
        setErrorBanner("");
      }

      const hasHardRowErrors = validationErrors.some(v => v.type === "row");
      const hasBranchError = validationErrors.some(v => v.type === "branch");
      const hasWorkerError = validationErrors.some(v => v.type === "worker");
      const unresolvedBlocked = lastNameValidation.unresolved.length > 0 && !allowSaveOverride;
      const canSaveState = canSave({
        rowCount: data.length,
        hasHardRowErrors,
        hasBranchError,
        hasWorkerError,
        unresolvedBlocked,
      });
      elements.saveBtn.disabled = !canSaveState;
      elements.buildBtn.disabled = !canSaveState;
    }

    function calculateDuplicateSlots(rows) {
      const counts = new Map();
      rows.forEach(row => {
        const slot = Number(row.Slot);
        const role = (row.RoleAtRegistration || "").toString().trim();
        if (Number.isInteger(slot) && role) {
          const key = `${slot}::${role}`;
          counts.set(key, (counts.get(key) || 0) + 1);
        }
      });
      const duplicates = new Set();
      counts.forEach((count, key) => {
        if (count > 1) {
          duplicates.add(key);
        }
      });
      return duplicates;
    }

    function collectValidationErrors(rows) {
      const errors = [];
      rows.forEach((row, index) => {
        const rowNum = index + 1;
        const slot = Number(row.Slot);
        if (!Number.isInteger(slot) || slot < 1 || slot > 30) {
          errors.push({ type: "row", message: `Zeile ${rowNum}: Slot muss 1-30 sein` });
        }
        if (!(row.RoleAtRegistration === "Start" || row.RoleAtRegistration === "Ersatz")) {
          errors.push({ type: "row", message: `Zeile ${rowNum}: Role muss Start oder Ersatz sein` });
        }
        const teil = normalizeTeilgenommen(row.Teilgenommen);
        if (!(teil === 0 || teil === 1)) {
          errors.push({ type: "row", message: `Zeile ${rowNum}: Teilgenommen muss 0 oder 1 sein` });
        }
        const points = Number(row.Punkte);
        if (row.Punkte !== "" && (!Number.isFinite(points) || points < 0)) {
          errors.push({ type: "row", message: `Zeile ${rowNum}: Punkte muss >= 0 sein` });
        }
      });

      if (duplicateSlots.size) {
        const duplicateSlotNumbers = new Set();
        duplicateSlots.forEach(key => {
          const [slotStr] = key.split("::");
          const num = Number(slotStr);
          if (Number.isInteger(num)) {
            duplicateSlotNumbers.add(num);
          }
        });
        if (duplicateSlotNumbers.size) {
          const sorted = Array.from(duplicateSlotNumbers).sort((a, b) => a - b);
          errors.push({
            type: "row",
            message: `Slots doppelt vergeben (innerhalb gleicher Rolle): ${sorted.join(", ")}`
          });
        }
      }

      return errors;
    }

    function updateStatusBar(data, eventIdValid) {
      elements.rowCount.textContent = `Zeilen: ${data.length}`;

      let duplicateSlotNumbers = new Set();
      if (duplicateSlots.size) {
        duplicateSlots.forEach(key => {
          const [slotStr] = key.split("::");
          const num = Number(slotStr);
          if (Number.isInteger(num)) {
            duplicateSlotNumbers.add(num);
          }
        });
      }

      if (duplicateSlotNumbers.size) {
        elements.duplicateCount.textContent = `Duplikate: ${duplicateSlotNumbers.size}`;
        elements.duplicateCount.className = "status-error";
      } else {
        elements.duplicateCount.textContent = "Duplikate: 0";
        elements.duplicateCount.className = "status-ok";
      }

      const criticalErrors = validationErrors.filter(isCriticalError);
      elements.errorCount.textContent = `Fehler: ${criticalErrors.length}`;
      elements.errorCount.className = criticalErrors.length ? "status-error" : (eventIdValid ? "status-ok" : "status-error");
    }

    function isCriticalError(entry) {
      return entry && entry.type !== "warning";
    }

    function canSave(state) {
      if (!state) return false;
      if (!state.rowCount) return false;
      if (state.hasHardRowErrors) return false;
      if (state.hasBranchError) return false;
      if (state.hasWorkerError) return false;
      if (state.unresolvedBlocked) return false;
      return true;
    }

    function normalizeRow(row) {
      let pointsValue = row.Punkte;
      if (pointsValue === "" || pointsValue === null || pointsValue === undefined) {
        pointsValue = 0;
      }
      const pointsNumber = Number(pointsValue);
      const normalizedPoints = Number.isFinite(pointsNumber) && pointsNumber >= 0 ? pointsNumber : pointsValue;
      return {
        EventID: (row.EventID || elements.eventId.value || "").toString().trim(),
        Slot: row.Slot === "" || row.Slot === null || row.Slot === undefined ? "" : Number(row.Slot),
        PlayerName: (row.PlayerName || "").toString().trim(),
        RoleAtRegistration: (row.RoleAtRegistration || "").toString().trim(),
        Teilgenommen: normalizeTeilgenommen(row.Teilgenommen),
        Punkte: normalizedPoints,
        Warnungen: (row.Warnungen || "").toString().trim(),
      };
    }

    function setTableData(rows) {
      table.setData(rows.map(normalizeRow));
      allowSaveOverride = false;
      refreshValidationState();
    }

    function getTableData() {
      return table.getData().map(normalizeRow);
    }

    function parseCsv(text) {
      return new Promise((resolve, reject) => {
        Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          transformHeader: header => normalizeHeader(header),
          complete: results => resolve(results.data),
          error: err => reject(err),
        });
      });
    }

    function normalizeHeader(header) {
      if (!header) return header;
      const h = header.toLowerCase().replace(/[^a-z0-9]/g, "");
      switch (h) {
        case "eventid":
          return "EventID";
        case "slot":
          return "Slot";
        case "playername":
          return "PlayerName";
        case "roleatregistration":
        case "role":
          return "RoleAtRegistration";
        case "teilgenommen":
        case "participated":
          return "Teilgenommen";
        case "punkte":
        case "points":
          return "Punkte";
        case "warnungen":
        case "warnings":
          return "Warnungen";
        default:
          return header;
      }
    }

    async function fetchFirstAvailable(urls) {
      for (const url of urls) {
        try {
          const response = await fetch(url, { cache: "no-store" });
          if (response.ok) {
            return await response.text();
          }
        } catch (err) {
          console.warn("Fallback-Ladevorgang fehlgeschlagen", url, err);
        }
      }
      throw new Error(`Keine der Quellen erreichbar (${urls.join(", ")})`);
    }

    async function loadTextFromBranch(branch, path) {
      const url = `https://raw.githubusercontent.com/${repoOwner}/${repoName}/${encodeURIComponent(branch)}/${path}`;
      try {
        const response = await fetch(url, { cache: "no-store" });
        if (!response.ok) {
          if (response.status === 404) {
            return null;
          }
          throw new Error(`Fetch ${response.status} für ${path}`);
        }
        return await response.text();
      } catch (err) {
        console.warn("Fetch branch file fehlgeschlagen", url, err);
        throw err;
      }
    }

    async function loadPlayerDirectory() {
      const basePaths = ["../../data", "../data", "./data", "data"];
      const alliancePaths = basePaths.map(base => `${base.replace(/\/$/, "")}/alliance.csv`);
      const aliasesPaths = basePaths.map(base => `${base.replace(/\/$/, "")}/aliases.csv`);
      const rawAlliance = `https://raw.githubusercontent.com/${repoOwner}/${repoName}/main/data/alliance.csv`;
      const rawAliases = `https://raw.githubusercontent.com/${repoOwner}/${repoName}/main/data/aliases.csv`;
      alliancePaths.push(rawAlliance);
      aliasesPaths.push(rawAliases);
      try {
        const allianceText = await fetchFirstAvailable(alliancePaths);
        let aliasesText = "Canonical,Alias\n";
        try {
          aliasesText = await fetchFirstAvailable(aliasesPaths);
        } catch (err) {
          console.warn("Aliases nicht gefunden, starte mit leerer Liste", err);
        }

        const canonicalMap = new Map();
        const aliasMap = new Map();

        const allianceParsed = Papa.parse(allianceText, { header: true, skipEmptyLines: true });
        allianceParsed.data.forEach(row => {
          const name = (row.PlayerName || row.Canonical || "").toString().trim();
          if (!name) return;
          const key = normalizePlayerKey(name);
          if (!key) return;
          canonicalMap.set(key, name);
          aliasMap.set(key, name);
        });

        const aliasesParsed = Papa.parse(aliasesText, { header: true, skipEmptyLines: true });
        aliasesParsed.data.forEach(row => {
          const canonical = (row.Canonical || row.PlayerName || "").toString().trim();
          const alias = (row.Alias || row.Name || "").toString().trim();
          if (!canonical || !alias) return;
          const canonicalKey = normalizePlayerKey(canonical);
          const aliasKey = normalizePlayerKey(alias);
          if (!aliasKey) return;
          if (!canonicalMap.has(canonicalKey)) {
            canonicalMap.set(canonicalKey, canonical);
          }
          const canonicalValue = canonicalMap.get(canonicalKey) || canonical;
          aliasMap.set(aliasKey, canonicalValue);
        });

        playerDirectory.canonicalByKey.clear();
        playerDirectory.aliasToCanonical.clear();

        canonicalMap.forEach((value, key) => {
          playerDirectory.canonicalByKey.set(key, value);
        });
        aliasMap.forEach((value, key) => {
          playerDirectory.aliasToCanonical.set(key, value);
        });

        playerDirectory.canonicalList = Array.from(new Set(canonicalMap.values())).sort((a, b) =>
          a.localeCompare(b, "de", { sensitivity: "base" })
        );

        renderCanonicalOptions();
      } catch (err) {
        console.error("Spieler-Verzeichnis konnte nicht geladen werden", err);
        showToast("Warnung: Spieler-Verzeichnis konnte nicht geladen werden.");
      }
    }

    function renderCanonicalOptions() {
      if (!resolverElements.canonicalList) return;
      resolverElements.canonicalList.innerHTML = "";
      playerDirectory.canonicalList.forEach(name => {
        const option = document.createElement("option");
        option.value = name;
        resolverElements.canonicalList.appendChild(option);
      });
    }

    function collectNameValidationState(rows) {
      const seen = new Map();
      rows.forEach(row => {
        const rawName = (row.PlayerName || "").toString().trim();
        if (!rawName) return;
        const key = normalizePlayerKey(rawName);
        if (!key) return;
        if (!seen.has(key)) {
          seen.set(key, rawName);
        }
      });

      const validKeys = new Set(seen.keys());
      Array.from(nameResolutions.keys()).forEach(key => {
        if (!validKeys.has(key)) {
          deleteNameResolution(key);
        }
      });

      const unresolved = [];
      const aliasResolutions = [];
      const newPlayers = [];
      seen.forEach((displayName, key) => {
        const status = getNameStatusByKey(key, displayName);
        if (status.status === "unresolved") {
          unresolved.push({ name: displayName, key });
        } else if (status.status === "alias") {
          aliasResolutions.push({ name: displayName, canonical: status.canonical, key });
        } else if (status.status === "new-player") {
          newPlayers.push({ name: displayName, canonical: status.canonical, key });
        }
      });

      return {
        total: seen.size,
        unresolved,
        aliasResolutions,
        newPlayers,
      };
    }

    function updateNameSummary(state) {
      if (!state.total) {
        elements.nameValidation.classList.add("hidden");
        elements.nameValidationStatus.textContent = "";
        elements.nameValidationPending.classList.add("hidden");
        elements.nameValidationResolutions.classList.add("hidden");
        elements.nameValidationActions.classList.add("hidden");
        return;
      }

      elements.nameValidation.classList.remove("hidden");

      if (state.unresolved.length) {
        let statusText = `${state.unresolved.length} Namen ohne Zuordnung`;
        if (allowSaveOverride) {
          statusText += ` · Override aktiv – ${state.unresolved.length} offene Namen werden beim Speichern ignoriert.`;
        }
        elements.nameValidationStatus.textContent = statusText;
      } else {
        const summaryParts = [];
        if (state.aliasResolutions.length) summaryParts.push(`${state.aliasResolutions.length} neue Aliase`);
        if (state.newPlayers.length) summaryParts.push(`${state.newPlayers.length} neue Spieler`);
        elements.nameValidationStatus.textContent = summaryParts.length
          ? summaryParts.join(" · ")
          : "Alle Namen geprüft ✓";
      }

      elements.nameValidationPending.innerHTML = "";
      if (state.unresolved.length) {
        elements.nameValidationPending.classList.remove("hidden");
        state.unresolved.forEach(item => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "name-chip";
          button.dataset.name = item.name;
          button.textContent = item.name;
          elements.nameValidationPending.appendChild(button);
        });
      } else {
        elements.nameValidationPending.classList.add("hidden");
      }

      elements.nameValidationResolutions.innerHTML = "";
      const resolutionEntries = [];
      state.aliasResolutions.forEach(item => {
        const pill = document.createElement("span");
        pill.className = "resolution-pill";
        pill.textContent = `Alias: ${item.name} → ${item.canonical}`;
        resolutionEntries.push(pill);
      });
      state.newPlayers.forEach(item => {
        const pill = document.createElement("span");
        pill.className = "resolution-pill";
        pill.textContent = `Neuer Spieler: ${item.canonical}`;
        resolutionEntries.push(pill);
      });
      if (resolutionEntries.length) {
        elements.nameValidationResolutions.classList.remove("hidden");
        resolutionEntries.forEach(node => elements.nameValidationResolutions.appendChild(node));
      } else {
        elements.nameValidationResolutions.classList.add("hidden");
      }

      if (state.unresolved.length) {
        elements.nameValidationActions.classList.remove("hidden");
        elements.forceSaveBtn.classList.remove("hidden");
        elements.forceSaveBtn.disabled = allowSaveOverride;
        elements.forceSaveBtn.textContent = allowSaveOverride
          ? "Override aktiv"
          : `Speichern trotz offener Namen (${state.unresolved.length})`;
      } else {
        elements.nameValidationActions.classList.add("hidden");
        elements.forceSaveBtn.classList.add("hidden");
        elements.forceSaveBtn.disabled = false;
        elements.forceSaveBtn.textContent = "Speichern trotz offener Namen";
      }
    }

    function setResolverError(message) {
      if (!resolverElements.error) return;
      resolverElements.error.textContent = message || "";
    }

    function closeNameResolver() {
      resolverElements.modal.classList.add("hidden");
      resolverElements.backdrop.classList.add("hidden");
      setResolverError("");
      renderCanonicalSuggestions([]);
      activeResolveKey = null;
      activeResolveName = "";
    }

    function openNameResolver(name) {
      const trimmed = (name || "").toString().trim();
      if (!trimmed) return;
      activeResolveName = trimmed;
      activeResolveKey = normalizePlayerKey(trimmed);
      resolverElements.title.textContent = `Spieler „${trimmed}“ zuordnen`;
      setResolverError("");
      resolverElements.canonicalInput.value = "";
      resolverElements.newPlayerInput.value = trimmed;
      const status = getNameStatus(trimmed);
      if (status.status === "alias") {
        resolverElements.canonicalInput.value = status.canonical || "";
      } else if (status.status === "new-player") {
        resolverElements.newPlayerInput.value = status.canonical || trimmed;
      } else if (status.status === "known") {
        resolverElements.canonicalInput.value = status.canonical || trimmed;
      }
      const shouldSuggest = !(status.status === "known" && !nameResolutions.has(activeResolveKey));
      const suggestions = shouldSuggest ? suggestCanonicalNames(trimmed) : [];
      renderCanonicalSuggestions(suggestions);
      resolverElements.backdrop.classList.remove("hidden");
      resolverElements.modal.classList.remove("hidden");
      setTimeout(() => resolverElements.canonicalInput.focus(), 50);
    }

    function resolveAliasFromModal() {
      if (!activeResolveKey) return;
      const canonicalInput = resolverElements.canonicalInput.value.trim();
      if (!canonicalInput) {
        setResolverError("Bitte bekannten Spieler auswählen.");
        resolverElements.canonicalInput.focus();
        return;
      }
      const canonicalKey = normalizePlayerKey(canonicalInput);
      if (!canonicalKey) {
        setResolverError("Ungültige Eingabe.");
        return;
      }
      let canonicalName = playerDirectory.canonicalByKey.get(canonicalKey);
      if (!canonicalName) {
        const matchingNew = Array.from(nameResolutions.values()).find(value =>
          value.status === "new-player" && normalizePlayerKey(value.newPlayerName) === canonicalKey
        );
        if (matchingNew) {
          canonicalName = matchingNew.newPlayerName;
        }
      }
      if (!canonicalName) {
        setResolverError("Spieler nicht gefunden. Schreibweise prüfen.");
        return;
      }
      if (canonicalKey === activeResolveKey) {
        deleteNameResolution(activeResolveKey);
      } else {
        setNameResolution(activeResolveKey, {
          status: "alias",
          alias: activeResolveName,
          canonical: canonicalName,
        });
      }
      closeNameResolver();
      allowSaveOverride = false;
      refreshValidationState();
    }

    function resolveNewPlayerFromModal() {
      if (!activeResolveKey) return;
      const newPlayerName = resolverElements.newPlayerInput.value.trim();
      if (!newPlayerName) {
        setResolverError("Bitte Namen für den neuen Spieler eingeben.");
        resolverElements.newPlayerInput.focus();
        return;
      }
      const newKey = normalizePlayerKey(newPlayerName);
      if (!newKey) {
        setResolverError("Ungültiger Name.");
        return;
      }
      if (playerDirectory.aliasToCanonical.has(newKey)) {
        const existing = playerDirectory.aliasToCanonical.get(newKey);
        setResolverError(`Name bereits vergeben (${existing}).`);
        return;
      }
      setNameResolution(activeResolveKey, {
        status: "new-player",
        alias: activeResolveName,
        newPlayerName,
      });
      closeNameResolver();
      allowSaveOverride = false;
      refreshValidationState();
    }

    function resetNameResolutionFromModal() {
      if (!activeResolveKey) {
        closeNameResolver();
        return;
      }
      deleteNameResolution(activeResolveKey);
      closeNameResolver();
      allowSaveOverride = false;
      refreshValidationState();
    }

    async function importFiles(files) {
      if (!files.length) return;
      const rows = [];
      for (const file of files) {
        try {
          const text = await file.text();
          const parsed = await parseCsv(text);
          rows.push(...parsed);
          if (!elements.eventId.value && file.name) {
            const match = file.name.match(/(DS-\d{4}-\d{2}-\d{2}-[A-Z])/i);
            if (match) {
              elements.eventId.value = match[1].toUpperCase();
            }
          }
        } catch (err) {
          console.error(err);
          showToast(`Fehler beim Import von ${file.name}: ${err.message}`);
        }
      }
      if (rows.length) {
        setTableData(rows);
        showToast(`${rows.length} Zeilen importiert.`);
      } else {
        showToast("Keine Daten gefunden.");
      }
    }

    async function importClipboard() {
      try {
        const text = await navigator.clipboard.readText();
        if (!text) {
          showToast("Zwischenablage ist leer.");
          return;
        }
        const parsed = await parseCsv(text);
        if (parsed.length) {
          setTableData(parsed);
          showToast(`${parsed.length} Zeilen aus Zwischenablage importiert.`);
        } else {
          showToast("Keine Daten aus Zwischenablage erkannt.");
        }
      } catch (err) {
        console.error(err);
        showToast("Zwischenablage kann nicht gelesen werden.");
      }
    }

    function deriveEventFromData() {
      const data = getTableData();
      const eventIds = new Set(
        data
          .map(row => row.EventID)
          .filter(id => EVENT_ID_PATTERN.test(id))
      );
      if (eventIds.size === 1) {
        const value = Array.from(eventIds)[0];
        elements.eventId.value = value;
        refreshValidationState();
        showToast(`Event ID ${value} übernommen.`);
        return;
      }
      showToast("Keine eindeutige Event ID in den Daten gefunden.");
    }

    function resetToOriginal() {
      elements.eventId.value = originalEventId;
      setTableData(originalData.map(row => ({ ...row })));
      elements.actionsLinks.innerHTML = "";
      elements.buildBtn.disabled = true;
      lastBuildUrl = null;
      allowSaveOverride = false;
      showToast("Änderungen zurückgesetzt.");
    }

    async function saveData() {
      refreshValidationState();
      const data = getTableData();
      const eventId = elements.eventId.value.trim();
      if (!data.length) {
        showToast("Keine Daten zum Speichern.");
        return;
      }
      if (!validateEventId(eventId)) {
        showToast("Event ID ungültig.");
        return;
      }
      const branch = getBranchValue();
      const strategy = elements.strategy.value;
      const workerUrl = elements.workerUrl.value.trim();
      const adminKey = elements.adminKey.value.trim();

      if (lastNameValidation.unresolved.length && !allowSaveOverride) {
        showToast("Namensvalidierung offen – bitte Zuordnungen abschließen.");
        return;
      }

      try {
        const filePath = `data/${eventId}.csv`;
        if (strategy === "abort-if-exists") {
          const exists = await checkFileExists(branch, filePath);
          if (exists) {
            showToast("Datei existiert bereits – Speichern abgebrochen.");
            return;
          }
        }

        let mergedData = data;
        let mergeNote = "";
        if (strategy === "merge") {
          const existing = await loadExistingCsv(branch, filePath);
          if (existing && existing.length) {
            const merged = mergeRows(existing, data);
            const overwrittenSlots = merged.overwritten;
            mergedData = merged.rows;
            mergeNote = overwrittenSlots.length
              ? `; überschrieben: Slots ${overwrittenSlots.join(", ")}`
              : "";
          }
        }

        const eventPayload = {
          path: filePath,
          content: buildCsv(mergedData, eventId),
          message: `event: ${strategy} ${eventId} (n=${mergedData.length})`,
          branch: branch,
        };

        const aliasUpdate = await prepareAliasFile(branch, lastNameValidation.aliasResolutions || []);
        const allianceUpdate = await prepareAllianceFile(branch, lastNameValidation.newPlayers || []);

        const aliasCount = aliasUpdate && Array.isArray(aliasUpdate.added) ? aliasUpdate.added.length : 0;
        const newPlayerCount = allianceUpdate && Array.isArray(allianceUpdate.added) ? allianceUpdate.added.length : 0;
        const unresolvedAccepted = allowSaveOverride ? lastNameValidation.unresolved.length : 0;
        const summaryLines = [
          `Ziel-Datei: ${filePath}`,
          `Neue Aliase: ${aliasCount}`,
          `Neue Spieler: ${newPlayerCount}`,
        ];
        if (unresolvedAccepted > 0) {
          summaryLines.push(`Offene Namen (bewusst akzeptiert): ${unresolvedAccepted}`);
        }
        const proceed = window.confirm(
          `Speichern vorbereiten:\n\n${summaryLines.join("\n")}\n\nFortfahren?`
        );
        if (!proceed) {
          showToast("Speichern abgebrochen.");
          return;
        }

        const filesToWrite = [];
        const summaries = [];
        if (aliasUpdate) {
          filesToWrite.push(aliasUpdate.payload);
          summaries.push(aliasUpdate.summary);
        }
        if (allianceUpdate) {
          filesToWrite.push(allianceUpdate.payload);
          summaries.push(allianceUpdate.summary);
        }
        filesToWrite.push(eventPayload);

        await writeFilesSequential(filesToWrite, workerUrl, adminKey);

        if (aliasUpdate && Array.isArray(aliasUpdate.added)) {
          aliasUpdate.added.forEach(entry => {
            const aliasKey = normalizePlayerKey(entry.alias);
            if (!aliasKey) return;
            playerDirectory.aliasToCanonical.set(aliasKey, entry.canonical);
            deleteNameResolution(aliasKey);
          });
        }
        if (allianceUpdate && Array.isArray(allianceUpdate.added)) {
          let canonicalListChanged = false;
          allianceUpdate.added.forEach(name => {
            const trimmed = (name || "").toString().trim();
            const key = normalizePlayerKey(trimmed);
            if (!key) return;
            if (!playerDirectory.canonicalByKey.has(key)) {
              playerDirectory.canonicalByKey.set(key, trimmed);
              playerDirectory.canonicalList.push(trimmed);
              canonicalListChanged = true;
            }
            playerDirectory.aliasToCanonical.set(key, trimmed);
            deleteNameResolution(key);
          });
          if (canonicalListChanged) {
            playerDirectory.canonicalList = Array.from(new Set(playerDirectory.canonicalList)).sort((a, b) =>
              a.localeCompare(b, "de", { sensitivity: "base" })
            );
            renderCanonicalOptions();
          }
        }

        if (summaries.length) {
          showToast(`Zusatz-Dateien gespeichert: ${summaries.join(" · ")}`);
        }
        showToast(`Gespeichert nach ${filePath}${mergeNote}`);
        originalData = mergedData.map(row => ({ ...row }));
        originalEventId = eventId;
        lastBuildUrl = null;
        elements.buildBtn.disabled = false;
        renderPreviewLink(branch);
        allowSaveOverride = false;
        refreshValidationState();
      } catch (err) {
        console.error(err);
        showToast(`Speichern fehlgeschlagen: ${err.message}`);
      }
    }

    function buildCsv(rows, eventId) {
      const header = ["EventID", "Slot", "PlayerName", "RoleAtRegistration", "Teilgenommen", "Punkte", "Warnungen"];
      const csvRows = rows.map(row => {
        const normalized = normalizeRow(row);
        normalized.EventID = eventId;
        return header.map(key => formatCsvValue(normalized[key]));
      });
      return [header.join(","), ...csvRows.map(cols => cols.join(","))].join("\n");
    }

    function formatCsvValue(value) {
      if (value === null || value === undefined) return "";
      const str = value.toString();
      if (str.includes("\"") || str.includes(",") || str.includes("\n")) {
        return `"${str.replace(/"/g, '""')}"`;
      }
      return str;
    }

    function buildSimpleCsv(header, rows) {
      const lines = [];
      lines.push(header.join(","));
      rows.forEach(row => {
        const cols = row.map(value => formatCsvValue(value === undefined || value === null ? "" : value));
        lines.push(cols.join(","));
      });
      return lines.join("\n");
    }

    async function writeFilesSequential(files, workerUrl, adminKey) {
      if (!files.length) return;
      const headers = { "Content-Type": "application/json" };
      if (adminKey) {
        headers["X-Admin-Key"] = adminKey;
      }
      for (const file of files) {
        const response = await fetch(workerUrl, {
          method: "POST",
          headers,
          body: JSON.stringify(file),
        });
        if (!response.ok) {
          const text = await response.text();
          throw new Error(`Worker-Fehler (${response.status}): ${text}`);
        }
      }
    }

    async function prepareAliasFile(branch, aliasResolutions) {
      if (!aliasResolutions.length) return null;
      const path = "data/aliases.csv";
      const header = ["Canonical", "Alias"];
      let existingText = null;
      try {
        existingText = await loadTextFromBranch(branch, path);
      } catch (err) {
        if (err && err.message && err.message.includes(" 404")) {
          existingText = null;
        } else {
          throw err;
        }
      }

      const rows = [];
      const existingAliases = new Set();
      if (existingText) {
        const parsed = Papa.parse(existingText, { header: true, skipEmptyLines: true });
        parsed.data.forEach(row => {
          const canonical = (row.Canonical || row.PlayerName || "").toString().trim();
          const alias = (row.Alias || row.Name || "").toString().trim();
          if (!canonical && !alias) return;
          rows.push([canonical, alias]);
          if (alias) {
            existingAliases.add(normalizePlayerKey(alias));
          }
        });
      }

      const addedAliases = [];
      const addedKeys = new Set();
      aliasResolutions.forEach(item => {
        const aliasName = (item.name || "").toString().trim();
        const canonicalName = (item.canonical || "").toString().trim();
        const aliasKey = normalizePlayerKey(aliasName);
        if (!aliasKey || !canonicalName) return;
        if (aliasKey === normalizePlayerKey(canonicalName)) return;
        if (existingAliases.has(aliasKey) || addedKeys.has(aliasKey)) return;
        rows.push([canonicalName, aliasName]);
        addedKeys.add(aliasKey);
        addedAliases.push({ alias: aliasName, canonical: canonicalName });
      });

      if (!addedAliases.length) {
        return null;
      }

      const content = buildSimpleCsv(header, rows);
      return {
        payload: {
          path,
          content,
          message: `admin: update aliases (${addedAliases.length})`,
          branch,
        },
        summary: `Aliase: ${addedAliases.length}`,
        added: addedAliases,
      };
    }

    async function prepareAllianceFile(branch, newPlayers) {
      if (!newPlayers.length) return null;
      const path = "data/alliance.csv";
      const header = ["PlayerName", "Active", "Note", "PrefGroup", "PrefMode", "PrefBoost"];
      let existingText = null;
      try {
        existingText = await loadTextFromBranch(branch, path);
      } catch (err) {
        if (err && err.message && err.message.includes(" 404")) {
          existingText = null;
        } else {
          throw err;
        }
      }

      const rows = [];
      const existingPlayers = new Set();
      if (existingText) {
        const parsed = Papa.parse(existingText, { header: true, skipEmptyLines: true });
        parsed.data.forEach(row => {
          const values = header.map(column => (row[column] !== undefined ? row[column] : ""));
          const playerName = (values[0] || "").toString().trim();
          if (!playerName) return;
          rows.push(values);
          existingPlayers.add(normalizePlayerKey(playerName));
        });
      }

      const addedPlayers = [];
      const addedPlayerKeys = new Set();
      newPlayers.forEach(item => {
        const canonicalName = (item.canonical || item.name || "").toString().trim();
        if (!canonicalName) return;
        const key = normalizePlayerKey(canonicalName);
        if (!key || existingPlayers.has(key) || addedPlayerKeys.has(key)) return;
        rows.push([canonicalName, "1", "", "", "", ""]);
        addedPlayerKeys.add(key);
        addedPlayers.push(canonicalName);
      });

      if (!addedPlayers.length) {
        return null;
      }

      const content = buildSimpleCsv(header, rows);
      return {
        payload: {
          path,
          content,
          message: `admin: update alliance (${addedPlayers.length})`,
          branch,
        },
        summary: `Neue Spieler: ${addedPlayers.length}`,
        added: addedPlayers,
      };
    }

    async function checkFileExists(branch, path) {
      try {
        const url = `https://raw.githubusercontent.com/${repoOwner}/${repoName}/${encodeURIComponent(branch)}/${path}`;
        const response = await fetch(url, { method: "HEAD" });
        return response.ok;
      } catch (err) {
        console.warn("HEAD check fehlgeschlagen", err);
        return false;
      }
    }

    async function loadExistingCsv(branch, path) {
      try {
        const url = `https://raw.githubusercontent.com/${repoOwner}/${repoName}/${encodeURIComponent(branch)}/${path}`;
        const response = await fetch(url);
        if (!response.ok) {
          return null;
        }
        const text = await response.text();
        const parsed = await parseCsv(text);
        return parsed.map(normalizeRow);
      } catch (err) {
        console.warn("Merge: Laden fehlgeschlagen", err);
        return null;
      }
    }

    function mergeRows(existing, incoming) {
      const bySlot = new Map();
      const overwritten = [];
      existing.forEach(row => {
        const normalized = normalizeRow(row);
        if (Number.isInteger(normalized.Slot)) {
          bySlot.set(Number(normalized.Slot), normalized);
        }
      });
      incoming.forEach(row => {
        const normalized = normalizeRow(row);
        const slot = Number(normalized.Slot);
        if (Number.isInteger(slot)) {
          if (bySlot.has(slot)) {
            overwritten.push(slot);
          }
          bySlot.set(slot, normalized);
        }
      });
      const rows = Array.from(bySlot.values()).sort((a, b) => Number(a.Slot) - Number(b.Slot));
      return { rows, overwritten };
    }

    async function triggerBuild() {
      const branch = getBranchValue();
      const eventId = elements.eventId.value.trim();
      const payload = {
        ref: branch,
        reason: `admin events upload ${eventId}`,
      };
      try {
        const response = await fetch("/dispatch", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!response.ok) {
          const text = await response.text();
          throw new Error(text || `HTTP ${response.status}`);
        }
        const result = await response.json().catch(() => null);
        if (result && result.html_url) {
          lastBuildUrl = result.html_url;
          renderActionsLink(result.html_url);
        }
        showToast("Build ausgelöst.");
      } catch (err) {
        console.error(err);
        showToast(`Build fehlgeschlagen: ${err.message}`);
      }
    }

    function renderPreviewLink(branch) {
      const url = `/?branch=${encodeURIComponent(branch)}`;
      elements.actionsLinks.innerHTML = `<a href="${url}" target="_blank" rel="noopener">Vorschau öffnen</a>`;
    }

    function renderActionsLink(url) {
      const preview = elements.actionsLinks.querySelector("a");
      elements.actionsLinks.innerHTML = "";
      if (preview) {
        elements.actionsLinks.appendChild(preview);
      }
      const link = document.createElement("a");
      link.href = url;
      link.target = "_blank";
      link.rel = "noopener";
      link.textContent = "Actions-Run ansehen";
      elements.actionsLinks.appendChild(link);
    }

    function restoreSettings() {
      const stored = localStorage.getItem("dsro-admin-settings");
      if (!stored) return;
      try {
        const values = JSON.parse(stored);
        elements.workerUrl.value = values.workerUrl || "/write-file";
        elements.adminKey.value = values.adminKey || "";
        elements.branchSelect.value = values.branchSelect || "main";
        if (elements.branchSelect.value === "__custom") {
          elements.customBranchWrapper.classList.remove("hidden");
          elements.customBranch.value = values.customBranch || "";
        }
        elements.remember.checked = true;
      } catch (err) {
        console.warn("Settings konnten nicht geladen werden", err);
      }
    }

    function persistSettings() {
      if (!elements.remember.checked) {
        localStorage.removeItem("dsro-admin-settings");
        return;
      }
      const values = {
        workerUrl: elements.workerUrl.value,
        adminKey: elements.adminKey.value,
        branchSelect: elements.branchSelect.value,
        customBranch: elements.customBranch.value,
      };
      localStorage.setItem("dsro-admin-settings", JSON.stringify(values));
    }

    // Event listeners
    elements.dropzone.addEventListener("dragover", ev => {
      ev.preventDefault();
      elements.dropzone.classList.add("dragover");
    });
    elements.dropzone.addEventListener("dragleave", () => {
      elements.dropzone.classList.remove("dragover");
    });
    elements.dropzone.addEventListener("drop", async ev => {
      ev.preventDefault();
      elements.dropzone.classList.remove("dragover");
      const files = Array.from(ev.dataTransfer.files).filter(file => file.type === "text/csv" || file.name.endsWith(".csv"));
      await importFiles(files);
      refreshValidationState();
    });

    elements.pasteBtn.addEventListener("click", () => {
      importClipboard().then(() => refreshValidationState());
    });

    elements.deriveEvent.addEventListener("click", () => {
      deriveEventFromData();
    });

    elements.branchSelect.addEventListener("change", () => {
      if (elements.branchSelect.value === "__custom") {
        elements.customBranchWrapper.classList.remove("hidden");
      } else {
        elements.customBranchWrapper.classList.add("hidden");
      }
      persistSettings();
      refreshValidationState();
    });

    [elements.eventId, elements.customBranch, elements.workerUrl, elements.adminKey].forEach(el => {
      el.addEventListener("input", () => {
        refreshValidationState();
        persistSettings();
      });
    });

    elements.remember.addEventListener("change", () => {
      persistSettings();
    });

    elements.strategy.addEventListener("change", () => {
      refreshValidationState();
    });

    elements.saveBtn.addEventListener("click", saveData);
    elements.buildBtn.addEventListener("click", triggerBuild);
    elements.resetBtn.addEventListener("click", resetToOriginal);

    elements.nameValidationPending.addEventListener("click", event => {
      const target = event.target.closest(".name-chip");
      if (!target) return;
      const value = target.dataset.name;
      if (value) {
        openNameResolver(value);
      }
    });

    elements.forceSaveBtn.addEventListener("click", () => {
      if (!lastNameValidation.unresolved.length) {
        showToast("Keine offenen Namen.");
        return;
      }
      if (allowSaveOverride) {
        showToast("Override bereits aktiv.");
        return;
      }
      const confirmed = window.confirm(
        `Es sind noch ${lastNameValidation.unresolved.length} Namen offen. Trotzdem speichern erlauben?`
      );
      if (confirmed) {
        allowSaveOverride = true;
        showToast("Override aktiv – Speichern trotz offener Namen möglich.");
        refreshValidationState();
      }
    });

    resolverElements.close.addEventListener("click", closeNameResolver);
    resolverElements.backdrop.addEventListener("click", closeNameResolver);
    resolverElements.aliasButton.addEventListener("click", resolveAliasFromModal);
    resolverElements.newPlayerButton.addEventListener("click", resolveNewPlayerFromModal);
    resolverElements.resetButton.addEventListener("click", resetNameResolutionFromModal);
    resolverElements.canonicalInput.addEventListener("keydown", event => {
      if (event.key === "Enter") {
        event.preventDefault();
        resolveAliasFromModal();
      }
    });
    resolverElements.newPlayerInput.addEventListener("keydown", event => {
      if (event.key === "Enter") {
        event.preventDefault();
        resolveNewPlayerFromModal();
      }
    });
    document.addEventListener("keydown", event => {
      if (event.key === "Escape" && !resolverElements.modal.classList.contains("hidden")) {
        event.preventDefault();
        closeNameResolver();
      }
    });

    elements.eventId.addEventListener("blur", () => refreshValidationState());

    table.on("tableBuilt", () => {
      originalData = table.getData().map(row => ({ ...row }));
      originalEventId = elements.eventId.value;
      refreshValidationState();
    });

    // Initial setup
    restoreSettings();
    refreshValidationState();
    loadPlayerDirectory().then(() => refreshValidationState());
  </script>
</body>
</html>
