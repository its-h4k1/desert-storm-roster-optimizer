<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Callup-Assistent · Erinnerungen & Tracking</title>
  <meta name="robots" content="noindex, nofollow" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="admin.css" />
  <style>
    /* Layout-Notiz: Bisher begrenzten der 1200px-Wrapper und sechs Spalten die Breite. Mehr Fläche + gestapelte Callup-Blöcke
       verhindern gequetschte Spalten und erlauben bei kleineren Screens einen horizontalen Scroll. */
    body { margin: 0; }
    .page-header { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-end; }
    .page-header h1 { margin:0; flex:1 1 220px; }
    .page-header p { margin:0; color:var(--text-muted); }
    .page-header .settings { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-end; }
    label { display:flex; flex-direction:column; gap:0.35rem; font-size:0.9rem; color:var(--text-muted); }
    input[type="text"], input[type="search"], input[type="password"], select, textarea { font:inherit; padding:0.5rem 0.65rem; border-radius:0.75rem; border:1px solid var(--border); background:var(--bg-alt); color:var(--text); min-width:12rem; }
    input:focus, select:focus, textarea:focus { outline:2px solid rgba(37,99,235,0.35); outline-offset:1px; }
    button { font:inherit; border:1px solid var(--border); border-radius:0.75rem; padding:0.55rem 1rem; background:#fff; color:var(--text); cursor:pointer; display:inline-flex; align-items:center; gap:0.4rem; }
    button:hover { background:#f8fafc; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    .controls { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center; }
    .controls .spacer { flex:1; min-width:40px; }
    .filters { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center; }
    .autosync-toggle { display:flex; flex-direction:column; gap:0.2rem; max-width:340px; }
    .autosync-toggle strong { display:flex; align-items:center; gap:0.4rem; font-size:0.95rem; }
    .autosync-toggle small { color:var(--text-muted); line-height:1.35; }
    .hint { color:var(--text-muted); font-size:0.9rem; }
    .card-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:0.85rem; }
    .card { background:var(--panel-muted); border:1px solid var(--border); border-radius:0.85rem; padding:0.85rem; }
    .callup-page .admin-content { width:min(1400px,100%); }
    .callup-page .page-inner { max-width:1400px; }
    .callup-config { margin-top:0.25rem; display:grid; gap:0.85rem; }
    .callup-config .card-grid { grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); }
    .callup-config .controls { justify-content:flex-end; }
    .config-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(180px,1fr)); gap:0.65rem; }
    .config-status { display:flex; gap:0.5rem; align-items:center; color:var(--text-muted); font-size:0.9rem; }
    .badge { display:inline-flex; align-items:center; gap:0.35rem; padding:0.2rem 0.6rem; border-radius:999px; font-weight:700; font-size:0.85rem; border:1px solid var(--border); }
    .badge.warn { background:#fef9c3; color:#854d0e; border-color:#fde68a; }
    .badge.info { background:#e0f2fe; color:#075985; border-color:#bae6fd; }
    .callup-table-wrapper { width:100%; overflow-x:auto; padding:0.25rem; }
    .table-wrapper { border:1px solid var(--border); border-radius:0.85rem; overflow:auto; box-shadow:var(--shadow-card); }
    .callup-table { width:100%; border-collapse:collapse; min-width:1100px; table-layout:auto; }
    thead { background:var(--bg-alt); position:sticky; top:0; z-index:5; }
    th { font-size:0.9rem; color:var(--text-muted); letter-spacing:0.01em; }
    th, td { padding:0.7rem 0.9rem; border-bottom:1px solid var(--border); text-align:left; vertical-align:top; line-height:1.4; }
    tbody tr:nth-child(4n+1) td, tbody tr:nth-child(4n+2) td { background:var(--panel-muted); }
    tbody tr.absent td { opacity:0.65; }
    tbody tr.recommended td { box-shadow: inset 3px 0 0 #2563eb; }
    .pill { display:inline-flex; align-items:center; gap:0.35rem; padding:0.25rem 0.6rem; border-radius:999px; font-size:0.85rem; }
    .pill.info { background:#e0f2fe; color:#075985; }
    .pill.warn { background:#fef9c3; color:#854d0e; }
    .pill.ok { background:#dcfce7; color:#166534; }
    .pill.bad { background:#fee2e2; color:#991b1b; }
    .chip { display:inline-flex; align-items:center; gap:0.35rem; padding:0.25rem 0.55rem; border-radius:999px; font-weight:600; font-size:0.85rem; border:1px solid var(--border); }
    .chip.ns-ok { background:#dcfce7; color:#14532d; border-color:#bbf7d0; }
    .chip.ns-mid { background:#fef9c3; color:#854d0e; border-color:#fde68a; }
    .chip.ns-bad { background:#fee2e2; color:#991b1b; border-color:#fecdd3; }
    .chip.ns-neutral { background:#e2e8f0; color:#475569; border-color:#cbd5e1; }
    .row-actions { display:flex; gap:0.4rem; flex-wrap:wrap; }
    .cell-stack { display:flex; flex-direction:column; gap:0.45rem; }
    .player-cell .player-name { font-weight:700; font-size:1rem; }
    .player-cell .player-meta { display:flex; flex-wrap:wrap; gap:0.4rem; color:var(--text-muted); font-size:0.88rem; }
    .player-cell .player-meta .tag { display:inline-flex; gap:0.3rem; align-items:center; padding:0.1rem 0.5rem; background:var(--bg-alt); border:1px solid var(--border); border-radius:0.6rem; font-size:0.83rem; }
    .risk-cell .chip { width:fit-content; }
    .reason-chip { display:inline-flex; align-items:center; gap:0.35rem; padding:0.2rem 0.55rem; border-radius:0.8rem; background:var(--bg-alt); border:1px solid var(--border); font-weight:600; font-size:0.85rem; margin:0.1rem 0; }
    .callup-cell { min-width:280px; }
    .callup-steps { display:grid; gap:0.65rem; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); }
    .callup-step { padding:0.75rem 0.85rem; border:1px solid var(--border); border-radius:0.85rem; background:var(--bg-alt); box-shadow:inset 0 1px 0 rgba(255,255,255,0.45); }
    .callup-step h3 { margin:0; font-size:0.95rem; color:var(--text); }
    .callup-step .inline { display:flex; gap:0.6rem; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    .callup-step .inline small { color:var(--text-muted); }
    .timestamp-input { min-width:180px; max-width:220px; padding:0.45rem 0.6rem; }
    .callup-cell select { min-width:180px; width:fit-content; }
    .final-control { padding-top:0.35rem; margin-top:0.35rem; border-top:1px dashed var(--border); }
    .final-control .hint { font-size:0.85rem; }
    textarea.notes { min-width:220px; min-height:64px; max-width:100%; resize:vertical; }
    .status-bar { position:sticky; bottom:0; background:var(--glass); border-top:1px solid var(--border); padding:0.75rem 1rem; display:flex; gap:0.6rem; align-items:center; box-shadow:0 -8px 24px rgba(15,23,42,0.08); flex-wrap:wrap; }
    .status-badge { display:inline-flex; align-items:center; gap:0.35rem; padding:0.35rem 0.7rem; border-radius:999px; font-weight:600; font-size:0.9rem; }
    .status-info { background:#e0f2fe; color:#075985; }
    .status-warn { background:#fff7ed; color:#9a3412; }
    .status-ok { background:#dcfce7; color:#14532d; }
    .status-error { background:#fee2e2; color:#991b1b; }
    .candidate-row { cursor:pointer; }
    .candidate-row td { padding-top:0.6rem; padding-bottom:0.6rem; }
    .candidate-row .player-meta { font-size:0.86rem; }
    .candidate-row .player-meta .tag { background:transparent; }
    .no-show-stack { display:flex; flex-direction:column; gap:0.35rem; }
    .ns-chip { display:inline-flex; align-items:center; gap:0.35rem; padding:0.25rem 0.55rem; border-radius:0.6rem; font-weight:600; font-size:0.85rem; border:1px solid var(--border); background:var(--bg-alt); }
    .ns-chip strong { font-size:0.85rem; color:var(--text-muted); }
    .ns-chip small { color:var(--text-muted); }
    .reason-cell { min-width:180px; }
    .callup-summary { display:flex; flex-wrap:wrap; gap:0.4rem; align-items:center; }
    .status-chip { display:inline-flex; align-items:center; gap:0.35rem; padding:0.25rem 0.55rem; border-radius:0.7rem; font-weight:700; font-size:0.85rem; border:1px solid var(--border); background:var(--bg-alt); }
    .status-chip.muted { color:var(--text-muted); background:transparent; }
    .status-chip.info { background:#e0f2fe; border-color:#bae6fd; color:#075985; }
    .status-chip.ok { background:#dcfce7; border-color:#bbf7d0; color:#166534; }
    .status-chip.warn { background:#fef9c3; border-color:#fef08a; color:#854d0e; }
    .status-chip.bad { background:#fee2e2; border-color:#fecdd3; color:#991b1b; }
    .note-indicator { display:inline-flex; align-items:center; gap:0.35rem; color:var(--text-muted); font-weight:600; }
    .note-indicator.has-note { color:#0f172a; }
    .toast-container { position:fixed; inset:auto 1rem 1rem auto; display:grid; gap:0.5rem; z-index:100; }
    .toast { padding:0.65rem 0.85rem; border-radius:0.8rem; background:#0f172a; color:#e2e8f0; box-shadow:var(--shadow-card); border:1px solid rgba(15,23,42,0.3); opacity:0.96; transition:opacity 0.3s ease; max-width:320px; }
    .toast.error { background:#991b1b; color:#fef2f2; border-color:#fecdd3; }
    .toast.success { background:#166534; color:#ecfdf3; border-color:#bbf7d0; }
    .toast.fade-out { opacity:0; }
    .detail-row { display:none; }
    .detail-row td { padding:0; border-bottom:none; background:transparent; }
    .detail-card { margin:0 0.35rem 0.75rem; padding:0.9rem; border:1px solid var(--border); border-radius:0.85rem; background:var(--panel-muted); box-shadow:var(--shadow-card); }
    .detail-header { display:flex; align-items:center; justify-content:space-between; gap:0.5rem; margin-bottom:0.6rem; }
    .detail-header h3 { margin:0; font-size:1rem; }
    .detail-note { margin-top:0.6rem; }
    .callup-table .detail-row + .candidate-row td { border-top:1px solid var(--border); }
    @media (max-width: 960px) { table { min-width:1100px; } .page-header .settings { width:100%; } label { width:100%; } button { width:100%; justify-content:center; } }
  </style>
</head>
<body class="callup-page">
  <div class="admin-shell">
    <aside class="admin-sidebar">
      <div class="admin-sidebar-header">
        <div class="admin-logo">ELT Admin</div>
        <button class="sidebar-close" aria-label="Navigation schließen">✕</button>
      </div>
      <nav class="admin-nav">
        <a href="index.html">CSV &amp; Datei-Tools</a>
        <a href="events.html">Events erfassen</a>
        <a href="players.html">Spieler &amp; Aliase</a>
        <a href="absences.html">Absenzen</a>
        <a href="group-preferences.html">Gruppenpräferenzen</a>
        <a href="event-assignments.html">Event-Zusagen</a>
        <a href="noshow-dashboard.html">No-Show Analyse</a>
        <a href="callup-assistant.html" class="active">Callup-Assistent</a>
      </nav>
    </aside>

    <div class="admin-main">
      <header class="admin-header">
        <button class="sidebar-toggle" aria-label="Navigation öffnen">☰</button>
        <div class="page-title">
          <p>Callup</p>
          <h1>Assistent</h1>
        </div>
        <div class="admin-header-actions">
          <a class="btn ghost" href="../index.html">Zur Roster-Ansicht</a>
        </div>
      </header>

    <main class="admin-content">
      <section class="admin-section page-wrapper">
        <div class="page-inner">
          <header class="page-header">
            <div style="flex:1;min-width:240px;">
              <h1>Callup-Assistent</h1>
              <p>Empfiehlt Erinnerungen basierend auf No-Show-Risiko, Absenzen &amp; Allianz-Status und trackt die Rückmeldungen.</p>
            </div>
            <div class="settings">
              <label>Worker URL
                <input id="workerUrl" type="text" value="https://ds-commit.hak1.workers.dev/write-file" spellcheck="false">
              </label>
              <label>Branch
                <input id="branchInput" type="text" value="main" spellcheck="false">
              </label>
              <label>Admin-Key
                <input id="adminKey" type="password" placeholder="r4-admin" autocomplete="off">
              </label>
              <button id="reloadBtn" class="ghost">Neu laden</button>
              <button id="saveBtn" class="ok">Speichern</button>
            </div>
          </header>

          <section class="panel callup-config" aria-labelledby="callup-config-heading">
            <div class="controls" style="align-items:flex-start; gap:1rem;">
              <div style="flex:1; min-width:280px;">
                <p class="hint" style="margin:0;">Änderungen wirken nach dem nächsten Roster-Build in <code>latest.json</code> und der Roster-Ansicht.</p>
                <h2 id="callup-config-heading" style="margin:0.35rem 0 0.2rem;">Callup-Regeln</h2>
                <div class="config-status">
                  <span id="configStatusBadge" class="badge info">Geladen</span>
                  <span id="configStatusText">Aus <code>data/callup_config.yml</code> geladen.</span>
                </div>
              </div>
              <div class="controls" style="justify-content:flex-end;">
                <button id="configResetBtn" class="ghost" type="button">Auf Standardwerte zurücksetzen</button>
                <button id="configSaveBtn" class="ok" type="button">Speichern</button>
              </div>
            </div>
            <div class="config-grid">
              <label>Minimale Events (für Rolling/Overall)
                <input id="configMinEvents" type="number" min="0" max="50" step="1" inputmode="numeric">
              </label>
              <label>Low-N bis max. Events
                <input id="configLowN" type="number" min="0" max="20" step="1" inputmode="numeric">
              </label>
              <label>High Overall (in %)
                <input id="configHighOverall" type="number" min="0" max="100" step="1" inputmode="decimal">
              </label>
              <label>High Rolling (in %)
                <input id="configHighRolling" type="number" min="0" max="100" step="1" inputmode="decimal">
              </label>
              <label>Rolling-Uptick Minimum (in %)
                <input id="configRollingMin" type="number" min="0" max="100" step="1" inputmode="decimal">
              </label>
              <label>Rolling-Uptick Delta (in %-Punkten)
                <input id="configRollingDelta" type="number" min="0" max="100" step="1" inputmode="decimal">
              </label>
            </div>
          </section>

          <main class="page-main">
            <section class="panel">
              <div class="controls">
                <label style="flex:1;min-width:240px;">Event-ID (Datalist verfügbar)
                  <input type="text" id="eventId" list="eventOptions" placeholder="DS-2025-11-21-A" autocomplete="off">
                </label>
                <button id="useLastEvent" class="ghost" title="Letzten Callup oder lokale Auswahl übernehmen">Event-Vorschlag nutzen</button>
                <div class="spacer"></div>
                <div class="filters">
                  <label style="flex-direction:row;align-items:center;gap:0.35rem;"> <input type="checkbox" id="recommendedOnly" checked> <span>Nur empfohlene Callups</span> </label>
                  <label style="flex-direction:row;align-items:center;gap:0.35rem;"> <input type="checkbox" id="showAllRoster"> <span>Alle Roster-Spieler anzeigen</span> </label>
                  <label style="flex-direction:row;align-items:center;gap:0.35rem;"> <input type="checkbox" id="showAbsent"> <span>Abwesende anzeigen</span> </label>
                </div>
                <label class="autosync-toggle">
                  <strong><input type="checkbox" id="autoSyncSignups" checked> Zugesagte Spieler in Zusage-Pool übernehmen</strong>
                  <small>"Zugesagt (Roster übernehmen)" erzeugt automatisch einen Eintrag in <code>data/event_signups_next.csv</code> (Commitment=hard, Quelle=Callup). Änderungen am Ergebnis spiegeln den Pool beim Speichern.</small>
                </label>
              </div>
              <p class="hint">Roster-Basis: optimierte Aufstellung aus <code>out/latest.json</code> (zuletzt gebaut). Event-ID steuert Absenz-Filter &amp; Speicherung in <code>data/callups.csv</code>.</p>
              <div class="card-grid">
                <div class="card">
                  <strong>Regel-Set (Default)</strong>
                  <ul class="hint" style="margin:0 0 0 1rem; padding:0 0 0 1rem;">
                    <li>Nur Spieler im aktuellen Roster &amp; mit <code>InAlliance=1</code>.</li>
                    <li>Absenzen mit Datums-Überlappung werden standardmäßig ausgeblendet.</li>
                    <li>Empfohlen wenn mindestens eine Bedingung greift: High-Risk (No-Show &gt;= Schwellen, Events ≥ Mindestmenge), Low-N (≤2 Events), Rolling stark höher als Overall (kürzliche Ausfälle).</li>
                  </ul>
                </div>
                <div class="card">
                  <strong>Reminder-Schema</strong>
                  <div class="hint">Bis zu zwei Erinnerungen pro Event &amp; Spieler. Checkbox setzt automatisch einen Zeitstempel; Ergebnisse stehen zur Auswahl (<code>zugesagt</code>/<code>zugesagt (nur Info)</code>/<code>abgesagt</code>/<code>keine Antwort</code>). Freie Notiz möglich.</div>
                </div>
                <div class="card">
                  <strong>Schwellenwerte</strong>
                  <div class="hint">No-Show overall ≥ <span id="thOverall"></span> oder rolling ≥ <span id="thRolling"></span> bei Events ≥ <span id="thEvents"></span>. Low-N: ≤ <span id="thLowN"></span> Events. Uptick: Rolling ≥ Overall + <span id="thDelta"></span> &amp; ≥ <span id="thUptick"></span>.</div>
                </div>
                <div class="card">
                  <strong>Zusage-Pool Sync</strong>
                  <div class="hint">"Zugesagt (Roster übernehmen)" erzeugt einen Eintrag im Zusage-Pool des nächsten Events (<code>Source=callup-confirmed</code>, <code>Commitment=hard</code>). "Abgesagt"/"keine Antwort" entfernen diese Einträge wieder. Manuelle <code>Source=manual</code>-Einträge bleiben unverändert.</div>
                </div>
              </div>
            </section>

            <section class="panel" aria-live="polite">
              <div class="controls" style="margin-bottom:0.5rem;">
                <h2 style="margin:0;">Callup-Kandidaten</h2>
                <span id="candidateCount" class="pill info">–</span>
                <span class="hint" id="eventMeta"></span>
              </div>
              <div class="table-wrapper callup-table-wrapper">
                <table class="callup-table">
                  <thead>
                    <tr>
                      <th>Spieler &amp; Kontext</th>
                      <th>No-Show</th>
                      <th>Gründe</th>
                      <th>Callups</th>
                      <th>Notiz</th>
                    </tr>
                  </thead>
                  <tbody id="candidateBody"></tbody>
                </table>
              </div>
              <div class="hint" id="emptyState" style="display:none;">Keine Kandidaten für die gewählten Filter.</div>
            </section>
          </main>
        </div>
      </section>
    </main>
  </div>
  <div class="admin-overlay"></div>
  <div class="toast-container" id="toastContainer"></div>

  <div class="status-bar">
    <span id="statusBadge" class="status-badge status-info">Bereit</span>
    <div id="statusText" class="status-text">Noch keine Änderungen.</div>
  </div>

  <datalist id="eventOptions"></datalist>

  <script src="../shared.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    (function(){
      const elements = {
        workerUrl: document.getElementById('workerUrl'),
        branch: document.getElementById('branchInput'),
        adminKey: document.getElementById('adminKey'),
        reloadBtn: document.getElementById('reloadBtn'),
        saveBtn: document.getElementById('saveBtn'),
        configSaveBtn: document.getElementById('configSaveBtn'),
        configResetBtn: document.getElementById('configResetBtn'),
        configStatusBadge: document.getElementById('configStatusBadge'),
        configStatusText: document.getElementById('configStatusText'),
        configMinEvents: document.getElementById('configMinEvents'),
        configLowN: document.getElementById('configLowN'),
        configHighOverall: document.getElementById('configHighOverall'),
        configHighRolling: document.getElementById('configHighRolling'),
        configRollingMin: document.getElementById('configRollingMin'),
        configRollingDelta: document.getElementById('configRollingDelta'),
        eventId: document.getElementById('eventId'),
        useLastEvent: document.getElementById('useLastEvent'),
        recommendedOnly: document.getElementById('recommendedOnly'),
        showAllRoster: document.getElementById('showAllRoster'),
        showAbsent: document.getElementById('showAbsent'),
        autoSyncSignups: document.getElementById('autoSyncSignups'),
        candidateBody: document.getElementById('candidateBody'),
        candidateCount: document.getElementById('candidateCount'),
        emptyState: document.getElementById('emptyState'),
        eventOptions: document.getElementById('eventOptions'),
        eventMeta: document.getElementById('eventMeta'),
        statusBadge: document.getElementById('statusBadge'),
        statusText: document.getElementById('statusText'),
        toastContainer: document.getElementById('toastContainer'),
        thOverall: document.getElementById('thOverall'),
        thRolling: document.getElementById('thRolling'),
        thEvents: document.getElementById('thEvents'),
        thLowN: document.getElementById('thLowN'),
        thDelta: document.getElementById('thDelta'),
        thUptick: document.getElementById('thUptick'),
      };

      const SETTINGS_KEY = 'dsro-callups-settings';
      const DEFAULT_HEADERS = ['EventID','PlayerName','Reminder1SentAt','Reminder1Result','Reminder2SentAt','Reminder2Result','FinalStatus','Notes'];
      const SIGNUP_HEADERS = ['PlayerName','Group','Role','Commitment','Source','Note'];
      const RAW_BASE = 'https://raw.githubusercontent.com/its-h4k1/desert-storm-roster-optimizer/main/';
      const PATHS = { latest: 'out/latest.json', alliance: 'data/alliance.csv', absences: 'data/absences.csv', callups: 'data/callups.csv', signups: 'data/event_signups_next.csv' };
      const CALLOUP_SYNC_SOURCE = 'callup-confirmed';
      const canonicalNameJS = (window.dsroShared && typeof window.dsroShared.canonicalNameJS === 'function')
        ? window.dsroShared.canonicalNameJS
        : (value => {
            if (value == null) return '';
            return String(value).toLowerCase().trim().replace(/\s+/g, ' ');
          });

      // Datenmodell-Notiz:
      // - Callup-Ergebnisse werden pro Event & Spieler in data/callups.csv gespeichert.
      //   Ergebnisfelder: Reminder1Result/Reminder2Result je Callup-Schritt plus FinalStatus (manuelle Überschreibung).
      //   Der effektive Status wird aus diesen Feldern über deriveFinal()/resolveCallupDecision() abgeleitet.
      // - Eindeutiger Schlüssel für das Syncing ist EventID + PlayerName; Gruppe/Rolle entnehmen wir dem aktuellen Roster-Kontext.
      // - Der Zusage-Pool (data/event_signups_next.csv) füllt PlayerName/Group/Role + Source + Commitment + Note; Source=callup-confirmed
      //   markiert automatisch erzeugte Zusagen, Commitment=hard erzwingt Slots im nächsten Build.

      /**
       * Regel-Set für Empfehlungen:
       * - High-Risk: noshow_overall >= HIGH_OVERALL oder noshow_rolling >= HIGH_ROLLING, wenn events_seen >= MIN_EVENTS.
       *   Vorschlag: High-Risk ab 40 % overall oder 50 % rolling, aber erst ab 3 Events (Robustheit).
       * - Low-N: events_seen <= LOW_N (unsichere Schätzung, lieber aktiv erinnern).
       * - Recent Uptick: noshow_rolling deutlich höher als overall (>= DELTA_Uptick und >= ROLLING_MIN), als Proxy für kürzliche Ausfälle.
       * Spieler ohne Historie (events_seen 0 oder fehlend) fallen automatisch unter Low-N-Heuristik und werden neutral gebadget.
       */
      const DEFAULT_CALLOUP_CONFIG = {
        version: 1,
        min_events: 3,
        low_n_max_events: 2,
        high_overall_threshold: 0.4,
        high_rolling_threshold: 0.5,
        rolling_uptick_min: 0.25,
        rolling_uptick_delta: 0.1,
      };

      const BADGE_CLASS_BY_LEVEL = {
        nodata: 'chip ns-neutral',
        neutral: 'chip ns-neutral',
        good: 'chip ns-ok',
        warning: 'chip ns-mid',
        bad: 'chip ns-bad',
      };

      const RESULT_OPTIONS = [
        { value: '', label: 'Ergebnis wählen' },
        { value: 'zugesagt (roster übernehmen)', label: 'Zugesagt (Roster übernehmen)' },
        { value: 'zugesagt (nur info)', label: 'Zugesagt (nur Info)' },
        { value: 'zugesagt', label: 'Zugesagt (Legacy)' },
        { value: 'abgesagt', label: 'Abgesagt' },
        { value: 'keine antwort', label: 'Keine Antwort' },
      ];

      const FINAL_OPTIONS = [
        { value: '', label: 'Auto (aus Ergebnissen)' },
        { value: 'confirmed_roster', label: 'Zugesagt (Roster übernehmen)' },
        { value: 'confirmed_info', label: 'Zugesagt (nur Info)' },
        { value: 'confirmed', label: 'Zugesagt (Legacy)' },
        { value: 'declined', label: 'Abgesagt' },
        { value: 'no_response', label: 'Keine Antwort' },
      ];

      const state = {
        roster: { players: [], groups: {}, generatedAt: null },
        rosterIndex: new Map(),
        alliance: new Map(),
        absences: [],
        callups: [],
        headers: [],
        originalCsv: '',
        signups: [],
        signupHeaders: [],
        originalSignupsCsv: '',
        selectedEventId: '',
        loading: false,
        saving: false,
        autoSyncSignups: true,
        expandedPlayer: null,
        callupConfig: { ...DEFAULT_CALLOUP_CONFIG },
        configMeta: { source: 'default', usedDefaults: true, warning: '' },
        configSaving: false,
      };

      const pc = (v) => (v == null || !Number.isFinite(v)) ? '–' : `${(v*100).toFixed(0)}%`;
      const getActiveConfig = () => state.callupConfig || { ...DEFAULT_CALLOUP_CONFIG };

      function showToast(message, tone = 'info') {
        if (!elements.toastContainer) return;
        const toast = document.createElement('div');
        toast.className = 'toast' + (tone === 'error' ? ' error' : tone === 'success' ? ' success' : '');
        toast.textContent = message;
        elements.toastContainer.appendChild(toast);
        requestAnimationFrame(() => {
          setTimeout(() => toast.classList.add('fade-out'), 3200);
          toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        });
      }

      function parseCallupConfigYaml(text) {
        const lines = (text || '').split(/\r?\n/);
        const out = {};
        lines.forEach(line => {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith('#')) return;
          const m = /^([A-Za-z0-9_]+)\s*:\s*(.+)$/.exec(line);
          if (m) out[m[1]] = m[2].trim();
        });
        return out;
      }

      function normalizeCallupConfig(raw = {}) {
        const cfg = { ...DEFAULT_CALLOUP_CONFIG };
        let usedDefaults = false;
        const num = (value) => {
          const n = Number(value);
          return Number.isFinite(n) ? n : null;
        };
        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
        const assignPercent = (key) => {
          if (raw[key] == null) { usedDefaults = true; return; }
          const n = num(raw[key]);
          if (n == null) { usedDefaults = true; return; }
          cfg[key] = clamp(n, 0, 1);
        };
        const assignInt = (key, min, max) => {
          if (raw[key] == null) { usedDefaults = true; return; }
          const n = num(raw[key]);
          if (n == null) { usedDefaults = true; return; }
          cfg[key] = clamp(Math.round(n), min, max);
        };

        assignInt('version', 1, 99);
        assignInt('min_events', 0, 999);
        assignInt('low_n_max_events', 0, 999);
        assignPercent('high_overall_threshold');
        assignPercent('high_rolling_threshold');
        assignPercent('rolling_uptick_min');
        assignPercent('rolling_uptick_delta');

        return { config: cfg, meta: { usedDefaults } };
      }

      function renderConfigInputs() {
        const cfg = getActiveConfig();
        if (elements.configMinEvents) elements.configMinEvents.value = cfg.min_events ?? DEFAULT_CALLOUP_CONFIG.min_events;
        if (elements.configLowN) elements.configLowN.value = cfg.low_n_max_events ?? DEFAULT_CALLOUP_CONFIG.low_n_max_events;
        if (elements.configHighOverall) elements.configHighOverall.value = Math.round((cfg.high_overall_threshold ?? 0) * 100);
        if (elements.configHighRolling) elements.configHighRolling.value = Math.round((cfg.high_rolling_threshold ?? 0) * 100);
        if (elements.configRollingMin) elements.configRollingMin.value = Math.round((cfg.rolling_uptick_min ?? 0) * 100);
        if (elements.configRollingDelta) elements.configRollingDelta.value = Math.round((cfg.rolling_uptick_delta ?? 0) * 100);

        const meta = state.configMeta || {};
        if (elements.configStatusBadge) {
          elements.configStatusBadge.className = 'badge ' + (meta.usedDefaults ? 'warn' : 'info');
          elements.configStatusBadge.textContent = meta.usedDefaults ? 'Standardwerte' : 'Konfiguration aktiv';
        }
        if (elements.configStatusText) {
          const warning = meta.warning || '';
          if (warning) {
            elements.configStatusText.textContent = warning;
          } else if (meta.usedDefaults) {
            elements.configStatusText.textContent = 'Standardwerte aus eingebautem Regel-Set.';
          } else {
            elements.configStatusText.innerHTML = 'Aus <code>data/callup_config.yml</code> geladen.';
          }
        }
      }

      function applyConfigDraftFromInputs() {
        state.callupConfig = buildConfigFromInputs({ useDefaults: false });
        state.configMeta = { source: 'draft', usedDefaults: false, warning: 'Entwurf (noch nicht gespeichert).' };
        renderConfigInputs();
        renderThresholds();
        renderCandidates();
      }

      function normalizeLineEndings(text) { return (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n'); }
      function ensureTrailingNewline(text) { if (!text) return '\n'; return /\n$/.test(text) ? text : text + '\n'; }
      function formatCsvValue(value) {
        if (value === null || value === undefined) return '';
        const str = value.toString();
        if (str.includes('"') || str.includes(',') || str.includes('\n')) return `"${str.replace(/"/g, '""')}"`;
        return str;
      }

      function buildConfigFromInputs({ useDefaults = false } = {}) {
        const cfg = useDefaults ? { ...DEFAULT_CALLOUP_CONFIG } : { ...getActiveConfig() };
        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
        const readInt = (el, fallback, min = 0, max = 999) => {
          if (!el) return fallback;
          const n = Number(el.value);
          if (!Number.isFinite(n)) return fallback;
          return clamp(Math.round(n), min, max);
        };
        const readPercent = (el, fallback) => {
          if (!el) return fallback;
          const n = Number(el.value);
          if (!Number.isFinite(n)) return fallback;
          return clamp(n, 0, 100) / 100;
        };

        cfg.min_events = readInt(elements.configMinEvents, cfg.min_events, 0, 50);
        cfg.low_n_max_events = readInt(elements.configLowN, cfg.low_n_max_events, 0, 50);
        cfg.high_overall_threshold = readPercent(elements.configHighOverall, cfg.high_overall_threshold);
        cfg.high_rolling_threshold = readPercent(elements.configHighRolling, cfg.high_rolling_threshold);
        cfg.rolling_uptick_min = readPercent(elements.configRollingMin, cfg.rolling_uptick_min);
        cfg.rolling_uptick_delta = readPercent(elements.configRollingDelta, cfg.rolling_uptick_delta);
        cfg.version = cfg.version || DEFAULT_CALLOUP_CONFIG.version;
        return cfg;
      }

      function formatPercentValue(value) {
        if (value == null || !Number.isFinite(value)) return '0.00';
        return Number(value).toFixed(2);
      }

      function buildCallupConfigYaml(cfg) {
        const lines = [
          '# Konfiguration für Callup-Empfehlungen.',
          '# - version: Schema-Version der Datei (nur informativ)',
          '# - min_events: Ab wie vielen absolvierten Events Rolling/Overall-Raten ausgewertet werden.',
          '# - low_n_max_events: Bis zu dieser Event-Anzahl werden Spieler vorsorglich als Callup markiert.',
          '# - high_overall_threshold: No-Show-Rate (gesamt), ab der automatisch ein Callup empfohlen wird.',
          '# - high_rolling_threshold: Rolling-No-Show-Rate, ab der automatisch ein Callup empfohlen wird.',
          '# - rolling_uptick_min: Minimaler Rolling-Wert, bevor ein Rolling-Uptick geprüft wird.',
          '# - rolling_uptick_delta: Zusätzliche Differenz, die Rolling gegenüber Overall haben muss (in Prozentpunkten).',
          `version: ${cfg.version ?? DEFAULT_CALLOUP_CONFIG.version}`,
          `min_events: ${cfg.min_events ?? DEFAULT_CALLOUP_CONFIG.min_events}`,
          `low_n_max_events: ${cfg.low_n_max_events ?? DEFAULT_CALLOUP_CONFIG.low_n_max_events}`,
          `high_overall_threshold: ${formatPercentValue(cfg.high_overall_threshold ?? DEFAULT_CALLOUP_CONFIG.high_overall_threshold)}`,
          `high_rolling_threshold: ${formatPercentValue(cfg.high_rolling_threshold ?? DEFAULT_CALLOUP_CONFIG.high_rolling_threshold)}`,
          `rolling_uptick_min: ${formatPercentValue(cfg.rolling_uptick_min ?? DEFAULT_CALLOUP_CONFIG.rolling_uptick_min)}`,
          `rolling_uptick_delta: ${formatPercentValue(cfg.rolling_uptick_delta ?? DEFAULT_CALLOUP_CONFIG.rolling_uptick_delta)}`,
        ];
        return ensureTrailingNewline(lines.join('\n'));
      }

      function normalizeDecisionValue(value) {
        const v = (value || '').toString().trim().toLowerCase();
        if (!v) return '';
        if (v === 'zugesagt (roster übernehmen)' || v === 'zugesagt roster übernehmen' || v === 'confirmed_roster') return 'accept_roster';
        if (v === 'zugesagt (nur info)' || v === 'zugesagt nur info' || v === 'confirmed_info') return 'accept_info';
        if (v === 'zugesagt' || v === 'confirmed') return 'accept_roster';
        if (v === 'abgesagt' || v === 'declined') return 'declined';
        if (v === 'keine antwort' || v === 'no_response' || v === 'no response') return 'no_response';
        return '';
      }

      function describeDecision(decision) {
        switch (decision) {
          case 'accept_roster': return { label: 'zugesagt (Roster übernehmen)', tone: 'ok', commitment: 'hard' };
          case 'accept_info': return { label: 'zugesagt (Info)', tone: 'ok', commitment: 'none' };
          case 'declined': return { label: 'abgesagt', tone: 'bad' };
          case 'no_response': return { label: 'keine Antwort', tone: 'warn' };
          default: return { label: '–', tone: 'muted' };
        }
      }

      function resolveCallupDecision(entry) {
        const finalDecision = normalizeDecisionValue(entry.FinalStatus);
        if (finalDecision) return { decision: finalDecision, source: 'FinalStatus' };
        const r2 = normalizeDecisionValue(entry.Reminder2Result);
        const r1 = normalizeDecisionValue(entry.Reminder1Result);
        if (r2 === 'declined' || r1 === 'declined') {
          return { decision: 'declined', source: r2 === 'declined' ? 'Reminder2Result' : 'Reminder1Result' };
        }
        if (r2 === 'no_response' || r1 === 'no_response') {
          return { decision: 'no_response', source: r2 === 'no_response' ? 'Reminder2Result' : 'Reminder1Result' };
        }
        if (r2 === 'accept_roster' || r2 === 'accept_info') return { decision: r2, source: 'Reminder2Result' };
        if (r1 === 'accept_roster' || r1 === 'accept_info') return { decision: r1, source: 'Reminder1Result' };
        if (finalDecision === 'no_response') return { decision: 'no_response', source: 'FinalStatus' };
        if ((entry.Reminder2SentAt && !r2) || (entry.Reminder1SentAt && !r1)) {
          return { decision: 'no_response', source: 'derived' };
        }
        return { decision: '', source: '' };
      }

      function parseEventDate(eventId) {
        const m = /^DS-(\d{4})-(\d{2})-(\d{2})/i.exec(eventId || '');
        if (m) {
          const [_, y, mth, d] = m;
          return new Date(Date.UTC(Number(y), Number(mth)-1, Number(d)));
        }
        return new Date();
      }

      function isAbsenceActive(abs, refDate) {
        if (!abs || !refDate) return false;
        const from = abs.from ? new Date(abs.from) : null;
        const to = abs.to ? new Date(abs.to) : null;
        const day = new Date(refDate);
        day.setUTCHours(12,0,0,0);
        if (from && day < from) return false;
        if (to && day > to) return false;
        return true;
      }

      function classifyNoShowBadge({ rate, eventsSeen, flags = {} }) {
        const { noData=false, neverMissed=false, lowN=false, singleMiss=false } = flags;
        const GREEN_TH = 0.2;
        const YELLOW_TH = 0.35;
        const SINGLE_MISS_GREEN_SEEN_MIN = 10;
        const SINGLE_MISS_GREEN_RATE_MAX = 0.12;
        const BADGE_SETTINGS = { softenBadUntilSeen: 5 };

        if (noData) return { level: 'nodata', reason: 'no-data' };
        if (neverMissed) return { level: 'good', reason: 'never-missed' };
        if (lowN) return { level: 'warning', reason: 'low-n' };
        const value = (rate != null && Number.isFinite(rate)) ? rate : null;
        if (value == null) return { level: 'nodata', reason: 'no-rate' };
        if (singleMiss) {
          if ((eventsSeen ?? 0) >= SINGLE_MISS_GREEN_SEEN_MIN && value < SINGLE_MISS_GREEN_RATE_MAX) return { level: 'good', reason: 'single-miss-soft-green' };
          return { level: 'warning', reason: 'single-miss-soft-warning' };
        }
        let level;
        if (value < GREEN_TH) level = 'good';
        else if (value < YELLOW_TH) level = 'warning';
        else level = 'bad';
        if (level === 'bad' && eventsSeen != null && eventsSeen <= BADGE_SETTINGS.softenBadUntilSeen) return { level: 'warning', reason: 'small-sample-soften' };
        return { level, reason: 'threshold' };
      }

      function detectRecommendation(player) {
        const cfg = getActiveConfig();
        const eventsSeen = Number.isFinite(player.events_seen) ? Number(player.events_seen) : null;
        const overall = Number.isFinite(player.noshow_overall) ? Number(player.noshow_overall) : null;
        const rolling = Number.isFinite(player.noshow_rolling) ? Number(player.noshow_rolling) : null;
        const reasons = [];
        if (eventsSeen != null && eventsSeen <= cfg.low_n_max_events) {
          reasons.push(`Low-N (${eventsSeen} Event${eventsSeen === 1 ? '' : 's'})`);
        }
        if (eventsSeen != null && eventsSeen >= cfg.min_events) {
          if (overall != null && overall >= cfg.high_overall_threshold) reasons.push(`High No-Show overall ${pc(overall)}`);
          if (rolling != null && rolling >= cfg.high_rolling_threshold) reasons.push(`High No-Show rolling ${pc(rolling)}`);
        }
        if (rolling != null && overall != null && rolling >= Math.max(cfg.rolling_uptick_min, overall + cfg.rolling_uptick_delta)) {
          reasons.push(`Kürzliche Ausfälle (rolling ${pc(rolling)} vs. overall ${pc(overall)})`);
        }
        const recommended = reasons.length > 0;
        return { recommended, reasons };
      }

      function buildCsvFromRows(headers, rows) {
        const headerLine = headers.join(',');
        const lines = rows.map(row => headers.map(h => formatCsvValue(row[h] ?? '')).join(','));
        return ensureTrailingNewline([headerLine, ...lines].join('\n'));
      }

      function buildCurrentCallupCsv() {
        const headers = state.headers.length ? state.headers : [...DEFAULT_HEADERS];
        const rows = state.callups.map(entry => {
          const out = {};
          headers.forEach(h => { out[h] = entry[h] ?? ''; });
          return out;
        });
        rows.sort((a, b) => {
          const ea = (a.EventID || '').toString();
          const eb = (b.EventID || '').toString();
          if (ea === eb) return (a.PlayerName || '').localeCompare((b.PlayerName || ''), 'de', { sensitivity:'base' });
          return ea.localeCompare(eb, 'de', { sensitivity:'base' });
        });
        return buildCsvFromRows(headers, rows);
      }

      function buildCurrentSignupsCsv() {
        const headers = state.signupHeaders.length ? Array.from(new Set([...state.signupHeaders, ...SIGNUP_HEADERS])) : [...SIGNUP_HEADERS];
        const rows = state.signups.map(entry => {
          const out = {};
          headers.forEach(h => { out[h] = entry[h] ?? ''; });
          return out;
        });
        rows.sort((a, b) => (a.PlayerName || '').localeCompare((b.PlayerName || ''), 'de', { sensitivity:'base' }));
        return buildCsvFromRows(headers, rows);
      }

      function hasChanges() {
        const callupsChanged = normalizeLineEndings(buildCurrentCallupCsv()).trim() !== normalizeLineEndings(state.originalCsv).trim();
        const signupsChanged = normalizeLineEndings(buildCurrentSignupsCsv()).trim() !== normalizeLineEndings(state.originalSignupsCsv).trim();
        return callupsChanged || signupsChanged;
      }

      function setStatus(message, tone='info') {
        elements.statusBadge.className = 'status-badge status-' + tone;
        elements.statusBadge.textContent = tone === 'ok' ? 'OK' : tone === 'error' ? 'Fehler' : tone === 'warn' ? 'Hinweis' : 'Status';
        elements.statusText.textContent = message;
      }

      function setLoading(isLoading) {
        state.loading = isLoading;
        elements.reloadBtn.disabled = isLoading || state.saving;
        updateSaveButtonState();
        updateConfigButtonState();
        if (isLoading) setStatus('Lade Daten…', 'info');
      }

      function setSaving(isSaving) {
        state.saving = isSaving;
        updateSaveButtonState();
      }

      function updateSaveButtonState() {
        elements.saveBtn.disabled = state.loading || state.saving || !hasChanges();
        elements.saveBtn.textContent = state.saving ? 'Speichert…' : 'Speichern';
      }

      function updateConfigButtonState() {
        if (elements.configSaveBtn) elements.configSaveBtn.disabled = state.loading || state.configSaving;
        if (elements.configResetBtn) elements.configResetBtn.disabled = state.loading || state.configSaving;
        if (elements.configSaveBtn) elements.configSaveBtn.textContent = state.configSaving ? 'Speichert…' : 'Speichern';
      }

      async function fetchJson(path) {
        const url = RAW_BASE + path;
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status + ' ' + res.statusText);
        return await res.json();
      }

      async function fetchText(path, { allow404 = false } = {}) {
        const url = RAW_BASE + path;
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) {
          if (allow404 && res.status === 404) return '';
          throw new Error('HTTP ' + res.status + ' ' + res.statusText);
        }
        return await res.text();
      }

      async function loadCallupConfig() {
        try {
          const text = await fetchText('data/callup_config.yml', { allow404: true });
          if (!text.trim()) throw new Error('Leer oder fehlt');
          const parsed = parseCallupConfigYaml(text);
          const { config, meta } = normalizeCallupConfig(parsed);
          state.callupConfig = config;
          state.configMeta = { ...meta, source: 'file', warning: meta.usedDefaults ? 'Teils fehlend – Standardwerte ergänzt.' : '' };
        } catch (err) {
          console.warn('callup_config.yml konnte nicht geladen werden, nutze Defaults', err);
          state.callupConfig = { ...DEFAULT_CALLOUP_CONFIG };
          state.configMeta = { source: 'default', usedDefaults: true, warning: 'Standardwerte aktiv (Datei fehlte oder war ungültig).' };
        }
        renderConfigInputs();
        updateConfigButtonState();
      }

      async function loadLatest() {
        try {
          const data = await fetchJson(PATHS.latest);
          const players = Array.isArray(data) ? data : (data.players || []);
          const groups = (!Array.isArray(data) && data && data.groups) ? data.groups : {};
          const generatedAt = (!Array.isArray(data) && data && data.generated_at) ? data.generated_at : null;
          state.roster = { players, groups, generatedAt };
          const index = new Map();
          players.forEach(p => {
            const name = p.display || p.PlayerName || p.player || '';
            const canon = canonicalNameJS(name);
            if (!canon) return;
            index.set(canon, { group: p.group || p.Group || '', role: p.role || p.Role || '' });
          });
          state.rosterIndex = index;
        } catch (err) {
          console.error('latest.json fehlgeschlagen', err);
          state.roster = { players: [], groups: {}, generatedAt: null };
          state.rosterIndex = new Map();
        }
      }

      async function loadAlliance() {
        try {
          const text = ensureTrailingNewline(normalizeLineEndings(await fetchText(PATHS.alliance)));
          const parsed = Papa.parse(text, { header:true, skipEmptyLines:true });
          const nameField = (parsed.meta.fields || []).find(f => /^PlayerName$/i.test(f)) || 'PlayerName';
          state.alliance = new Map((parsed.data || []).map(row => [row[nameField], row.InAlliance]));
        } catch (err) {
          console.warn('alliance.csv konnte nicht geladen werden', err);
          state.alliance = new Map();
        }
      }

      async function loadAbsences() {
        try {
          const text = ensureTrailingNewline(normalizeLineEndings(await fetchText(PATHS.absences)));
          const parsed = Papa.parse(text, { header:true, skipEmptyLines:true });
          state.absences = (parsed.data || []).map(row => ({
            player: (row.PlayerName || '').trim(),
            from: row.From ? row.From.trim() : '',
            to: row.To ? row.To.trim() : '',
            reason: row.Reason || '',
          })).filter(a => a.player);
        } catch (err) {
          console.warn('absences.csv konnte nicht geladen werden', err);
          state.absences = [];
        }
      }

      async function loadCallups() {
        let text = '';
        try {
          text = await fetchText(PATHS.callups);
        } catch (err) {
          console.warn('callups.csv fehlt, initialisiere neu', err);
          text = DEFAULT_HEADERS.join(',') + '\n';
        }
        const normalized = ensureTrailingNewline(normalizeLineEndings(text));
        const parsed = Papa.parse(normalized, { header:true, skipEmptyLines:false });
        state.headers = (parsed.meta.fields || []).filter(Boolean);
        if (!state.headers.length) state.headers = [...DEFAULT_HEADERS];
        state.callups = (parsed.data || [])
          .filter(row => Object.values(row || {}).some(v => (v ?? '').toString().trim() !== ''))
          .map(row => ({ ...row }));
        state.originalCsv = buildCurrentCallupCsv();
        refreshEventOptions();
      }

      async function loadSignups() {
        let text = '';
        try {
          text = await fetchText(PATHS.signups, { allow404: true });
        } catch (err) {
          console.warn('event_signups_next.csv fehlt oder nicht lesbar, starte leer', err);
          text = '';
        }
        const normalized = ensureTrailingNewline(normalizeLineEndings(text || ''));
        const parsed = Papa.parse(normalized, { header:true, skipEmptyLines:true });
        state.signupHeaders = (parsed.meta.fields || []).filter(Boolean);
        if (!state.signupHeaders.length) state.signupHeaders = [...SIGNUP_HEADERS];
        const baseRow = SIGNUP_HEADERS.reduce((acc, key) => ({ ...acc, [key]: key === 'Commitment' ? 'none' : '' }), {});
        state.signups = (parsed.data || []).map(row => {
          let commitment = (row.Commitment || row.commitment || baseRow.Commitment || 'none').toString().trim().toLowerCase() || 'none';
          if (commitment !== 'hard') commitment = 'none';
          return {
            ...baseRow,
            ...row,
            Source: (row.Source || row.source || baseRow.Source || 'manual').toString().trim().toLowerCase() || 'manual',
            Commitment: commitment,
          };
        }).filter(r => (r.PlayerName || '').trim());
        state.originalSignupsCsv = buildCurrentSignupsCsv();
      }

      function refreshEventOptions() {
        const events = Array.from(new Set(state.callups.map(row => (row.EventID || '').trim()).filter(Boolean)));
        events.sort((a, b) => b.localeCompare(a, 'de', { sensitivity:'base' }));
        elements.eventOptions.innerHTML = '';
        events.forEach(ev => {
          const opt = document.createElement('option');
          opt.value = ev;
          elements.eventOptions.appendChild(opt);
        });
        if (!state.selectedEventId) {
          const saved = loadSettings().eventId || '';
          state.selectedEventId = saved || events[0] || '';
        }
        elements.eventId.value = state.selectedEventId;
      }

      function getAbsenceFor(playerName) {
        const target = (playerName || '').trim();
        const ref = parseEventDate(state.selectedEventId || '');
        return state.absences.find(abs => abs.player === target && isAbsenceActive(abs, ref));
      }

      function ensureCallupEntry(eventId, playerName) {
        const existing = state.callups.find(row => (row.EventID || '') === eventId && (row.PlayerName || '') === playerName);
        if (existing) return existing;
        const headers = state.headers.length ? state.headers : DEFAULT_HEADERS;
        const blank = {};
        headers.forEach(h => blank[h] = '');
        blank.EventID = eventId;
        blank.PlayerName = playerName;
        state.callups.push(blank);
        return blank;
      }

      function deriveFinal(entry) {
        const { decision } = resolveCallupDecision(entry);
        if (decision === 'accept_roster' || decision === 'accept_info') return 'confirmed';
        if (decision === 'declined') return 'declined';
        if (decision === 'no_response') return 'no_response';
        return entry.FinalStatus || '';
      }

      function shouldSyncToSignupPool(entry) {
        const { decision } = resolveCallupDecision(entry);
        if (decision === 'accept_roster') return { sync: true, commitment: 'hard', decision };
        // "zugesagt (nur Info)" wird nicht automatisch synchronisiert, damit nur harte Zusagen in den Pool laufen.
        return { sync: false, commitment: 'none', decision };
      }

      function buildCallupNote(entry, decisionCode) {
        const desc = describeDecision(decisionCode);
        const steps = [];
        if (entry.Reminder1Result) steps.push(`C1: ${entry.Reminder1Result}`);
        if (entry.Reminder2Result) steps.push(`C2: ${entry.Reminder2Result}`);
        if (entry.FinalStatus) steps.push(`Final: ${entry.FinalStatus}`);
        const suffix = steps.length ? ` (${steps.join(' · ')})` : '';
        return desc.label && desc.label !== '–' ? `Callup: ${desc.label}${suffix}` : (steps.join(' · ') || 'Callup');
      }

      function syncCallupsToSignupPool(eventId) {
        if (!eventId) return;
        const working = state.signups.map(r => ({ ...r }));
        const touched = new Set();
        const keep = new Set();
        const eventCallups = state.callups.filter(row => (row.EventID || '') === eventId);
        eventCallups.forEach(callup => {
          const canon = canonicalNameJS(callup.PlayerName || '');
          if (!canon) return;
          touched.add(canon);
          const decision = shouldSyncToSignupPool(callup);
          const ctx = state.rosterIndex.get(canon) || {};
          const existing = working.find(r => canonicalNameJS(r.PlayerName || '') === canon && (r.Source || '') === CALLOUP_SYNC_SOURCE);
          if (decision.sync) {
            const base = existing ? { ...existing } : { PlayerName: callup.PlayerName || '', Group:'', Role:'', Commitment:'none', Source: CALLOUP_SYNC_SOURCE, Note:'' };
            base.PlayerName = base.PlayerName || callup.PlayerName || '';
            base.Group = ctx.group || ctx.Group || base.Group || '';
            base.Role = ctx.role || ctx.Role || base.Role || '';
            base.Source = CALLOUP_SYNC_SOURCE;
            base.Commitment = decision.commitment || 'hard';
            base.Note = buildCallupNote(callup, decision.decision);
            if (existing) {
              const idx = working.indexOf(existing);
              working[idx] = base;
            } else {
              working.push(base);
            }
            keep.add(canon);
          }
        });
        state.signups = working.filter(entry => {
          if ((entry.Source || '') !== CALLOUP_SYNC_SOURCE) return true;
          const canon = canonicalNameJS(entry.PlayerName || '');
          if (!touched.has(canon)) return true; // andere Events oder manuell eingetragen lassen
          return keep.has(canon); // nur behalten, wenn aktueller Callup syncen soll
        });
      }

      function renderCandidates() {
        const eventId = elements.eventId.value.trim();
        state.selectedEventId = eventId;
        persistSettings();
        const recommendedOnly = elements.recommendedOnly.checked;
        const showAll = elements.showAllRoster.checked;
        const showAbsent = elements.showAbsent.checked;
        const allianceMap = state.alliance;

        const rosterPlayers = state.roster.players || [];
        const candidates = [];
        rosterPlayers.forEach(p => {
          const name = p.display || p.PlayerName || p.player;
          const allianceValue = allianceMap.has(name) ? allianceMap.get(name) : null;
          const inAlliance = allianceValue != null ? String(allianceValue) === '1' : false;
          if (!inAlliance) return;
          const absence = getAbsenceFor(name);
          const { recommended, reasons } = detectRecommendation(p);
          const existingEntry = state.callups.find(row => (row.EventID || '') === eventId && (row.PlayerName || '') === name);
          const hasData = existingEntry ? Object.values(existingEntry).some(v => (v ?? '').toString().trim() !== '') : false;
          const include = showAll || (recommendedOnly ? recommended : (recommended || hasData));
          if (!include) return;
          if (absence && !showAbsent) return;
          const eventsSeen = Number.isFinite(p.events_seen) ? Number(p.events_seen) : null;
          const miss = Number.isFinite(p.noshow_count) ? Number(p.noshow_count) : null;
          const badgeRolling = classifyNoShowBadge({ rate: p.noshow_rolling, eventsSeen, flags: { noData: eventsSeen == null || eventsSeen === 0, neverMissed: miss === 0, lowN: eventsSeen != null && eventsSeen > 0 && eventsSeen <= 2, singleMiss: miss === 1 } });
          const badgeOverall = classifyNoShowBadge({ rate: p.noshow_overall, eventsSeen, flags: { noData: eventsSeen == null || eventsSeen === 0, neverMissed: miss === 0, lowN: eventsSeen != null && eventsSeen > 0 && eventsSeen <= 2, singleMiss: miss === 1 } });
          const entry = existingEntry || ensureCallupEntry(eventId, name);
          candidates.push({
            name,
            group: p.group || p.Group || '-',
            role: p.role || p.Role || '-',
            eventsSeen,
            noshowOverall: p.noshow_overall,
            noshowRolling: p.noshow_rolling,
            recommended,
            reasons,
            absence,
            badgeRolling,
            badgeOverall,
            callup: entry,
          });
        });

        elements.candidateBody.innerHTML = '';
        candidates.sort((a, b) => {
          if (a.recommended !== b.recommended) return a.recommended ? -1 : 1;
          if (a.group !== b.group) return (a.group || '').localeCompare((b.group || ''), 'de', { sensitivity:'base' });
          return a.name.localeCompare(b.name, 'de', { sensitivity:'base' });
        });

        const availableNames = new Set(candidates.map(c => c.name));
        if (state.expandedPlayer && !availableNames.has(state.expandedPlayer)) state.expandedPlayer = null;

        candidates.forEach(c => {
          const { summaryRow, detailRow } = buildCandidateRows(c);
          if (c.absence) { summaryRow.classList.add('absent'); detailRow.classList.add('absent'); }
          if (c.recommended) { summaryRow.classList.add('recommended'); detailRow.classList.add('recommended'); }
          elements.candidateBody.appendChild(summaryRow);
          elements.candidateBody.appendChild(detailRow);
        });

        applyExpandedState();

        elements.emptyState.style.display = candidates.length ? 'none' : 'block';
        elements.candidateCount.textContent = `${candidates.length} Spieler`;
        elements.candidateCount.className = 'pill ' + (recommendedOnly && !showAll ? 'warn' : 'info');
        const meta = [];
        if (state.roster.generatedAt) meta.push(`Roster gebaut: ${state.roster.generatedAt}`);
        if (eventId) meta.push(`Event: ${eventId}`);
        if (showAbsent) meta.push('Abwesende eingeblendet');
        elements.eventMeta.textContent = meta.join(' · ');
        updateSaveButtonState();
      }

      function buildCandidateRows(c) {
        const callupSummary = buildCallupSummaryDisplay(c.callup);
        const notesSummary = buildNotesSummaryDisplay(c.callup);
        let finalControl = null;
        const refresh = () => { if (finalControl) finalControl.refresh(); callupSummary.refresh(); notesSummary.refresh(); updateSaveButtonState(); };
        finalControl = buildFinalControl(c, refresh);

        const summaryRow = document.createElement('tr');
        summaryRow.className = 'candidate-row';
        summaryRow.dataset.player = c.name;
        summaryRow.appendChild(tdPlayer(c));
        summaryRow.appendChild(tdNoShow(c));
        summaryRow.appendChild(tdReason(c));
        summaryRow.appendChild(tdCallupSummary(callupSummary.element));
        summaryRow.appendChild(tdNotesSummary(notesSummary.element));
        summaryRow.addEventListener('click', () => toggleDetails(c.name));

        const detailRow = document.createElement('tr');
        detailRow.className = 'detail-row';
        detailRow.dataset.player = c.name;
        const detailCell = document.createElement('td');
        detailCell.colSpan = 5;
        detailCell.appendChild(buildDetailCard(c, refresh, finalControl));
        detailRow.appendChild(detailCell);

        return { summaryRow, detailRow };
      }

      function toggleDetails(playerName) {
        const next = state.expandedPlayer === playerName ? null : playerName;
        state.expandedPlayer = next;
        applyExpandedState();
      }

      function applyExpandedState() {
        const open = state.expandedPlayer;
        elements.candidateBody.querySelectorAll('.detail-row').forEach(row => {
          row.style.display = row.dataset.player === open ? 'table-row' : 'none';
        });
        elements.candidateBody.querySelectorAll('.candidate-row').forEach(row => {
          row.classList.toggle('expanded', row.dataset.player === open);
        });
      }

      function tdPlayer(c) {
        const td = document.createElement('td');
        td.className = 'player-cell';
        const wrap = document.createElement('div');
        wrap.className = 'cell-stack';
        const name = document.createElement('div');
        name.className = 'player-name';
        name.textContent = c.name;
        const meta = document.createElement('div');
        meta.className = 'player-meta';
        const metaParts = [];
        metaParts.push(`${c.group || '–'} / ${c.role || '–'}`);
        metaParts.push(`${c.eventsSeen != null ? `${c.eventsSeen} Events` : '– Events'}`);
        if (c.absence) metaParts.push(`Abwesend: ${c.absence.reason || 'keine Angabe'}`);
        metaParts.forEach(part => {
          const tag = document.createElement('span');
          tag.className = 'tag';
          tag.textContent = part;
          meta.appendChild(tag);
        });
        wrap.appendChild(name);
        wrap.appendChild(meta);
        td.appendChild(wrap);
        return td;
      }

      function tdNoShow(c) {
        const td = document.createElement('td');
        td.className = 'risk-cell';
        const wrap = document.createElement('div');
        wrap.className = 'no-show-stack';
        wrap.appendChild(noShowBadge('Overall', c.noshowOverall, c.badgeOverall));
        wrap.appendChild(noShowBadge('Rolling', c.noshowRolling, c.badgeRolling));
        td.appendChild(wrap);
        return td;
      }

      function noShowBadge(label, rate, badge) {
        const chip = document.createElement('div');
        chip.className = 'ns-chip ' + (BADGE_CLASS_BY_LEVEL[badge.level] || BADGE_CLASS_BY_LEVEL.nodata);
        const reasonLabel = badgeReasonLabel(badge.reason);
        chip.innerHTML = `<strong>${label}</strong><span>${pc(rate)}</span><small>${reasonLabel}</small>`;
        return chip;
      }

      function badgeReasonLabel(reason) {
        const map = {
          'no-data': 'keine Daten',
          'no-rate': 'keine Rate',
          'never-missed': 'nie No-Show',
          'low-n': 'Low-N',
          'single-miss-soft-warning': '1 No-Show',
          'single-miss-soft-green': '1 No-Show',
          'threshold': 'threshold',
          'small-sample-soften': 'kleine Stichprobe',
        };
        return map[reason] || reason || '–';
      }

      function tdReason(c) {
        const td = document.createElement('td');
        td.className = 'reason-cell';
        if (c.reasons.length) {
          c.reasons.forEach(r => {
            const pill = document.createElement('div');
            pill.className = 'reason-chip';
            pill.textContent = shortenReason(r);
            td.appendChild(pill);
          });
        } else {
          td.textContent = '—';
        }
        return td;
      }

      function shortenReason(reason) {
        if (/High No-Show overall/i.test(reason)) return 'High No-Show overall';
        if (/High No-Show rolling/i.test(reason)) return 'High No-Show rolling';
        if (/Low-N/i.test(reason)) return reason;
        if (/Kürzliche Ausfälle/i.test(reason)) return 'Rolling Uptick';
        return reason;
      }

      function callupStatus(entry, step) {
        const sentKey = step === 1 ? 'Reminder1SentAt' : 'Reminder2SentAt';
        const resultKey = step === 1 ? 'Reminder1Result' : 'Reminder2Result';
        const decision = normalizeDecisionValue(entry[resultKey]);
        if (decision) return describeDecision(decision);
        if (entry[sentKey]) return { label: 'gesendet', tone: 'info' };
        return { label: '–', tone: 'muted' };
      }

      function finalStatus(entry) {
        const { decision } = resolveCallupDecision(entry);
        if (decision) return describeDecision(decision);
        const derived = deriveFinal(entry);
        const labelMap = { confirmed: 'zugesagt', declined: 'abgesagt', no_response: 'keine Antwort' };
        const toneMap = { confirmed: 'ok', declined: 'bad', no_response: 'warn' };
        const tone = toneMap[derived] || 'muted';
        const label = labelMap[derived] || (entry.FinalStatus ? entry.FinalStatus : 'Auto');
        return { label, tone };
      }

      function createStatusChip(label, status) {
        const chip = document.createElement('div');
        updateStatusChip(chip, label, status);
        return chip;
      }

      function updateStatusChip(chip, label, status) {
        chip.className = `status-chip ${status.tone || 'muted'}`;
        chip.innerHTML = `<span>${label}:</span><span>${status.label}</span>`;
      }

      function buildCallupSummaryDisplay(entry) {
        const wrap = document.createElement('div');
        wrap.className = 'callup-summary';
        const c1 = createStatusChip('C1', callupStatus(entry, 1));
        const c2 = createStatusChip('C2', callupStatus(entry, 2));
        const final = createStatusChip('Final', finalStatus(entry));
        wrap.appendChild(c1);
        wrap.appendChild(c2);
        wrap.appendChild(final);
        const refresh = () => {
          updateStatusChip(c1, 'C1', callupStatus(entry, 1));
          updateStatusChip(c2, 'C2', callupStatus(entry, 2));
          updateStatusChip(final, 'Final', finalStatus(entry));
        };
        return { element: wrap, refresh };
      }

      function buildNotesSummaryDisplay(entry) {
        const indicator = document.createElement('div');
        indicator.className = 'note-indicator';
        const refresh = () => {
          const hasNote = Boolean((entry.Notes || '').trim());
          indicator.className = 'note-indicator' + (hasNote ? ' has-note' : '');
          indicator.textContent = hasNote ? '📝 Notiz vorhanden' : 'keine Notiz';
        };
        refresh();
        return { element: indicator, refresh };
      }

      function tdCallupSummary(element) {
        const td = document.createElement('td');
        td.className = 'callup-summary-cell';
        td.appendChild(element);
        return td;
      }

      function tdNotesSummary(element) {
        const td = document.createElement('td');
        td.className = 'notes-summary-cell';
        td.appendChild(element);
        return td;
      }

      function buildDetailCard(c, onChange = () => {}, finalControl = null) {
        const card = document.createElement('div');
        card.className = 'detail-card';

        const header = document.createElement('div');
        header.className = 'detail-header';
        const title = document.createElement('h3');
        title.textContent = c.name;
        const meta = document.createElement('div');
        meta.className = 'player-meta';
        const parts = [`${c.group || '–'} / ${c.role || '–'}`, `${c.eventsSeen != null ? `${c.eventsSeen} Events` : '– Events'}`];
        if (c.absence) parts.push(`Abwesend: ${c.absence.reason || 'keine Angabe'}`);
        meta.textContent = parts.join(' · ');
        const closeBtn = document.createElement('button');
        closeBtn.className = 'ghost';
        closeBtn.type = 'button';
        closeBtn.textContent = 'Details schließen';
        closeBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleDetails(c.name); });
        header.appendChild(title);
        header.appendChild(closeBtn);
        card.appendChild(header);
        card.appendChild(meta);

        const steps = document.createElement('div');
        steps.className = 'callup-steps';
        steps.appendChild(callupStepBlock(c, 1, onChange));
        steps.appendChild(callupStepBlock(c, 2, onChange, finalControl));
        card.appendChild(steps);

        card.appendChild(notesControl(c, onChange));
        return card;
      }

      function callupStepBlock(c, step, onChange = () => {}, finalControl = null) {
        const block = document.createElement('div');
        block.className = 'callup-step cell-stack';
        const title = document.createElement('h3');
        title.textContent = step === 1 ? 'Callup 1' : 'Callup 2';
        block.appendChild(title);
        const sentKey = step === 1 ? 'Reminder1SentAt' : 'Reminder2SentAt';
        const resultKey = step === 1 ? 'Reminder1Result' : 'Reminder2Result';
        const sent = document.createElement('label');
        sent.className = 'inline';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = Boolean(c.callup[sentKey]);
        const stamp = document.createElement('input');
        stamp.type = 'text';
        stamp.className = 'timestamp-input';
        stamp.placeholder = 'YYYY-MM-DD HH:MM';
        stamp.value = c.callup[sentKey] || '';
        cb.addEventListener('change', () => {
          if (cb.checked && !stamp.value) {
            const now = new Date();
            stamp.value = now.toISOString().replace('T', ' ').slice(0,16);
          }
          if (!cb.checked) stamp.value = '';
          c.callup[sentKey] = stamp.value;
          onChange();
        });
        stamp.addEventListener('input', () => { c.callup[sentKey] = stamp.value; cb.checked = Boolean(stamp.value); onChange(); });
        sent.appendChild(cb);
        sent.appendChild(document.createTextNode('gesendet'));
        const firstLine = document.createElement('div');
        firstLine.className = 'inline';
        firstLine.appendChild(sent);
        firstLine.appendChild(stamp);
        block.appendChild(firstLine);

        const sel = document.createElement('select');
        const currentVal = (c.callup[resultKey] || '').toString().toLowerCase();
        RESULT_OPTIONS.forEach(({ value, label }) => {
          const opt = document.createElement('option');
          opt.value = value;
          opt.textContent = label;
          if (currentVal === value) opt.selected = true;
          sel.appendChild(opt);
        });
        sel.addEventListener('change', () => { c.callup[resultKey] = sel.value; onChange(); });
        block.appendChild(sel);

        if (step === 2) {
          const note = document.createElement('small');
          note.textContent = 'aktiv nach Callup 1';
          block.appendChild(note);
          if (finalControl) {
            block.appendChild(finalControl.container);
          }
        }

        return block;
      }

      function buildFinalControl(c, onChange = () => {}) {
        const wrap = document.createElement('div');
        wrap.className = 'final-control cell-stack';
        const label = document.createElement('div');
        label.className = 'hint';
        label.textContent = 'Final';
        const select = document.createElement('select');
        const currentVal = (c.callup.FinalStatus || '').toString().toLowerCase();
        FINAL_OPTIONS.forEach(({ value, label }) => {
          const opt = document.createElement('option');
          opt.value = value;
          opt.textContent = label;
          if (currentVal === value) opt.selected = true;
          select.appendChild(opt);
        });
        const hint = document.createElement('div');
        hint.className = 'hint';
        const refresh = () => {
          const { decision } = resolveCallupDecision(c.callup);
          if (decision) {
            const desc = describeDecision(decision);
            hint.textContent = `abgeleitet: ${desc.label}`;
            return;
          }
          const derived = deriveFinal(c.callup);
          hint.textContent = derived ? `abgeleitet: ${derived}` : '—';
        };
        refresh();
        select.addEventListener('change', () => { c.callup.FinalStatus = select.value; onChange(); });
        wrap.appendChild(label);
        wrap.appendChild(select);
        wrap.appendChild(hint);
        return { container: wrap, refresh };
      }

      function notesControl(c, onChange = () => {}) {
        const wrap = document.createElement('label');
        wrap.className = 'detail-note cell-stack';
        wrap.textContent = 'Notiz';
        const ta = document.createElement('textarea');
        ta.className = 'notes';
        ta.value = c.callup.Notes || '';
        ta.placeholder = 'z.B. Kontext der Erinnerung';
        ta.addEventListener('input', () => { c.callup.Notes = ta.value; onChange(); });
        wrap.appendChild(ta);
        return wrap;
      }

      async function reloadData() {
        setLoading(true);
        try {
          await loadCallupConfig();
          await Promise.all([loadLatest(), loadAlliance(), loadAbsences(), loadCallups(), loadSignups()]);
          renderThresholds();
          renderCandidates();
          setStatus('Geladen.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus('Laden fehlgeschlagen: ' + err.message, 'error');
        } finally {
          setLoading(false);
          updateSaveButtonState();
        }
      }

      async function saveChanges() {
        if (state.loading || state.saving) return;
        const workerUrl = elements.workerUrl.value.trim();
        const adminKey = elements.adminKey.value.trim();
        const branch = elements.branch.value.trim() || 'main';
        const eventId = elements.eventId.value.trim();
        if (!workerUrl) { setStatus('Worker-URL fehlt.', 'error'); return; }
        if (!adminKey) { setStatus('Admin-Key erforderlich.', 'error'); return; }
        if (state.autoSyncSignups && eventId) {
          syncCallupsToSignupPool(eventId);
        } else if (state.autoSyncSignups && !eventId) {
          setStatus('Event-ID fehlt, Sync in Zusage-Pool übersprungen.', 'warn');
        }

        const callupContent = buildCurrentCallupCsv();
        const signupsContent = buildCurrentSignupsCsv();
        const callupsChanged = normalizeLineEndings(callupContent).trim() !== normalizeLineEndings(state.originalCsv).trim();
        const signupsChanged = normalizeLineEndings(signupsContent).trim() !== normalizeLineEndings(state.originalSignupsCsv).trim();
        if (!callupsChanged && !signupsChanged) { setStatus('Keine Änderungen zu speichern.', 'info'); return; }
        setSaving(true);
        setStatus('Speichere Callups…', 'info');
        try {
          if (callupsChanged) {
            await writeFile(workerUrl, adminKey, { path: 'data/callups.csv', content: callupContent, branch, message: 'admin: update callups.csv via callup assistant' });
            state.originalCsv = callupContent;
          }
          if (signupsChanged) {
            setStatus('Synchronisiere Zusage-Pool…', 'info');
            await writeFile(workerUrl, adminKey, { path: 'data/event_signups_next.csv', content: signupsContent, branch, message: 'admin: sync event_signups_next.csv via callup assistant' });
            state.originalSignupsCsv = signupsContent;
          }
          setStatus(signupsChanged ? 'Callups & Zusage-Pool gespeichert.' : 'Callups gespeichert.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus('Speichern fehlgeschlagen: ' + err.message, 'error');
        } finally {
          setSaving(false);
          updateSaveButtonState();
        }
      }

      async function saveCallupConfig({ useDefaults = false } = {}) {
        if (state.loading || state.configSaving) return;
        const workerUrl = elements.workerUrl.value.trim();
        const adminKey = elements.adminKey.value.trim();
        const branch = elements.branch.value.trim() || 'main';
        if (!workerUrl) { setStatus('Worker-URL fehlt.', 'error'); return; }
        if (!adminKey) { setStatus('Admin-Key erforderlich.', 'error'); return; }

        const cfg = buildConfigFromInputs({ useDefaults });
        const yaml = buildCallupConfigYaml(cfg);
        state.configSaving = true;
        updateConfigButtonState();
        setStatus('Speichere Callup-Regeln…', 'info');
        try {
          await writeFile(workerUrl, adminKey, { path: 'data/callup_config.yml', content: yaml, branch, message: 'admin: update callup_config.yml via callup assistant' });
          state.callupConfig = cfg;
          state.configMeta = { source: 'file', usedDefaults: useDefaults, warning: useDefaults ? 'Standardwerte aktiv.' : '' };
          renderConfigInputs();
          renderThresholds();
          renderCandidates();
          showToast(useDefaults ? 'Standardwerte gespeichert.' : 'Callup-Konfiguration gespeichert.', 'success');
          setStatus('Callup-Konfiguration gespeichert.', 'ok');
        } catch (err) {
          console.error(err);
          showToast('Speichern der Callup-Regeln fehlgeschlagen: ' + err.message, 'error');
          setStatus('Speichern der Callup-Regeln fehlgeschlagen: ' + err.message, 'error');
        } finally {
          state.configSaving = false;
          updateConfigButtonState();
        }
      }

      async function writeFile(workerUrl, adminKey, payload) {
        const headers = { 'Content-Type': 'application/json', 'X-Admin-Key': adminKey };
        const res = await fetch(workerUrl, { method:'POST', headers, body: JSON.stringify(payload) });
        if (!res.ok) {
          const text = await res.text().catch(() => '');
          throw new Error(text || `HTTP ${res.status}`);
        }
        const result = await res.json().catch(() => ({}));
        if (result && result.ok === false) throw new Error(result.error || 'Worker-Fehler');
        return result;
      }

      function persistSettings() {
        const values = { workerUrl: elements.workerUrl.value, branch: elements.branch.value, adminKey: elements.adminKey.value, eventId: elements.eventId.value, autoSyncSignups: elements.autoSyncSignups.checked };
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(values));
      }

      function loadSettings() {
        const saved = localStorage.getItem(SETTINGS_KEY);
        if (!saved) return {};
        try { return JSON.parse(saved); } catch (err) { return {}; }
      }

      function restoreSettings() {
        const saved = loadSettings();
        if (saved.workerUrl) elements.workerUrl.value = saved.workerUrl;
        if (saved.branch) elements.branch.value = saved.branch;
        if (saved.adminKey) elements.adminKey.value = saved.adminKey;
        if (saved.autoSyncSignups !== undefined) elements.autoSyncSignups.checked = Boolean(saved.autoSyncSignups);
        state.autoSyncSignups = elements.autoSyncSignups.checked;
        if (saved.eventId) { elements.eventId.value = saved.eventId; state.selectedEventId = saved.eventId; }
      }

      function renderThresholds() {
        const cfg = getActiveConfig();
        elements.thOverall.textContent = pc(cfg.high_overall_threshold);
        elements.thRolling.textContent = pc(cfg.high_rolling_threshold);
        elements.thEvents.textContent = cfg.min_events;
        elements.thLowN.textContent = cfg.low_n_max_events;
        elements.thDelta.textContent = pc(cfg.rolling_uptick_delta);
        elements.thUptick.textContent = pc(cfg.rolling_uptick_min);
      }

      function initEvents() {
        elements.reloadBtn.addEventListener('click', reloadData);
        elements.saveBtn.addEventListener('click', saveChanges);
        elements.eventId.addEventListener('change', renderCandidates);
        elements.useLastEvent.addEventListener('click', () => {
          if (state.callups.length) {
            const latest = state.callups[state.callups.length - 1];
            elements.eventId.value = latest.EventID || '';
            renderCandidates();
          }
        });
        elements.recommendedOnly.addEventListener('change', () => { if (elements.recommendedOnly.checked) elements.showAllRoster.checked = false; renderCandidates(); });
        elements.showAllRoster.addEventListener('change', () => { if (elements.showAllRoster.checked) elements.recommendedOnly.checked = false; renderCandidates(); });
        elements.showAbsent.addEventListener('change', renderCandidates);
        elements.workerUrl.addEventListener('change', persistSettings);
        elements.branch.addEventListener('change', persistSettings);
        elements.adminKey.addEventListener('change', persistSettings);
        elements.autoSyncSignups.addEventListener('change', () => { state.autoSyncSignups = elements.autoSyncSignups.checked; persistSettings(); });
        elements.eventId.addEventListener('change', persistSettings);
        [elements.configMinEvents, elements.configLowN, elements.configHighOverall, elements.configHighRolling, elements.configRollingMin, elements.configRollingDelta]
          .forEach(el => el?.addEventListener('input', applyConfigDraftFromInputs));
        elements.configSaveBtn?.addEventListener('click', () => saveCallupConfig({ useDefaults: false }));
        elements.configResetBtn?.addEventListener('click', () => {
          state.callupConfig = { ...DEFAULT_CALLOUP_CONFIG };
          state.configMeta = { source: 'default', usedDefaults: true, warning: 'Standardwerte (noch nicht gespeichert).' };
          renderConfigInputs();
          renderThresholds();
          renderCandidates();
          saveCallupConfig({ useDefaults: true });
        });
      }

      restoreSettings();
      initEvents();
      renderConfigInputs();
      renderThresholds();
      reloadData();
    })();
  </script>
  <script src="admin.js"></script>
</body>
</html>
