<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>Spieler & Aliase verwalten</title>
  <link rel="stylesheet" href="admin.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    :root {
      --card-bg: #fff;
      --muted: #6b7280;
      --border: rgba(15, 23, 42, 0.1);
      --pill: #0b63f6;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }

    .page-shell {
      display: grid;
      gap: 1rem;
    }

    .page-header {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1rem;
      display: grid;
      gap: 0.75rem;
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.08);
    }

    .page-header h2 { margin: 0; }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: flex-end;
    }

    label {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.9rem;
      color: var(--muted);
    }

    input[type="text"], input[type="search"] {
      font: inherit;
      padding: 0.55rem 0.7rem;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: var(--bg-alt);
      color: var(--text);
      min-width: 12rem;
    }

    button {
      font: inherit;
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      padding: 0.55rem 1rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    button.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
    button.ghost { background: transparent; border-color: transparent; color: var(--accent); }
    button[disabled] { opacity: 0.6; cursor: not-allowed; }

    .columns {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 1rem;
      align-items: start;
    }

    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1rem;
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.08);
    }

    .card h3 { margin-top: 0; }

    .group-list { display: grid; gap: 0.5rem; }

    details.group {
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      background: var(--panel-muted);
    }

    details.group summary {
      cursor: pointer;
      padding: 0.75rem 1rem;
      list-style: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    details.group summary::-webkit-details-marker { display: none; }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      background: rgba(11, 99, 246, 0.12);
      color: #0b63f6;
      font-weight: 600;
    }

    .group-body { padding: 0.75rem 1rem 1rem; display: grid; gap: 0.75rem; }
    .group-meta { color: var(--muted); font-size: 0.9rem; }
    .alias-list { display: grid; gap: 0.35rem; }
    .alias-row { display: flex; gap: 0.5rem; align-items: center; }
    .alias-row strong { margin-right: 0.35rem; }
    .alias-actions { display: inline-flex; gap: 0.35rem; }

    .inline-form { display: flex; gap: 0.5rem; flex-wrap: wrap; }

    .status { display: flex; gap: 0.5rem; align-items: center; color: var(--muted); }
    .status .badge { padding: 0.2rem 0.5rem; border-radius: 0.5rem; background: rgba(15, 23, 42, 0.08); font-weight: 600; }

    .list-empty { color: var(--muted); text-align: center; padding: 1rem; border: 1px dashed var(--border); border-radius: 0.75rem; }

    .warning { background: rgba(251, 146, 60, 0.12); border: 1px solid rgba(251, 146, 60, 0.3); padding: 0.75rem; border-radius: 0.75rem; color: #92400e; }

    @media (max-width: 960px) { .columns { grid-template-columns: 1fr; } details.group summary { flex-wrap: wrap; } }
  </style>
</head>
<body>
  <div class="admin-shell">
    <aside class="admin-sidebar">
      <div class="admin-sidebar-header">
        <div class="admin-logo">ELT Admin</div>
        <button class="sidebar-close" aria-label="Navigation schließen">✕</button>
      </div>
      <nav class="admin-nav">
        <a href="index.html">CSV &amp; Datei-Tools</a>
        <a href="events.html">Events erfassen</a>
        <a href="players.html" class="active">Spieler &amp; Aliase</a>
        <a href="absences.html">Absenzen</a>
        <a href="group-preferences.html">Gruppenpräferenzen</a>
        <a href="event-assignments.html">Event-Zusagen</a>
        <a href="attendance-config.html">Attendance-Config</a>
        <a href="noshow-dashboard.html">No-Show Analyse</a>
      </nav>
    </aside>

    <div class="admin-main">
      <header class="admin-header">
        <button class="sidebar-toggle" aria-label="Navigation öffnen">☰</button>
        <div class="page-title">
          <p>Spieler &amp; Aliase</p>
          <h1>Alias-Gruppen verwalten</h1>
        </div>
        <div class="admin-header-actions">
          <a class="btn ghost" href="../index.html">Zur Roster-Ansicht</a>
        </div>
      </header>

      <main class="admin-content">
        <div class="page-shell">
          <section class="page-header">
            <div>
              <h2>Alias-Gruppen</h2>
              <p style="margin:0;color:var(--muted)">Pflegt <code>data/alliance.csv</code> und <code>data/aliases.csv</code> mit stabilen kanonischen IDs.</p>
            </div>
            <div class="controls">
              <label>Worker URL
                <input id="workerUrl" type="text" value="https://ds-commit.hak1.workers.dev/write-file" spellcheck="false">
              </label>
              <label>Branch
                <input id="branchInput" type="text" value="main" spellcheck="false">
              </label>
              <label>Suche
                <input id="searchInput" type="search" placeholder="Spieler oder Alias…" autocomplete="off">
              </label>
              <button id="reloadBtn" class="ghost">Neu laden</button>
              <button id="saveBtn" class="primary">Speichern</button>
            </div>
            <div class="status" id="statusBar">
              <span class="badge">Status</span>
              <span id="statusText">Bereit</span>
            </div>
          </section>

          <div class="columns">
            <section class="card">
              <div class="inline-form" style="justify-content: space-between; align-items:center; gap:0.75rem;">
                <h3 style="margin:0">Gruppen</h3>
                <div id="duplicateHints" class="warning hidden"></div>
              </div>
              <div id="groupList" class="group-list"></div>
              <div id="groupEmpty" class="list-empty">Noch keine Spieler geladen.</div>
            </section>

            <section class="card">
              <h3>Duplikats-Erkennung</h3>
              <p class="group-meta">Unicode-normalisierte Namensvarianten werden automatisch erkannt. Vorschläge können mit einem Klick zusammengeführt werden.</p>
              <div id="suggestionList" class="group-list"></div>
              <div id="suggestionEmpty" class="list-empty">Keine Konflikte gefunden.</div>
            </section>
          </div>
        </div>
      </main>
    </div>
  </div>
  <div class="admin-overlay"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js" integrity="sha512-9b7mAJauTSce+YhuaTic9YzQ0dTQyzhGYlNaKxaVGxBMcrFJuw6y3Cl7umAIcXPBkU4hz7PuYfctgEDaoMvf4g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="../shared.js"></script>
  <script src="admin.js"></script>
  <script>
    const repoOwner = "its-h4k1";
    const repoName = "desert-storm-roster-optimizer";
    const defaultBranch = "main";
    const SETTINGS_KEY = "dsro-player-admin-settings";
    const canonicalNameJS = (window.dsroShared && typeof window.dsroShared.canonicalNameJS === "function")
      ? window.dsroShared.canonicalNameJS
      : (v => (v || "").toString().trim().toLowerCase());
    const normalizePlayerName = (v) => (window.dsroShared?.normalizePlayerName?.(v) || (v || "").toString().trim());

    const state = {
      playerHeaders: [],
      playerNameField: "PlayerName",
      allianceRows: [],
      aliasHeaders: ["Canonical", "Alias"],
      aliasCanonicalField: "Canonical",
      aliasAliasField: "Alias",
      aliasRows: [],
      groups: new Map(),
      originalAllianceCsv: "",
      originalAliasesCsv: "",
      loading: false,
      saving: false,
    };

    const elements = {
      groupList: document.getElementById("groupList"),
      groupEmpty: document.getElementById("groupEmpty"),
      suggestionList: document.getElementById("suggestionList"),
      suggestionEmpty: document.getElementById("suggestionEmpty"),
      duplicateHints: document.getElementById("duplicateHints"),
      workerUrl: document.getElementById("workerUrl"),
      branchInput: document.getElementById("branchInput"),
      searchInput: document.getElementById("searchInput"),
      reloadBtn: document.getElementById("reloadBtn"),
      saveBtn: document.getElementById("saveBtn"),
      statusText: document.getElementById("statusText"),
    };

    function normalizeLineEndings(text) { return (text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n"); }
    function ensureTrailingNewline(text) { if (!text) return "\n"; return /\n$/.test(text) ? text : text + "\n"; }
    function formatCsvValue(value) {
      if (value === null || value === undefined) return "";
      const str = value.toString();
      if (/["\n,]/.test(str)) return `"${str.replace(/"/g, '""')}"`;
      return str;
    }
    function buildCsvFromRows(headers, rows) {
      const headerLine = headers.join(",");
      const lines = rows.map(row => headers.map(h => formatCsvValue(row[h] ?? "")).join(","));
      return ensureTrailingNewline([headerLine, ...lines].join("\n"));
    }
    function detectNameField(headers) {
      if (!headers || !headers.length) return "PlayerName";
      const candidates = ["PlayerName", "DisplayName", "Canonical", "Name"];
      return headers.find(h => candidates.includes(h)) || headers[0];
    }
    function detectAliasField(headers, preferred) { return headers.find(h => preferred.includes(h)) || preferred[0]; }

    function setStatus(text, tone = "info") {
      elements.statusText.textContent = text;
      elements.statusText.style.color = tone === "error" ? "#991b1b" : tone === "ok" ? "#0f7b43" : "";
    }

    function buildCandidatePaths(path) {
      const clean = path.replace(/^\/+/, "");
      const prefixes = ["../../", "../", "./", ""];
      const candidates = prefixes.map(p => `${p}${clean}`.replace(/\/+g, "/"));
      candidates.push(`https://raw.githubusercontent.com/${repoOwner}/${repoName}/${defaultBranch}/${clean}`);
      return candidates;
    }

    async function fetchFirstAvailable(urls) {
      for (const url of urls) {
        try {
          const res = await fetch(url, { cache: "no-store" });
          if (res.ok) return await res.text();
        } catch (err) {
          console.warn("Fetch fallback", url, err);
        }
      }
      throw new Error("Keine Quelle erreichbar");
    }

    function rememberSettings() {
      const payload = {
        workerUrl: elements.workerUrl.value.trim(),
        branch: elements.branchInput.value.trim(),
        adminKey: window.dsroShared?.getAdminKey?.() || "",
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(payload));
    }

    function restoreSettings() {
      const saved = localStorage.getItem(SETTINGS_KEY);
      if (!saved) return;
      try {
        const parsed = JSON.parse(saved);
        if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
        if (parsed.branch) elements.branchInput.value = parsed.branch;
        if (parsed.adminKey && window.dsroShared) window.dsroShared.saveAdminKey(parsed.adminKey);
      } catch (err) { console.warn("settings restore", err); }
    }

    function ensureGroup(canonicalKey, seedName) {
      let group = state.groups.get(canonicalKey);
      if (!group) {
        group = {
          canonicalKey,
          canonicalLabel: seedName || canonicalKey,
          currentName: seedName || canonicalKey,
          aliases: new Set(),
          rows: [],
        };
        state.groups.set(canonicalKey, group);
      }
      return group;
    }

    async function loadAlliance() {
      const text = await fetchFirstAvailable(buildCandidatePaths("data/alliance.csv"));
      state.originalAllianceCsv = ensureTrailingNewline(normalizeLineEndings(text));
      const parsed = Papa.parse(state.originalAllianceCsv, { header: true, skipEmptyLines: true });
      state.playerHeaders = parsed.meta.fields || [];
      state.playerNameField = detectNameField(state.playerHeaders);
      state.allianceRows = (parsed.data || []).map(row => {
        const safe = { ...row };
        Object.keys(safe).forEach(k => safe[k] = safe[k] === undefined || safe[k] === null ? "" : safe[k]);
        const currentName = normalizePlayerName(safe[state.playerNameField] || "");
        const canonicalKey = canonicalNameJS(currentName);
        const group = ensureGroup(canonicalKey, currentName);
        group.currentName = group.currentName || currentName;
        group.canonicalLabel = group.canonicalLabel || currentName;
        group.rows.push(safe);
        return { ...safe, canonicalKey, currentName };
      });
    }

    async function loadAliases() {
      try {
        const text = await fetchFirstAvailable(buildCandidatePaths("data/aliases.csv"));
        state.originalAliasesCsv = ensureTrailingNewline(normalizeLineEndings(text));
        const parsed = Papa.parse(state.originalAliasesCsv, { header: true, skipEmptyLines: true });
        state.aliasHeaders = parsed.meta.fields && parsed.meta.fields.length ? parsed.meta.fields : ["Canonical", "Alias"];
        state.aliasCanonicalField = detectAliasField(state.aliasHeaders, ["Canonical", "PlayerName", "Name"]);
        state.aliasAliasField = detectAliasField(state.aliasHeaders, ["Alias", "DisplayName"]);
        state.aliasRows = (parsed.data || []).map(row => ({
          canonical: normalizePlayerName(row[state.aliasCanonicalField] || ""),
          alias: normalizePlayerName(row[state.aliasAliasField] || ""),
        })).filter(r => r.canonical && r.alias);
        state.aliasRows.forEach(({ canonical, alias }) => {
          const canonKey = canonicalNameJS(canonical);
          const group = ensureGroup(canonKey, canonical);
          if (canonicalNameJS(alias) !== canonKey || alias !== group.currentName) {
            group.aliases.add(alias);
          }
        });
      } catch (err) {
        console.warn("aliases load", err);
        state.originalAliasesCsv = "Canonical,Alias\n";
        state.aliasRows = [];
      }
    }

    function rebuildGroupsFromAlliance() {
      const old = new Map(state.groups);
      state.groups = new Map();
      state.allianceRows.forEach(row => {
        const group = ensureGroup(row.canonicalKey, row.currentName);
        group.rows.push(row);
        if (!group.currentName) group.currentName = row.currentName;
        if (!group.canonicalLabel) group.canonicalLabel = row.currentName;
        const previous = old.get(row.canonicalKey);
        if (previous) {
          previous.aliases.forEach(a => group.aliases.add(a));
        }
      });
      state.aliasRows.forEach(({ canonical, alias }) => {
        const key = canonicalNameJS(canonical);
        const group = ensureGroup(key, canonical);
        group.aliases.add(alias);
      });
    }

    function renderGroups() {
      const query = elements.searchInput.value.trim();
      const queryCanon = canonicalNameJS(query);
      const groups = Array.from(state.groups.values()).filter(g => {
        if (!query) return true;
        const haystack = [g.currentName, g.canonicalLabel, ...Array.from(g.aliases)];
        return haystack.some(name => name.toLowerCase().includes(query.toLowerCase()) || canonicalNameJS(name) === queryCanon);
      }).sort((a, b) => a.currentName.localeCompare(b.currentName, "de", { sensitivity: "base" }));

      elements.groupList.innerHTML = "";
      elements.groupEmpty.classList.toggle("hidden", groups.length > 0);
      if (!groups.length) return;

      groups.forEach(group => {
        const details = document.createElement("details");
        details.className = "group";
        details.open = true;
        const summary = document.createElement("summary");
        const title = document.createElement("strong");
        title.textContent = group.currentName || group.canonicalLabel;
        summary.appendChild(title);
        const pill = document.createElement("span");
        pill.className = "pill";
        pill.textContent = `${group.aliases.size} Alias` + (group.aliases.size === 1 ? "" : "e");
        summary.appendChild(pill);
        const meta = document.createElement("span");
        meta.className = "group-meta";
        meta.textContent = `ID: ${group.canonicalKey}`;
        summary.appendChild(meta);
        details.appendChild(summary);

        const body = document.createElement("div");
        body.className = "group-body";

        const nameRow = document.createElement("div");
        nameRow.className = "inline-form";
        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.value = group.currentName;
        nameInput.placeholder = "Hauptname";
        const renameBtn = document.createElement("button");
        renameBtn.textContent = "Hauptname ändern";
        renameBtn.addEventListener("click", (ev) => {
          ev.preventDefault();
          const next = normalizePlayerName(nameInput.value);
          if (!next) return;
          if (next === group.currentName) return;
          group.aliases.add(group.currentName);
          group.currentName = next;
          renderGroups();
          renderSuggestions();
        });
        nameRow.appendChild(nameInput);
        nameRow.appendChild(renameBtn);
        body.appendChild(nameRow);

        const aliasTitle = document.createElement("div");
        aliasTitle.className = "group-meta";
        aliasTitle.textContent = "Aliase";
        body.appendChild(aliasTitle);

        const aliasList = document.createElement("div");
        aliasList.className = "alias-list";
        if (!group.aliases.size) {
          const empty = document.createElement("div");
          empty.className = "group-meta";
          empty.textContent = "Keine Aliase vorhanden.";
          aliasList.appendChild(empty);
        } else {
          Array.from(group.aliases).sort((a, b) => a.localeCompare(b, "de", { sensitivity: "base" })).forEach(alias => {
            const row = document.createElement("div");
            row.className = "alias-row";
            const text = document.createElement("strong");
            text.textContent = alias;
            row.appendChild(text);
            const actions = document.createElement("div");
            actions.className = "alias-actions";

            const setCurrent = document.createElement("button");
            setCurrent.className = "ghost";
            setCurrent.textContent = "Als aktuellen Namen setzen";
            setCurrent.addEventListener("click", () => {
              group.aliases.delete(alias);
              group.aliases.add(group.currentName);
              group.currentName = alias;
              renderGroups();
              renderSuggestions();
            });

            const moveBtn = document.createElement("button");
            moveBtn.className = "ghost";
            moveBtn.textContent = "Verschieben";
            moveBtn.addEventListener("click", () => moveAlias(alias, group.canonicalKey));

            const delBtn = document.createElement("button");
            delBtn.textContent = "Löschen";
            delBtn.addEventListener("click", () => {
              group.aliases.delete(alias);
              renderGroups();
              renderSuggestions();
            });

            actions.appendChild(setCurrent);
            actions.appendChild(moveBtn);
            actions.appendChild(delBtn);
            row.appendChild(actions);
            aliasList.appendChild(row);
          });
        }
        body.appendChild(aliasList);

        const addForm = document.createElement("form");
        addForm.className = "inline-form";
        const aliasInput = document.createElement("input");
        aliasInput.type = "text";
        aliasInput.placeholder = "Alias hinzufügen";
        const addBtn = document.createElement("button");
        addBtn.textContent = "Alias speichern";
        addForm.appendChild(aliasInput);
        addForm.appendChild(addBtn);
        addForm.addEventListener("submit", (ev) => {
          ev.preventDefault();
          const alias = normalizePlayerName(aliasInput.value);
          if (!alias) return;
          if (canonicalNameJS(alias) === group.canonicalKey && alias === group.currentName) return;
          group.aliases.add(alias);
          aliasInput.value = "";
          renderGroups();
          renderSuggestions();
        });
        body.appendChild(addForm);

        details.appendChild(body);
        elements.groupList.appendChild(details);
      });
    }

    function moveAlias(alias, fromKey) {
      const targets = Array.from(state.groups.values()).filter(g => g.canonicalKey !== fromKey);
      if (!targets.length) return;
      const choice = prompt("Zu welchem Hauptnamen verschieben?", targets[0].currentName);
      if (!choice) return;
      const match = targets.find(t => t.currentName === choice || t.canonicalLabel === choice || canonicalNameJS(t.currentName) === canonicalNameJS(choice));
      if (!match) { alert("Keine passende Gruppe gefunden."); return; }
      const from = state.groups.get(fromKey);
      from?.aliases.delete(alias);
      match.aliases.add(alias);
      renderGroups();
      renderSuggestions();
    }

    function buildDuplicateSuggestions() {
      const bucket = new Map();
      state.groups.forEach(group => {
        const allNames = [group.currentName, ...group.aliases];
        allNames.forEach(name => {
          const key = canonicalNameJS(name);
          if (!key) return;
          if (!bucket.has(key)) bucket.set(key, new Set());
          bucket.get(key).add(group.canonicalKey);
        });
      });
      const suggestions = [];
      bucket.forEach((owners, norm) => {
        if (owners.size <= 1) return;
        const involved = Array.from(owners).map(k => state.groups.get(k)).filter(Boolean);
        if (involved.length > 1) suggestions.push({ norm, groups: involved });
      });
      return suggestions;
    }

    function renderSuggestions() {
      const suggestions = buildDuplicateSuggestions();
      elements.suggestionList.innerHTML = "";
      elements.suggestionEmpty.classList.toggle("hidden", suggestions.length > 0);
      elements.duplicateHints.classList.toggle("hidden", suggestions.length === 0);
      if (suggestions.length) {
        elements.duplicateHints.textContent = "Diese Namen sehen gleich aus – zusammenführen?";
      }
      suggestions.forEach(item => {
        const card = document.createElement("div");
        card.className = "card";
        const title = document.createElement("h4");
        title.textContent = `„${item.norm}“ taucht in ${item.groups.length} Gruppen auf.`;
        card.appendChild(title);
        const list = document.createElement("ul");
        item.groups.forEach(g => {
          const li = document.createElement("li");
          li.textContent = `${g.currentName} (ID: ${g.canonicalKey})`;
          list.appendChild(li);
        });
        card.appendChild(list);
        const mergeBtn = document.createElement("button");
        mergeBtn.textContent = "Gruppen zusammenführen";
        mergeBtn.addEventListener("click", () => mergeGroups(item.groups));
        card.appendChild(mergeBtn);
        elements.suggestionList.appendChild(card);
      });
    }

    function mergeGroups(groups) {
      if (!groups || groups.length < 2) return;
      const target = groups[0];
      for (let i = 1; i < groups.length; i += 1) {
        const donor = groups[i];
        donor.aliases.add(donor.currentName);
        donor.aliases.forEach(a => target.aliases.add(a));
        donor.rows.forEach(r => {
          r[state.playerNameField] = target.currentName;
          target.rows.push(r);
        });
        state.groups.delete(donor.canonicalKey);
      }
      renderGroups();
      renderSuggestions();
    }

    function buildAllianceCsv() {
      return buildCsvFromRows(state.playerHeaders, state.allianceRows.map(row => {
        const match = state.groups.get(row.canonicalKey);
        const clone = { ...row };
        if (match) clone[state.playerNameField] = match.currentName;
        return clone;
      }));
    }

    function buildAliasCsv() {
      const headers = state.aliasHeaders && state.aliasHeaders.length ? state.aliasHeaders : [state.aliasCanonicalField, state.aliasAliasField];
      const rows = [];
      state.groups.forEach(group => {
        const canon = group.canonicalLabel || group.currentName || group.canonicalKey;
        const ensureAlias = (alias) => {
          const row = {};
          headers.forEach(h => row[h] = "");
          row[state.aliasCanonicalField] = canon;
          row[state.aliasAliasField] = alias;
          rows.push(row);
        };
        const allAliases = new Set(group.aliases);
        if (canonicalNameJS(group.currentName) !== group.canonicalKey) {
          allAliases.add(group.currentName);
        }
        allAliases.forEach(ensureAlias);
      });
      return buildCsvFromRows(headers, rows);
    }

    async function saveChanges() {
      rememberSettings();
      const adminKey = window.dsroShared?.getAdminKey?.();
      if (!adminKey) { alert("Admin-Key fehlt – bitte einloggen."); return; }
      state.saving = true; elements.saveBtn.disabled = true; setStatus("Speichere…", "info");
      const allianceCsv = buildAllianceCsv();
      const aliasesCsv = buildAliasCsv();
      const branch = elements.branchInput.value.trim() || "main";
      const workerUrl = elements.workerUrl.value.trim();
      const headers = window.dsroShared.buildAdminHeaders({ adminKey, headers: { "Content-Type": "application/json" } });
      const payload = async (path, content) => {
        const res = await fetch(workerUrl, { method: "POST", headers, body: JSON.stringify({ path, content, branch }) });
        const json = await res.json().catch(() => ({}));
        if (!res.ok || !json.ok) throw new Error(json.error || json.detail || `Schreiben fehlgeschlagen (${path})`);
      };
      try {
        await payload("data/alliance.csv", allianceCsv);
        await payload("data/aliases.csv", aliasesCsv);
        setStatus("Gespeichert.", "ok");
      } catch (err) {
        console.error(err);
        setStatus(err.message || "Speichern fehlgeschlagen", "error");
      } finally {
        state.saving = false; elements.saveBtn.disabled = false;
      }
    }

    async function reloadData() {
      state.loading = true; elements.reloadBtn.disabled = true; elements.saveBtn.disabled = true; setStatus("Lade…", "info");
      try {
        state.groups.clear();
        await loadAlliance();
        await loadAliases();
        rebuildGroupsFromAlliance();
        renderGroups();
        renderSuggestions();
        setStatus(`Geladen (${state.groups.size} Gruppen).`, "ok");
      } catch (err) {
        console.error(err);
        setStatus(err.message || "Laden fehlgeschlagen", "error");
      } finally {
        state.loading = false; elements.reloadBtn.disabled = false; elements.saveBtn.disabled = false;
      }
    }

    function init() {
      restoreSettings();
      elements.searchInput.addEventListener("input", renderGroups);
      elements.reloadBtn.addEventListener("click", reloadData);
      elements.saveBtn.addEventListener("click", saveChanges);
      reloadData();
    }

    init();
  </script>
</body>
</html>
