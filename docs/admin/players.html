<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>Spieler & Aliase verwalten</title>
  <link rel="stylesheet" href="admin.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    :root {
      --card-bg: #fff;
      --muted: #6b7280;
      --border: rgba(15, 23, 42, 0.08);
      --pill: #0b63f6;
      --row-bg: rgba(255, 255, 255, 0.8);
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }

    .page-shell { display: grid; gap: 1rem; }

    .page-header {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 0.9rem;
      padding: 1rem 1.1rem;
      display: grid;
      gap: 0.75rem;
      box-shadow: 0 12px 26px rgba(15, 23, 42, 0.08);
    }

    .header-top { display: flex; gap: 0.75rem; align-items: flex-start; flex-wrap: wrap; }
    .title-block { display: grid; gap: 0.3rem; }
    .eyebrow { margin: 0; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.04em; font-size: 0.85rem; }
    .page-header h2 { margin: 0; font-size: 1.5rem; }
    .lede { margin: 0; color: var(--muted); }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      background: var(--panel-muted);
      border: 1px solid var(--border);
      color: var(--muted);
      margin-left: auto;
      font-weight: 600;
    }
    .status-pill.ok { background: #dcfce7; border-color: #bbf7d0; color: #166534; }
    .status-pill.error { background: #fee2e2; border-color: #fecaca; color: #991b1b; }
    .status-pill.info { background: var(--panel-muted); color: var(--muted); }
    .status-dot { width: 10px; height: 10px; border-radius: 999px; background: currentColor; box-shadow: 0 0 0 3px rgba(255,255,255,0.7); }

    .toolbar { display: flex; flex-wrap: wrap; gap: 0.65rem; align-items: center; }
    .toolbar .search { flex: 1; min-width: 220px; }
    .toolbar-actions { display: inline-flex; gap: 0.45rem; flex-wrap: wrap; align-items: center; }

    label {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.9rem;
      color: var(--muted);
    }

    input[type="text"], input[type="search"] {
      font: inherit;
      padding: 0.45rem 0.65rem;
      border-radius: 0.55rem;
      border: 1px solid var(--border);
      background: var(--bg-alt);
      color: var(--text);
      min-width: 12rem;
    }

    button {
      font: inherit;
      border-radius: 0.55rem;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      padding: 0.45rem 0.85rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    button.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
    button.ghost { background: transparent; border-color: transparent; color: var(--accent); }
    button.icon { padding: 0.35rem 0.45rem; border-color: transparent; background: transparent; }
    button[disabled] { opacity: 0.6; cursor: not-allowed; }

    .advanced { border: 1px solid var(--border); border-radius: 0.85rem; background: var(--panel-muted); padding: 0.4rem 0.6rem; }
    .advanced summary { list-style: none; cursor: pointer; display: inline-flex; align-items: center; gap: 0.45rem; color: var(--muted); font-weight: 700; }
    .advanced summary::-webkit-details-marker { display: none; }
    .advanced .settings-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 0.65rem; padding: 0.4rem 0.35rem 0.2rem; }
    .advanced small { color: var(--muted); }

    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 0.85rem 1rem;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
    }

    .list-empty {
      color: var(--muted);
      text-align: center;
      padding: 1rem;
      border: 1px dashed var(--border);
      border-radius: 0.55rem;
    }

    .autocomplete-menu { display: flex; flex-wrap: wrap; gap: 0.35rem; padding: 0.35rem; }
    .autocomplete-item { flex: 0 0 auto; }

    .group-list { display: grid; gap: 0.6rem; }

    .group-row {
      display: grid;
      gap: 0.25rem;
      padding: 0.65rem 0.75rem;
      border-radius: 0.55rem;
      border: 1px solid var(--border);
      background: var(--row-bg);
      box-shadow: 0 6px 14px rgba(15, 23, 42, 0.06);
    }

    .group-head {
      display: flex;
      align-items: center;
      gap: 0.45rem;
    }

    .group-title { display: flex; align-items: baseline; gap: 0.35rem; flex: 1; min-width: 0; }
    .group-name { font-weight: 700; font-size: 1rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .group-meta { color: var(--muted); font-size: 0.9rem; }

    .group-actions { display: inline-flex; gap: 0.15rem; }

    .alias-line { display: flex; align-items: center; gap: 0.4rem; flex-wrap: wrap; }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.06);
      font-weight: 600;
    }
    .chip button { border: none; background: transparent; padding: 0.1rem 0.25rem; color: var(--muted); }
    .chip button:hover { color: var(--text); }

    .inline-input { display: inline-flex; gap: 0.35rem; align-items: center; }
    .inline-input input { padding: 0.35rem 0.55rem; border-radius: 0.45rem; border: 1px solid var(--border); }

    .hint {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: #b45309;
      background: rgba(251, 191, 36, 0.12);
      border: 1px solid rgba(251, 191, 36, 0.4);
      padding: 0.45rem 0.55rem;
      border-radius: 0.5rem;
      font-size: 0.9rem;
    }

    .hint button { border-color: transparent; background: transparent; color: #b45309; font-weight: 700; }

    @media (max-width: 960px) {
      .group-head { flex-wrap: wrap; }
      .group-actions { width: 100%; justify-content: flex-start; }
    }
  </style>
</head>
<body>
  <div class="admin-shell">
    <aside class="admin-sidebar">
      <div class="admin-sidebar-header">
        <div class="admin-logo">ELT Admin</div>
        <button class="sidebar-close" aria-label="Navigation schließen">✕</button>
      </div>
      <nav class="admin-nav">
        <a href="index.html">CSV &amp; Datei-Tools</a>
        <a href="events.html">Events erfassen</a>
        <a href="players.html" class="active">Spieler &amp; Aliase</a>
        <a href="absences.html">Absenzen</a>
        <a href="group-preferences.html">Gruppenpräferenzen</a>
        <a href="event-assignments.html">Event-Zusagen</a>
        <a href="attendance-config.html">Attendance-Config</a>
        <a href="noshow-dashboard.html">No-Show Analyse</a>
      </nav>
    </aside>

    <div class="admin-main">
      <header class="admin-header">
        <button class="sidebar-toggle" aria-label="Navigation öffnen">☰</button>
        <div class="page-title">
          <p>Spieler &amp; Aliase</p>
          <h1>Alias-Gruppen verwalten</h1>
        </div>
        <div class="admin-header-actions">
          <a class="btn ghost" href="../index.html">Zur Roster-Ansicht</a>
        </div>
      </header>

      <main class="admin-content">
        <div class="page-shell">
          <section class="page-header">
            <div class="header-top">
              <div class="title-block">
                <p class="eyebrow">Admin · Aliase</p>
                <h2>Alias-Gruppen</h2>
                <p class="lede">Pflegt <code>data/alliance.csv</code> und <code>data/aliases.csv</code> mit stabilen kanonischen IDs.</p>
              </div>
              <div class="status-pill info" id="statusBar">
                <span class="status-dot"></span>
                <span id="statusText">Bereit</span>
              </div>
            </div>
            <div class="toolbar">
              <label class="search">Spieler suchen
                <input id="searchInput" type="search" placeholder="Name oder ID…" autocomplete="off">
              </label>
              <div class="toolbar-actions">
                <button id="showAllToggle" class="ghost" type="button">Alle Spieler anzeigen</button>
                <button id="reloadBtn" class="ghost" type="button">Neu laden</button>
                <button id="saveBtn" class="primary" type="button">Speichern</button>
              </div>
            </div>
            <details class="advanced">
              <summary>Advanced / Technische Details</summary>
              <div class="settings-grid">
                <label>Worker URL
                  <input id="workerUrl" type="text" value="https://ds-commit.hak1.workers.dev/write-file" spellcheck="false">
                  <small>Ändern nur falls der Schreib-Worker gewechselt wird.</small>
                </label>
                <label>Branch
                  <input id="branchInput" type="text" value="main" spellcheck="false">
                  <small>Ziel-Branch für Schreiboperationen.</small>
                </label>
              </div>
            </details>
          </section>

          <section class="card">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:0.5rem;flex-wrap:wrap;">
              <h3 style="margin:0">Gruppen</h3>
              <small class="group-meta">Inline bearbeiten &amp; speichern</small>
            </div>
            <div id="groupList" class="group-list"></div>
            <div id="groupEmpty" class="list-empty">Noch keine Spieler geladen.</div>
          </section>
        </div>
      </main>
    </div>
  </div>
  <div class="admin-overlay"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="../shared.js"></script>
  <script src="admin.js"></script>
  <script>
    const repoOwner = "its-h4k1";
    const repoName = "desert-storm-roster-optimizer";
    const defaultBranch = "main";
    const SETTINGS_KEY = "dsro-player-admin-settings";
    const canonicalNameJS = (window.dsroShared && typeof window.dsroShared.canonicalNameJS === "function")
      ? window.dsroShared.canonicalNameJS
      : (v => (v || "").toString().trim().toLowerCase());
    const normalizePlayerName = (v) => (window.dsroShared?.normalizePlayerName?.(v) || (v || "").toString().trim());

    const state = {
      playerHeaders: [],
      playerNameField: "PlayerName",
      allianceRows: [],
      aliasHeaders: ["Canonical", "Alias"],
      aliasCanonicalField: "Canonical",
      aliasAliasField: "Alias",
      aliasRows: [],
      groups: new Map(),
      originalAllianceCsv: "",
      originalAliasesCsv: "",
      loading: false,
      saving: false,
      showAllPlayers: false,
      highlightedKey: "",
    };

    const elements = {
      groupList: document.getElementById("groupList"),
      groupEmpty: document.getElementById("groupEmpty"),
      workerUrl: document.getElementById("workerUrl"),
      branchInput: document.getElementById("branchInput"),
      searchInput: document.getElementById("searchInput"),
      showAllToggle: document.getElementById("showAllToggle"),
      reloadBtn: document.getElementById("reloadBtn"),
      saveBtn: document.getElementById("saveBtn"),
      statusText: document.getElementById("statusText"),
    };

    function buildNameIndex() {
      const names = [];
      state.groups.forEach(group => {
        if (group.currentName) names.push(group.currentName);
        if (group.canonicalLabel) names.push(group.canonicalLabel);
        group.aliases.forEach(a => names.push(a));
      });
      if (window.dsroShared?.refreshAdminPlayerIndex) {
        window.dsroShared.refreshAdminPlayerIndex({ additionalNames: names });
      }
    }

    function setCurrentName(group, nextName) {
      const next = normalizePlayerName(nextName);
      if (!group || !next || next === group.currentName) return false;
      const previous = group.currentName;
      if (previous) group.aliases.add(previous);
      group.aliases.delete(next);
      group.currentName = next;
      return true;
    }

    function normalizeLineEndings(text) { return (text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n"); }
    function ensureTrailingNewline(text) { if (!text) return "\n"; return /\n$/.test(text) ? text : text + "\n"; }
    function formatCsvValue(value) {
      if (value === null || value === undefined) return "";
      const str = value.toString();
      if (/["\n,]/.test(str)) return `"${str.replace(/"/g, '""')}"`;
      return str;
    }
    function buildCsvFromRows(headers, rows) {
      const headerLine = headers.join(",");
      const lines = rows.map(row => headers.map(h => formatCsvValue(row[h] ?? "")).join(","));
      return ensureTrailingNewline([headerLine, ...lines].join("\n"));
    }
    function detectNameField(headers) {
      if (!headers || !headers.length) return "PlayerName";
      const candidates = ["PlayerName", "DisplayName", "Canonical", "Name"];
      return headers.find(h => candidates.includes(h)) || headers[0];
    }
    function detectAliasField(headers, preferred) { return headers.find(h => preferred.includes(h)) || preferred[0]; }

    function setStatus(text, tone = "info") {
      elements.statusText.textContent = text;
      const pill = document.getElementById("statusBar");
      pill.classList.remove("ok", "error", "info");
      pill.classList.add(tone);
    }

      function buildCandidatePaths(path) {
        const clean = path.replace(/^\/+/, "");
        const prefixes = ["../../", "../", "./", ""];
        const candidates = prefixes.map(p => `${p}${clean}`.replace(/\/+/g, "/"));
        candidates.push(`https://raw.githubusercontent.com/${repoOwner}/${repoName}/${defaultBranch}/${clean}`);
        return candidates;
      }

    async function fetchFirstAvailable(urls) {
      for (const url of urls) {
        try {
          const res = await fetch(url, { cache: "no-store" });
          if (res.ok) return await res.text();
        } catch (err) {
          console.warn("Fetch fallback", url, err);
        }
      }
      throw new Error("Keine Quelle erreichbar");
    }

    function rememberSettings() {
      const payload = {
        workerUrl: elements.workerUrl.value.trim(),
        branch: elements.branchInput.value.trim(),
        adminKey: window.dsroShared?.getAdminKey?.() || "",
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(payload));
    }

    function restoreSettings() {
      const saved = localStorage.getItem(SETTINGS_KEY);
      if (!saved) return;
      try {
        const parsed = JSON.parse(saved);
        if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
        if (parsed.branch) elements.branchInput.value = parsed.branch;
        if (parsed.adminKey && window.dsroShared) window.dsroShared.saveAdminKey(parsed.adminKey);
      } catch (err) { console.warn("settings restore", err); }
    }

    function ensureGroup(canonicalKey, seedName) {
      let group = state.groups.get(canonicalKey);
      if (!group) {
        group = {
          canonicalKey,
          canonicalLabel: seedName || canonicalKey,
          currentName: seedName || canonicalKey,
          aliases: new Set(),
          rows: [],
        };
        state.groups.set(canonicalKey, group);
      }
      return group;
    }

    async function loadAlliance() {
      const text = await fetchFirstAvailable(buildCandidatePaths("data/alliance.csv"));
      state.originalAllianceCsv = ensureTrailingNewline(normalizeLineEndings(text));
      const parsed = Papa.parse(state.originalAllianceCsv, { header: true, skipEmptyLines: true });
      state.playerHeaders = parsed.meta.fields || [];
      state.playerNameField = detectNameField(state.playerHeaders);
      state.allianceRows = (parsed.data || []).map(row => {
        const safe = { ...row };
        Object.keys(safe).forEach(k => safe[k] = safe[k] === undefined || safe[k] === null ? "" : safe[k]);
        const currentName = normalizePlayerName(safe[state.playerNameField] || "");
        const canonicalKey = canonicalNameJS(currentName);
        const group = ensureGroup(canonicalKey, currentName);
        group.currentName = group.currentName || currentName;
        group.canonicalLabel = group.canonicalLabel || currentName;
        group.rows.push(safe);
        return { ...safe, canonicalKey, currentName };
      });
    }

    async function loadAliases() {
      try {
        const text = await fetchFirstAvailable(buildCandidatePaths("data/aliases.csv"));
        state.originalAliasesCsv = ensureTrailingNewline(normalizeLineEndings(text));
        const parsed = Papa.parse(state.originalAliasesCsv, { header: true, skipEmptyLines: true });
        state.aliasHeaders = parsed.meta.fields && parsed.meta.fields.length ? parsed.meta.fields : ["Canonical", "Alias"];
        state.aliasCanonicalField = detectAliasField(state.aliasHeaders, ["Canonical", "PlayerName", "Name"]);
        state.aliasAliasField = detectAliasField(state.aliasHeaders, ["Alias", "DisplayName"]);
        state.aliasRows = (parsed.data || []).map(row => ({
          canonical: normalizePlayerName(row[state.aliasCanonicalField] || ""),
          alias: normalizePlayerName(row[state.aliasAliasField] || ""),
        })).filter(r => r.canonical && r.alias);
        state.aliasRows.forEach(({ canonical, alias }) => {
          const canonKey = canonicalNameJS(canonical);
          const group = ensureGroup(canonKey, canonical);
          if (canonicalNameJS(alias) !== canonKey || alias !== group.currentName) {
            group.aliases.add(alias);
          }
        });
      } catch (err) {
        console.warn("aliases load", err);
        state.originalAliasesCsv = "Canonical,Alias\n";
        state.aliasRows = [];
      }
    }

    function rebuildGroupsFromAlliance() {
      const old = new Map(state.groups);
      state.groups = new Map();
      state.allianceRows.forEach(row => {
        const group = ensureGroup(row.canonicalKey, row.currentName);
        group.rows.push(row);
        if (!group.currentName) group.currentName = row.currentName;
        if (!group.canonicalLabel) group.canonicalLabel = row.currentName;
        const previous = old.get(row.canonicalKey);
        if (previous) {
          previous.aliases.forEach(a => group.aliases.add(a));
        }
      });
      state.aliasRows.forEach(({ canonical, alias }) => {
        const key = canonicalNameJS(canonical);
        const group = ensureGroup(key, canonical);
        group.aliases.add(alias);
      });
    }

    function renderGroups() {
      const query = elements.searchInput.value.trim();
      const queryCanon = canonicalNameJS(query);
      const duplicates = buildDuplicateSuggestions();
      const duplicateMap = new Map();
      duplicates.forEach(item => item.groups.forEach(g => duplicateMap.set(g.canonicalKey, item)));

      const hasQuery = Boolean(query);
      const allGroups = Array.from(state.groups.values());
      const filtered = allGroups.filter(g => {
        const hasAlias = g.aliases.size > 0;
        const matchesQuery = hasQuery && ([g.currentName, g.canonicalLabel, g.canonicalKey, ...Array.from(g.aliases)]
          .some(name => {
            if (!name) return false;
            const canon = canonicalNameJS(name);
            return name.toLowerCase().includes(query.toLowerCase()) || canon === queryCanon;
          }));
        const spotlight = state.highlightedKey && state.highlightedKey === g.canonicalKey;
        if (state.showAllPlayers) return true;
        return hasAlias || matchesQuery || spotlight;
      }).sort((a, b) => a.currentName.localeCompare(b.currentName, "de", { sensitivity: "base" }));

      elements.groupList.innerHTML = "";
      elements.groupEmpty.classList.toggle("hidden", filtered.length > 0);
      if (!filtered.length) return;

      const makeInlineEdit = (group, container) => {
        container.innerHTML = "";
        const input = document.createElement("input");
        input.type = "text";
        input.value = group.currentName;
        input.autofocus = true;
        input.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter") {
            ev.preventDefault();
            if (setCurrentName(group, input.value)) renderGroups();
            else renderGroups();
          } else if (ev.key === "Escape") {
            ev.preventDefault();
            renderGroups();
          }
        });
        input.addEventListener("blur", () => renderGroups());
        container.appendChild(input);
        input.focus();
      };

      filtered.forEach(group => {
        const row = document.createElement("div");
        row.className = "group-row";

        const head = document.createElement("div");
        head.className = "group-head";
        const title = document.createElement("div");
        title.className = "group-title";
        const nameSlot = document.createElement("div");
        nameSlot.className = "group-name";
        nameSlot.textContent = group.currentName || group.canonicalLabel;
        title.appendChild(nameSlot);
        const meta = document.createElement("span");
        meta.className = "group-meta";
        meta.textContent = `ID: ${group.canonicalKey}`;
        title.appendChild(meta);
        head.appendChild(title);

        const actions = document.createElement("div");
        actions.className = "group-actions";
        const editBtn = document.createElement("button");
        editBtn.className = "icon";
        editBtn.title = "Hauptname bearbeiten";
        editBtn.textContent = "✏️";
        editBtn.addEventListener("click", () => makeInlineEdit(group, nameSlot));

        const addBtn = document.createElement("button");
        addBtn.className = "icon";
        addBtn.title = "Alias hinzufügen";
        addBtn.textContent = "➕";

        const starBtn = document.createElement("button");
        starBtn.className = "icon";
        starBtn.title = "Als aktuellen Namen setzen";
        starBtn.textContent = "⭐";
        starBtn.addEventListener("click", () => {
          if (group.canonicalLabel && setCurrentName(group, group.canonicalLabel)) renderGroups();
        });

        actions.appendChild(editBtn);
        actions.appendChild(addBtn);
        actions.appendChild(starBtn);
        head.appendChild(actions);
        row.appendChild(head);

        const aliasLine = document.createElement("div");
        aliasLine.className = "alias-line";

        const addInline = document.createElement("div");
        addInline.className = "inline-input hidden";
        const aliasInput = document.createElement("input");
        aliasInput.type = "text";
        aliasInput.placeholder = "Neuer Alias";
        const confirmBtn = document.createElement("button");
        confirmBtn.textContent = "✔";
        confirmBtn.className = "icon";
        const cancelBtn = document.createElement("button");
        cancelBtn.textContent = "✕";
        cancelBtn.className = "icon";
        addInline.appendChild(aliasInput);
        addInline.appendChild(confirmBtn);
        addInline.appendChild(cancelBtn);

        const toggleAdd = (show) => {
          addInline.classList.toggle("hidden", !show);
          if (show) { aliasInput.value = ""; aliasInput.focus(); }
        };

        addBtn.addEventListener("click", () => toggleAdd(true));
        cancelBtn.addEventListener("click", () => toggleAdd(false));
        aliasInput.addEventListener("keydown", (ev) => {
          if (ev.key === "Escape") { ev.preventDefault(); toggleAdd(false); }
          if (ev.key === "Enter") { ev.preventDefault(); confirmBtn.click(); }
        });
        const addAlias = () => {
          const alias = normalizePlayerName(aliasInput.value);
          if (!alias) return;
          if (canonicalNameJS(alias) === group.canonicalKey && alias === group.currentName) { toggleAdd(false); return; }
          group.aliases.add(alias);
          toggleAdd(false);
          renderGroups();
        };
        confirmBtn.addEventListener("click", addAlias);

        const chips = document.createElement("div");
        chips.style.display = "flex";
        chips.style.flexWrap = "wrap";
        chips.style.gap = "0.35rem";

        const aliases = Array.from(group.aliases).sort((a, b) => a.localeCompare(b, "de", { sensitivity: "base" }));
        if (!aliases.length) {
          const placeholder = document.createElement("span");
          placeholder.className = "group-meta";
          placeholder.textContent = "Keine Aliase";
          chips.appendChild(placeholder);
        } else {
          aliases.forEach(alias => {
            const chip = document.createElement("span");
            chip.className = "chip";
            chip.textContent = alias;
            const promoteBtn = document.createElement("button");
            promoteBtn.title = "Als Hauptnamen setzen";
            promoteBtn.textContent = "⭐";
            promoteBtn.addEventListener("click", () => {
              if (setCurrentName(group, alias)) renderGroups();
            });
            const removeBtn = document.createElement("button");
            removeBtn.title = "Alias entfernen";
            removeBtn.textContent = "✕";
            removeBtn.addEventListener("click", () => {
              group.aliases.delete(alias);
              renderGroups();
            });
            chip.appendChild(promoteBtn);
            chip.appendChild(removeBtn);
            chip.addEventListener("dblclick", () => moveAlias(alias, group.canonicalKey));
            chips.appendChild(chip);
          });
        }

        aliasLine.appendChild(chips);
        aliasLine.appendChild(addInline);
        row.appendChild(aliasLine);

        const duplicate = duplicateMap.get(group.canonicalKey);
        if (duplicate) {
          const hint = document.createElement("div");
          hint.className = "hint";
          const names = duplicate.groups.map(g => g.currentName).join(", ");
          hint.textContent = `⚠️ Diese Namen sehen gleich aus: ${names}`;
          const mergeBtn = document.createElement("button");
          mergeBtn.textContent = "Zusammenführen";
          mergeBtn.addEventListener("click", () => mergeGroups(duplicate.groups));
          hint.appendChild(mergeBtn);
          row.appendChild(hint);
        }

        elements.groupList.appendChild(row);
      });
      buildNameIndex();
    }

    function moveAlias(alias, fromKey) {
      const targets = Array.from(state.groups.values()).filter(g => g.canonicalKey !== fromKey);
      if (!targets.length) return;
      const choice = prompt("Zu welchem Hauptnamen verschieben?", targets[0].currentName);
      if (!choice) return;
      const match = targets.find(t => t.currentName === choice || t.canonicalLabel === choice || canonicalNameJS(t.currentName) === canonicalNameJS(choice));
      if (!match) { alert("Keine passende Gruppe gefunden."); return; }
      const from = state.groups.get(fromKey);
      from?.aliases.delete(alias);
      match.aliases.add(alias);
      renderGroups();
    }

    function buildDuplicateSuggestions() {
      const bucket = new Map();
      state.groups.forEach(group => {
        const allNames = [group.currentName, ...group.aliases];
        allNames.forEach(name => {
          const key = canonicalNameJS(name);
          if (!key) return;
          if (!bucket.has(key)) bucket.set(key, new Set());
          bucket.get(key).add(group.canonicalKey);
        });
      });
      const suggestions = [];
      bucket.forEach((owners, norm) => {
        if (owners.size <= 1) return;
        const involved = Array.from(owners).map(k => state.groups.get(k)).filter(Boolean);
        if (involved.length > 1) suggestions.push({ norm, groups: involved });
      });
      return suggestions;
    }

    function resolveGroupByQuery(rawQuery) {
      const query = (rawQuery || "").trim();
      if (!query) return null;
      const canon = canonicalNameJS(query);
      const lc = query.toLowerCase();
      return Array.from(state.groups.values()).find(g => {
        if (g.canonicalKey === query || g.canonicalKey === canon) return true;
        const names = [g.currentName, g.canonicalLabel, ...Array.from(g.aliases)];
        return names.some(name => {
          if (!name) return false;
          return canonicalNameJS(name) === canon || name.toLowerCase().includes(lc);
        });
      }) || null;
    }

    function attachPlayerAutocomplete(inputEl, { onCommit } = {}) {
      if (!inputEl) return null;
      const parent = inputEl.parentElement;
      if (parent && !parent.classList.contains("autocomplete-wrapper")) {
        parent.classList.add("autocomplete-wrapper");
      }
      const dropdown = document.createElement("div");
      dropdown.className = "autocomplete-menu";
      dropdown.style.display = "none";
      (parent || inputEl).appendChild(dropdown);

      let items = [];
      let activeIndex = -1;
      let blurTimer = null;

      const closeMenu = () => {
        dropdown.style.display = "none";
        dropdown.innerHTML = "";
        items = [];
        activeIndex = -1;
      };

      const commitValue = (value) => {
        inputEl.value = value;
        if (typeof onCommit === "function") onCommit(value);
        inputEl.dispatchEvent(new Event("input", { bubbles: true }));
        closeMenu();
      };

      const setActive = (nextIndex) => {
        activeIndex = nextIndex;
        Array.from(dropdown.children).forEach((child, idx) => {
          child.classList.toggle("active", idx === activeIndex);
        });
      };

      const renderList = (list) => {
        dropdown.innerHTML = "";
        list.forEach((name, idx) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "autocomplete-item";
          btn.textContent = name;
          btn.addEventListener("mousedown", (e) => { e.preventDefault(); commitValue(name); });
          btn.addEventListener("mousemove", () => setActive(idx));
          dropdown.appendChild(btn);
        });
        dropdown.style.display = list.length ? "block" : "none";
      };

      const updateList = () => {
        const term = inputEl.value || "";
        const trimmed = term.trim();
        if (!trimmed) { closeMenu(); return; }
        const maxItems = 16;
        const results = window.dsroShared?.queryPlayerNamesForAdmin
          ? window.dsroShared.queryPlayerNamesForAdmin(trimmed, maxItems)
          : Array.from(state.groups.values())
            .map(g => g.currentName)
            .filter(name => (name || "").toLowerCase().includes(trimmed.toLowerCase()))
            .slice(0, maxItems);
        items = results;
        renderList(items);
        setActive(items.length ? 0 : -1);
      };

      inputEl.addEventListener("input", updateList);
      inputEl.addEventListener("focus", updateList);
      inputEl.addEventListener("keydown", (e) => {
        if (e.key === "ArrowDown") {
          if (!items.length) updateList();
          if (items.length) { e.preventDefault(); setActive(activeIndex < items.length - 1 ? activeIndex + 1 : 0); }
        } else if (e.key === "ArrowUp") {
          if (!items.length) updateList();
          if (items.length) { e.preventDefault(); setActive(activeIndex > 0 ? activeIndex - 1 : items.length - 1); }
        } else if (e.key === "Enter") {
          if (items.length && activeIndex >= 0) { e.preventDefault(); commitValue(items[activeIndex]); }
        } else if (e.key === "Escape") {
          if (dropdown.style.display !== "none") { e.preventDefault(); closeMenu(); }
        }
      });

      inputEl.addEventListener("blur", () => {
        blurTimer = setTimeout(() => closeMenu(), 120);
      });
      dropdown.addEventListener("mousedown", () => { if (blurTimer) { clearTimeout(blurTimer); blurTimer = null; } });

      return { refresh: updateList, close: closeMenu };
    }

    function mergeGroups(groups) {
      if (!groups || groups.length < 2) return;
      const target = groups[0];
      for (let i = 1; i < groups.length; i += 1) {
        const donor = groups[i];
        donor.aliases.add(donor.currentName);
        donor.aliases.forEach(a => target.aliases.add(a));
        donor.rows.forEach(r => {
          r[state.playerNameField] = target.currentName;
          target.rows.push(r);
        });
        state.groups.delete(donor.canonicalKey);
      }
      renderGroups();
    }

    function deriveAllianceRows() {
      const rows = [];
      state.groups.forEach(group => {
        group.rows.forEach(row => {
          const clone = { ...row };
          clone[state.playerNameField] = group.currentName;
          clone.currentName = group.currentName;
          clone.canonicalKey = group.canonicalKey;
          rows.push(clone);
        });
      });
      return rows;
    }

    function buildAllianceCsv() {
      const derived = deriveAllianceRows();
      state.allianceRows = derived;
      return buildCsvFromRows(state.playerHeaders, derived);
    }

    function buildAliasCsv() {
      const headers = state.aliasHeaders && state.aliasHeaders.length ? state.aliasHeaders : [state.aliasCanonicalField, state.aliasAliasField];
      const rows = [];
      const nextAliasRows = [];
      state.groups.forEach(group => {
        const canon = group.canonicalLabel || group.currentName || group.canonicalKey;
        const ensureAlias = (alias) => {
          const row = {};
          headers.forEach(h => row[h] = "");
          row[state.aliasCanonicalField] = canon;
          row[state.aliasAliasField] = alias;
          rows.push(row);
          nextAliasRows.push({ canonical: canon, alias });
        };
        const allAliases = new Set(group.aliases);
        if (canonicalNameJS(group.currentName) !== group.canonicalKey) {
          allAliases.add(group.currentName);
        }
        allAliases.forEach(ensureAlias);
      });
      state.aliasRows = nextAliasRows;
      return buildCsvFromRows(headers, rows);
    }

    function handleSearchInput() {
      const match = resolveGroupByQuery(elements.searchInput.value);
      state.highlightedKey = match ? match.canonicalKey : "";
      renderGroups();
    }

    function toggleShowAll() {
      state.showAllPlayers = !state.showAllPlayers;
      elements.showAllToggle.textContent = state.showAllPlayers ? "Nur Alias-Gruppen anzeigen" : "Alle Spieler anzeigen";
      renderGroups();
    }

    async function saveChanges() {
      rememberSettings();
      const adminKey = window.dsroShared?.getAdminKey?.();
      if (!adminKey) { alert("Admin-Key fehlt – bitte einloggen."); return; }
      state.saving = true; elements.saveBtn.disabled = true; setStatus("Speichere…", "info");
      const allianceCsv = buildAllianceCsv();
      const aliasesCsv = buildAliasCsv();
      const branch = elements.branchInput.value.trim() || "main";
      const workerUrl = elements.workerUrl.value.trim();
      const headers = window.dsroShared.buildAdminHeaders({ adminKey, headers: { "Content-Type": "application/json" } });
      const payload = async (path, content) => {
        const res = await fetch(workerUrl, { method: "POST", headers, body: JSON.stringify({ path, content, branch }) });
        const json = await res.json().catch(() => ({}));
        if (!res.ok || !json.ok) throw new Error(json.error || json.detail || `Schreiben fehlgeschlagen (${path})`);
      };
      try {
        await payload("data/alliance.csv", allianceCsv);
        await payload("data/aliases.csv", aliasesCsv);
        setStatus("Gespeichert.", "ok");
      } catch (err) {
        console.error(err);
        setStatus(err.message || "Speichern fehlgeschlagen", "error");
      } finally {
        state.saving = false; elements.saveBtn.disabled = false;
      }
    }

    async function reloadData() {
      state.loading = true; elements.reloadBtn.disabled = true; elements.saveBtn.disabled = true; setStatus("Lade…", "info");
      try {
        state.highlightedKey = "";
        state.showAllPlayers = false;
        if (elements.showAllToggle) elements.showAllToggle.textContent = "Alle Spieler anzeigen";
        if (elements.searchInput) elements.searchInput.value = "";
        state.groups.clear();
        await loadAlliance();
        await loadAliases();
        rebuildGroupsFromAlliance();
        renderGroups();
        setStatus(`Geladen (${state.groups.size} Gruppen).`, "ok");
      } catch (err) {
        console.error(err);
        setStatus(err.message || "Laden fehlgeschlagen", "error");
      } finally {
        state.loading = false; elements.reloadBtn.disabled = false; elements.saveBtn.disabled = false;
      }
    }

    function init() {
      restoreSettings();
      const auto = attachPlayerAutocomplete(elements.searchInput, {
        onCommit: (value) => {
          const match = resolveGroupByQuery(value);
          state.highlightedKey = match ? match.canonicalKey : "";
        },
      });
      elements.searchInput.addEventListener("input", handleSearchInput);
      elements.showAllToggle.addEventListener("click", toggleShowAll);
      elements.reloadBtn.addEventListener("click", reloadData);
      elements.saveBtn.addEventListener("click", saveChanges);
      reloadData();
    }

    init();
  </script>
</body>
</html>
