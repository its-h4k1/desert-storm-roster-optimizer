<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex, nofollow">
  <title>Spieler & Aliase verwalten</title>
  <link rel="stylesheet" href="admin.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    :root {
      --card-bg: #fff;
      --muted: #6b7280;
      --border: rgba(15, 23, 42, 0.08);
      --pill: #0b63f6;
      --row-bg: rgba(255, 255, 255, 0.8);
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }

    .page-shell { display: grid; gap: 1rem; }

    .page-header {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 0.9rem;
      padding: 1rem 1.1rem;
      display: grid;
      gap: 0.75rem;
      box-shadow: 0 12px 26px rgba(15, 23, 42, 0.08);
    }

    .header-top { display: flex; gap: 0.75rem; align-items: flex-start; flex-wrap: wrap; }
    .title-block { display: grid; gap: 0.3rem; }
    .eyebrow { margin: 0; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.04em; font-size: 0.85rem; }
    .page-header h2 { margin: 0; font-size: 1.5rem; }
    .lede { margin: 0; color: var(--muted); }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      background: var(--panel-muted);
      border: 1px solid var(--border);
      color: var(--muted);
      margin-left: auto;
      font-weight: 600;
    }
    .status-pill.ok { background: #dcfce7; border-color: #bbf7d0; color: #166534; }
    .status-pill.error { background: #fee2e2; border-color: #fecaca; color: #991b1b; }
    .status-pill.info { background: var(--panel-muted); color: var(--muted); }
    .status-dot { width: 10px; height: 10px; border-radius: 999px; background: currentColor; box-shadow: 0 0 0 3px rgba(255,255,255,0.7); }

    .toolbar { display: flex; flex-wrap: wrap; gap: 0.65rem; align-items: center; }
    .toolbar .search { flex: 1; min-width: 220px; }
    .toolbar-actions { display: inline-flex; gap: 0.45rem; flex-wrap: wrap; align-items: center; }

    label {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      font-size: 0.9rem;
      color: var(--muted);
    }

    input[type="text"], input[type="search"] {
      font: inherit;
      padding: 0.45rem 0.65rem;
      border-radius: 0.55rem;
      border: 1px solid var(--border);
      background: var(--bg-alt);
      color: var(--text);
      min-width: 12rem;
    }

    button {
      font: inherit;
      border-radius: 0.55rem;
      border: 1px solid var(--border);
      background: #fff;
      color: var(--text);
      padding: 0.45rem 0.85rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    button.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
    button.ghost { background: transparent; border-color: transparent; color: var(--accent); }
    button.icon { padding: 0.35rem 0.45rem; border-color: transparent; background: transparent; }
    button[disabled] { opacity: 0.6; cursor: not-allowed; }

    .advanced { border: 1px solid var(--border); border-radius: 0.85rem; background: var(--panel-muted); padding: 0.4rem 0.6rem; }
    .advanced summary { list-style: none; cursor: pointer; display: inline-flex; align-items: center; gap: 0.45rem; color: var(--muted); font-weight: 700; }
    .advanced summary::-webkit-details-marker { display: none; }
    .advanced .settings-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 0.65rem; padding: 0.4rem 0.35rem 0.2rem; }
    .advanced small { color: var(--muted); }

    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 0.85rem 1rem;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
    }

    .list-empty {
      color: var(--muted);
      text-align: center;
      padding: 1rem;
      border: 1px dashed var(--border);
      border-radius: 0.55rem;
    }

    .autocomplete-menu { display: flex; flex-wrap: wrap; gap: 0.35rem; padding: 0.35rem; }
    .autocomplete-item { flex: 0 0 auto; }

    .group-list { display: grid; gap: 0.6rem; }

    .group-row {
      display: grid;
      gap: 0.25rem;
      padding: 0.65rem 0.75rem;
      border-radius: 0.55rem;
      border: 1px solid var(--border);
      background: var(--row-bg);
      box-shadow: 0 6px 14px rgba(15, 23, 42, 0.06);
    }

    .group-head {
      display: flex;
      align-items: center;
      gap: 0.45rem;
    }

    .group-title { display: flex; align-items: baseline; gap: 0.35rem; flex: 1; min-width: 0; }
    .group-name { font-weight: 700; font-size: 1rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .group-meta { color: var(--muted); font-size: 0.9rem; }

    .group-actions { display: inline-flex; gap: 0.15rem; }

    .alias-line { display: flex; align-items: center; gap: 0.4rem; flex-wrap: wrap; }
    .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 0.75rem; }
    .form-error { margin-top: 0.35rem; color: #b91c1c; font-weight: 600; }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.06);
      font-weight: 600;
    }
    .chip button { border: none; background: transparent; padding: 0.1rem 0.25rem; color: var(--muted); }
    .chip button:hover { color: var(--text); }

    .inline-input { display: inline-flex; gap: 0.35rem; align-items: center; }
    .inline-input input { padding: 0.35rem 0.55rem; border-radius: 0.45rem; border: 1px solid var(--border); }

    .hint {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: #b45309;
      background: rgba(251, 191, 36, 0.12);
      border: 1px solid rgba(251, 191, 36, 0.4);
      padding: 0.45rem 0.55rem;
      border-radius: 0.5rem;
      font-size: 0.9rem;
    }

    .hint button { border-color: transparent; background: transparent; color: #b45309; font-weight: 700; }

    @media (max-width: 960px) {
      .group-head { flex-wrap: wrap; }
      .group-actions { width: 100%; justify-content: flex-start; }
    }
  </style>
</head>
<body>
  <div class="admin-shell">
    <aside class="admin-sidebar">
      <div class="admin-sidebar-header">
        <div class="admin-logo">ELT Admin</div>
        <button class="sidebar-close" aria-label="Navigation schließen">✕</button>
      </div>
      <nav class="admin-nav">
        <a href="index.html">CSV &amp; Datei-Tools</a>
        <a href="events.html">Events erfassen</a>
        <a href="players.html" class="active">Spieler &amp; Aliase</a>
        <a href="absences.html">Absenzen</a>
        <a href="event-assignments.html">Event-Zusagen</a>
        <a href="noshow-dashboard.html">No-Show Analyse</a>
        <a href="reliability.html">Reliability</a>
      </nav>
    </aside>

    <div class="admin-main">
      <header class="admin-header">
        <button class="sidebar-toggle" aria-label="Navigation öffnen">☰</button>
        <div class="page-title">
          <p>Spieler &amp; Aliase</p>
          <h1>Alias-Gruppen verwalten</h1>
        </div>
        <div class="admin-header-actions">
          <div class="admin-header-tools">
            <div class="admin-status-line">
              <div id="adminKeyStatus" class="pill info">Admin-Key wird geprüft…</div>
            </div>
            <details id="adminSettings" class="admin-settings">
              <summary>⚙️ Einstellungen</summary>
              <div class="admin-settings-grid">
                <label>Worker URL
                  <input id="workerUrl" type="text" value="https://ds-commit.hak1.workers.dev/write-file" spellcheck="false">
                  <small>Ändern nur falls der Schreib-Worker gewechselt wird.</small>
                </label>
                <label>Branch
                  <input id="branchInput" type="text" value="main" spellcheck="false">
                  <small>Ziel-Branch für Schreiboperationen.</small>
                </label>
                <div id="adminKeyFallbackRow" style="display:none;">
                  <label style="margin:0;">Admin-Key (Fallback)
                    <input id="adminKeyFallback" type="password" placeholder="Optional – zentral gespeichert" autocomplete="off">
                  </label>
                  <div class="admin-settings-actions" style="margin-top:0.35rem;justify-content:flex-start;">
                    <button id="adminKeyFallbackBtn" type="button">Admin-Key übernehmen</button>
                  </div>
                </div>
              </div>
            </details>
            <a class="btn ghost" href="../index.html">Zur Roster-Ansicht</a>
          </div>
        </div>
      </header>

      <main class="admin-content">
        <div class="page-shell">
          <section class="page-header">
            <div class="header-top">
              <div class="title-block">
                <p class="eyebrow">Admin · Aliase</p>
                <h2>Alias-Gruppen</h2>
                <p class="lede">Pflegt <code>data/alliance.csv</code> und <code>data/aliases.csv</code> mit stabilen kanonischen IDs.</p>
              </div>
              <div class="status-pill info" id="statusBar">
                <span class="status-dot"></span>
                <span id="statusText">Bereit</span>
              </div>
            </div>
            <div class="toolbar">
              <label class="search">Spieler suchen
                <input id="searchInput" type="search" placeholder="Name suchen…" autocomplete="off">
              </label>
              <div class="toolbar-actions">
                <button id="showAllToggle" class="ghost" type="button">Alle Spieler anzeigen</button>
                <button id="reloadBtn" class="ghost" type="button">Neu laden</button>
                <button id="saveBtn" class="primary" type="button">Speichern</button>
              </div>
            </div>
          </section>

          <section class="card" id="createPlayerCard">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:0.5rem;flex-wrap:wrap;">
              <h3 style="margin:0">Neuen Spieler anlegen</h3>
              <small class="group-meta">Speichert direkt per CSV-Write</small>
            </div>
            <div class="form-grid" style="margin-top:0.65rem;">
              <label>Spielername
                <input id="newPlayerName" type="text" placeholder="z.B. Max Muster" autocomplete="off">
              </label>
              <label>Aliase (optional)
                <textarea id="newPlayerAliases" rows="2" placeholder="Komma oder Zeilenumbruch"></textarea>
              </label>
            </div>
            <div style="display:flex;align-items:center;gap:0.5rem;flex-wrap:wrap;margin-top:0.65rem;">
              <button id="createPlayerBtn" class="primary" type="button">Anlegen</button>
              <small id="createPlayerHint" class="group-meta"></small>
            </div>
            <div id="createPlayerError" class="form-error" aria-live="assertive"></div>
          </section>

          <section class="card">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:0.5rem;flex-wrap:wrap;">
              <h3 style="margin:0">Gruppen</h3>
              <small class="group-meta">Inline bearbeiten &amp; speichern</small>
            </div>
            <div id="groupList" class="group-list"></div>
            <div id="groupEmpty" class="list-empty">Noch keine Spieler geladen.</div>
          </section>
        </div>
      </main>
    </div>
  </div>
  <div class="admin-overlay"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="../shared.js"></script>
  <script src="admin.js"></script>
  <script>
    const repoOwner = "its-h4k1";
    const repoName = "desert-storm-roster-optimizer";
    const defaultBranch = "main";
    const SETTINGS_KEY = "dsro-player-admin-settings";
    const canonicalNameJS = (window.dsroShared && typeof window.dsroShared.canonicalNameJS === "function")
      ? window.dsroShared.canonicalNameJS
      : (v => (v || "").toString().trim().toLowerCase());
    const normalizePlayerName = (v) => (window.dsroShared?.normalizePlayerName?.(v) || (v || "").toString().trim());
    const resolvePlayerDisplayName =
      (window.dsroShared && typeof window.dsroShared.resolvePlayerDisplayName === "function")
        ? window.dsroShared.resolvePlayerDisplayName
        : (name) => normalizePlayerName(name);

    const state = {
      playerHeaders: [],
      playerNameField: "PlayerName",
      allianceRows: [],
      aliasHeaders: ["Canonical", "Alias"],
      aliasCanonicalField: "Canonical",
      aliasAliasField: "Alias",
      aliasRows: [],
      groups: new Map(),
      originalAllianceCsv: "",
      originalAliasesCsv: "",
      loading: false,
      saving: false,
      showAllPlayers: false,
      highlightedKey: "",
    };

    const elements = {
      groupList: document.getElementById("groupList"),
      groupEmpty: document.getElementById("groupEmpty"),
      workerUrl: document.getElementById("workerUrl"),
      branchInput: document.getElementById("branchInput"),
      adminSettings: document.getElementById("adminSettings"),
      adminKeyStatus: document.getElementById("adminKeyStatus"),
      adminKeyFallbackRow: document.getElementById("adminKeyFallbackRow"),
      adminKeyFallback: document.getElementById("adminKeyFallback"),
      adminKeyFallbackBtn: document.getElementById("adminKeyFallbackBtn"),
      searchInput: document.getElementById("searchInput"),
      showAllToggle: document.getElementById("showAllToggle"),
      reloadBtn: document.getElementById("reloadBtn"),
      saveBtn: document.getElementById("saveBtn"),
      statusText: document.getElementById("statusText"),
      newPlayerName: document.getElementById("newPlayerName"),
      newPlayerAliases: document.getElementById("newPlayerAliases"),
      createPlayerBtn: document.getElementById("createPlayerBtn"),
      createPlayerError: document.getElementById("createPlayerError"),
      createPlayerHint: document.getElementById("createPlayerHint"),
    };

    const openAdminSettings = () => {
      if (elements.adminSettings) elements.adminSettings.open = true;
    };
    const closeAdminSettings = () => {
      if (elements.adminSettings) elements.adminSettings.open = false;
    };

    function buildNameIndex() {
      const names = [];
      state.groups.forEach(group => {
        if (group.currentName) names.push(group.currentName);
        if (group.canonicalLabel) names.push(group.canonicalLabel);
        group.aliases.forEach(a => names.push(a));
      });
      if (window.dsroShared?.refreshAdminPlayerIndex) {
        window.dsroShared.refreshAdminPlayerIndex({ additionalNames: names });
      }
    }

    function setCurrentName(group, nextName) {
      const next = normalizePlayerName(nextName);
      if (!group || !next || next === group.currentName) return false;
      const previous = group.currentName;
      if (previous) group.aliases.add(previous);
      group.aliases.delete(next);
      group.currentName = next;
      return true;
    }

    function normalizeLineEndings(text) { return (text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n"); }
    function ensureTrailingNewline(text) { if (!text) return "\n"; return /\n$/.test(text) ? text : text + "\n"; }
    function formatCsvValue(value) {
      if (value === null || value === undefined) return "";
      const str = value.toString();
      if (/["\n,]/.test(str)) return `"${str.replace(/"/g, '""')}"`;
      return str;
    }
    function buildCsvFromRows(headers, rows) {
      const headerLine = headers.join(",");
      const lines = rows.map(row => headers.map(h => formatCsvValue(row[h] ?? "")).join(","));
      return ensureTrailingNewline([headerLine, ...lines].join("\n"));
    }
    function detectNameField(headers) {
      if (!headers || !headers.length) return "PlayerName";
      const candidates = ["PlayerName", "DisplayName", "Canonical", "Name"];
      return headers.find(h => candidates.includes(h)) || headers[0];
    }
    function detectAliasField(headers, preferred) { return headers.find(h => preferred.includes(h)) || preferred[0]; }

    function setStatus(text, tone = "info") {
      elements.statusText.textContent = text;
      const pill = document.getElementById("statusBar");
      pill.classList.remove("ok", "error", "info");
      pill.classList.add(tone);
    }

    function renderAdminKeyStatus({ message, tone = "info", showAlert = false } = {}) {
      if (!elements.adminKeyStatus) return;
      const cls = tone === "success" ? "info" : tone;
      elements.adminKeyStatus.textContent = message || "";
      elements.adminKeyStatus.className = `pill ${cls}`.trim();
      if (elements.adminKeyFallbackRow) {
        elements.adminKeyFallbackRow.style.display = showAlert ? "block" : "none";
      }
      if (showAlert) {
        openAdminSettings();
      } else if (tone === "success") {
        closeAdminSettings();
      }
    }

    function setCreateError(message = "") {
      if (elements.createPlayerError) elements.createPlayerError.textContent = message || "";
    }

    function isDataLoaded() { return state.playerHeaders.length > 0 && state.originalAllianceCsv; }

    function updateCreateState() {
      const disabled = state.loading || state.saving || !isDataLoaded();
      if (elements.createPlayerBtn) elements.createPlayerBtn.disabled = disabled;
      if (elements.createPlayerHint) {
        elements.createPlayerHint.textContent = isDataLoaded() ? "" : "Erst neu laden, danach anlegen.";
      }
    }

      function buildCandidatePaths(path) {
        const clean = path.replace(/^\/+/, "");
        const prefixes = ["../../", "../", "./", ""];
        const candidates = prefixes.map(p => `${p}${clean}`.replace(/\/+/g, "/"));
        candidates.push(`https://raw.githubusercontent.com/${repoOwner}/${repoName}/${defaultBranch}/${clean}`);
        return candidates;
      }

    async function fetchFirstAvailable(urls) {
      for (const url of urls) {
        try {
          const res = await fetch(url, { cache: "no-store" });
          if (res.ok) return await res.text();
        } catch (err) {
          console.warn("Fetch fallback", url, err);
        }
      }
      throw new Error("Keine Quelle erreichbar");
    }

    function rememberSettings() {
      const payload = {
        workerUrl: elements.workerUrl.value.trim(),
        branch: elements.branchInput.value.trim(),
        adminKey: window.dsroShared?.getAdminKey?.() || "",
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(payload));
    }

    function restoreSettings() {
      const saved = localStorage.getItem(SETTINGS_KEY);
      if (!saved) return;
      try {
        const parsed = JSON.parse(saved);
        if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
        if (parsed.branch) elements.branchInput.value = parsed.branch;
        if (parsed.adminKey && window.dsroShared) window.dsroShared.saveAdminKey(parsed.adminKey);
      } catch (err) { console.warn("settings restore", err); }
    }

    function ensureGroup(canonicalKey, seedName) {
      let group = state.groups.get(canonicalKey);
      if (!group) {
        group = {
          canonicalKey,
          canonicalLabel: seedName || canonicalKey,
          currentName: seedName || canonicalKey,
          aliases: new Set(),
          rows: [],
        };
        state.groups.set(canonicalKey, group);
      }
      return group;
    }

    function findAliasOwner(aliasValue) {
      const key = canonicalNameJS(normalizePlayerName(aliasValue));
      if (!key) return null;
      for (const group of state.groups.values()) {
        const matchesCurrent = canonicalNameJS(group.currentName) === key;
        const matchesLabel = canonicalNameJS(group.canonicalLabel || "") === key;
        const matchesAlias = Array.from(group.aliases).some(a => canonicalNameJS(a) === key);
        if (matchesCurrent || matchesLabel || matchesAlias) return group;
      }
      return null;
    }

    function parseAliasInput(rawAliases, playerName) {
      const cleaned = normalizeLineEndings(rawAliases || "");
      const baseKey = canonicalNameJS(playerName);
      const tokens = cleaned.split(/[\n,]+/);
      const seen = new Set();
      const aliases = [];
      tokens.forEach(token => {
        const alias = normalizePlayerName(token);
        const aliasKey = canonicalNameJS(alias);
        if (!alias || !aliasKey) return;
        if (aliasKey === baseKey) return;
        if (seen.has(aliasKey)) return;
        seen.add(aliasKey);
        aliases.push(alias);
      });
      return aliases;
    }

    async function loadAlliance() {
      const text = await fetchFirstAvailable(buildCandidatePaths("data/alliance.csv"));
      state.originalAllianceCsv = ensureTrailingNewline(normalizeLineEndings(text));
      const parsed = Papa.parse(state.originalAllianceCsv, { header: true, skipEmptyLines: true });
      state.playerHeaders = parsed.meta.fields || [];
      state.playerNameField = detectNameField(state.playerHeaders);
      state.allianceRows = (parsed.data || []).map(row => {
        const safe = { ...row };
        Object.keys(safe).forEach(k => safe[k] = safe[k] === undefined || safe[k] === null ? "" : safe[k]);
        const currentName = normalizePlayerName(safe[state.playerNameField] || "");
        const canonicalKey = canonicalNameJS(currentName);
        const group = ensureGroup(canonicalKey, currentName);
        group.currentName = group.currentName || currentName;
        group.canonicalLabel = group.canonicalLabel || currentName;
        group.rows.push(safe);
        return { ...safe, canonicalKey, currentName };
      });
    }

    async function loadAliases() {
      try {
        const text = await fetchFirstAvailable(buildCandidatePaths("data/aliases.csv"));
        state.originalAliasesCsv = ensureTrailingNewline(normalizeLineEndings(text));
        const parsed = Papa.parse(state.originalAliasesCsv, { header: true, skipEmptyLines: true });
        state.aliasHeaders = parsed.meta.fields && parsed.meta.fields.length ? parsed.meta.fields : ["Canonical", "Alias"];
        state.aliasCanonicalField = detectAliasField(state.aliasHeaders, ["Canonical", "PlayerName", "Name"]);
        state.aliasAliasField = detectAliasField(state.aliasHeaders, ["Alias", "DisplayName"]);
        state.aliasRows = (parsed.data || []).map(row => ({
          canonical: normalizePlayerName(row[state.aliasCanonicalField] || ""),
          alias: normalizePlayerName(row[state.aliasAliasField] || ""),
        })).filter(r => r.canonical && r.alias);
        state.aliasRows.forEach(({ canonical, alias }) => {
          const canonKey = canonicalNameJS(canonical);
          const group = ensureGroup(canonKey, canonical);
          if (canonicalNameJS(alias) !== canonKey || alias !== group.currentName) {
            group.aliases.add(alias);
          }
        });
      } catch (err) {
        console.warn("aliases load", err);
        state.originalAliasesCsv = "Canonical,Alias\n";
        state.aliasHeaders = ["Canonical", "Alias"];
        state.aliasCanonicalField = "Canonical";
        state.aliasAliasField = "Alias";
        state.aliasRows = [];
      }
    }

    function rebuildGroupsFromAlliance() {
      const old = new Map(state.groups);
      state.groups = new Map();
      state.allianceRows.forEach(row => {
        const group = ensureGroup(row.canonicalKey, row.currentName);
        group.rows.push(row);
        if (!group.currentName) group.currentName = row.currentName;
        if (!group.canonicalLabel) group.canonicalLabel = row.currentName;
        const previous = old.get(row.canonicalKey);
        if (previous) {
          previous.aliases.forEach(a => group.aliases.add(a));
        }
      });
      state.aliasRows.forEach(({ canonical, alias }) => {
        const key = canonicalNameJS(canonical);
        const group = ensureGroup(key, canonical);
        group.aliases.add(alias);
      });
    }

    function renderGroups() {
      const query = elements.searchInput.value.trim();
      const queryCanon = canonicalNameJS(query);
      const queryLower = query.toLowerCase();
      const hasQuery = Boolean(query);
      const resolved = hasQuery ? resolveGroupByQuery(query) : null;
      const spotlightKey = state.highlightedKey || resolved?.canonicalKey || "";

      const duplicates = buildDuplicateSuggestions();
      const duplicateMap = new Map();
      duplicates.forEach(item => item.groups.forEach(g => duplicateMap.set(g.canonicalKey, item)));

      const allGroups = Array.from(state.groups.values());
      const filtered = allGroups.filter(g => {
        const hasAlias = g.aliases.size > 0;
        const matchesQuery = hasQuery && ([g.currentName, g.canonicalLabel, g.canonicalKey, ...Array.from(g.aliases)]
          .some(name => {
            if (!name) return false;
            const canon = canonicalNameJS(name);
            return name.toLowerCase().includes(queryLower) || canon === queryCanon;
          }));
        const spotlight = spotlightKey && spotlightKey === g.canonicalKey;
        const spotlightCluster = spotlightKey
          && duplicateMap.has(spotlightKey)
          && duplicateMap.get(spotlightKey).groups.some(item => item.canonicalKey === g.canonicalKey);

        if (!hasQuery && state.showAllPlayers) return true;
        if (!hasQuery) return hasAlias || spotlight;

        return matchesQuery || spotlight || spotlightCluster;
      }).sort((a, b) => a.currentName.localeCompare(b.currentName, "de", { sensitivity: "base" }));

      elements.groupList.innerHTML = "";
      elements.groupEmpty.classList.toggle("hidden", filtered.length > 0);
      if (!filtered.length) return;

      const makeInlineEdit = (group, container) => {
        container.innerHTML = "";
        const input = document.createElement("input");
        input.type = "text";
        input.value = group.currentName;
        input.autofocus = true;
        input.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter") {
            ev.preventDefault();
            if (setCurrentName(group, input.value)) renderGroups();
            else renderGroups();
          } else if (ev.key === "Escape") {
            ev.preventDefault();
            renderGroups();
          }
        });
        input.addEventListener("blur", () => renderGroups());
        container.appendChild(input);
        input.focus();
      };

      filtered.forEach(group => {
        const row = document.createElement("div");
        row.className = "group-row";

        const head = document.createElement("div");
        head.className = "group-head";
        const title = document.createElement("div");
        title.className = "group-title";
        const nameSlot = document.createElement("div");
        nameSlot.className = "group-name";
        const displayName = resolvePlayerDisplayName(group.currentName || group.canonicalLabel);
        nameSlot.textContent = displayName;
        title.appendChild(nameSlot);
        const meta = document.createElement("span");
        meta.className = "group-meta";
        meta.textContent = `${group.rows.length} Datensätze · ${group.aliases.size} Aliase`;
        title.appendChild(meta);
        head.appendChild(title);

        const actions = document.createElement("div");
        actions.className = "group-actions";
        const editBtn = document.createElement("button");
        editBtn.className = "icon";
        editBtn.title = "Hauptname bearbeiten";
        editBtn.textContent = "✏️";
        editBtn.addEventListener("click", () => makeInlineEdit(group, nameSlot));

        const addBtn = document.createElement("button");
        addBtn.className = "icon";
        addBtn.title = "Alias hinzufügen";
        addBtn.textContent = "➕";

        actions.appendChild(editBtn);
        actions.appendChild(addBtn);
        head.appendChild(actions);
        row.appendChild(head);

        const aliasLine = document.createElement("div");
        aliasLine.className = "alias-line";

        const addInline = document.createElement("div");
        addInline.className = "inline-input hidden";
        const aliasInput = document.createElement("input");
        aliasInput.type = "text";
        aliasInput.placeholder = "Neuer Alias";
        const confirmBtn = document.createElement("button");
        confirmBtn.textContent = "✔";
        confirmBtn.className = "icon";
        const cancelBtn = document.createElement("button");
        cancelBtn.textContent = "✕";
        cancelBtn.className = "icon";
        addInline.appendChild(aliasInput);
        addInline.appendChild(confirmBtn);
        addInline.appendChild(cancelBtn);

        const toggleAdd = (show) => {
          addInline.classList.toggle("hidden", !show);
          if (show) { aliasInput.value = ""; aliasInput.focus(); }
        };

        addBtn.addEventListener("click", () => toggleAdd(true));
        cancelBtn.addEventListener("click", () => toggleAdd(false));
        aliasInput.addEventListener("keydown", (ev) => {
          if (ev.key === "Escape") { ev.preventDefault(); toggleAdd(false); }
          if (ev.key === "Enter") { ev.preventDefault(); confirmBtn.click(); }
        });
        const addAlias = () => {
          const alias = normalizePlayerName(aliasInput.value);
          if (!alias) return;
          if (canonicalNameJS(alias) === group.canonicalKey && alias === group.currentName) { toggleAdd(false); return; }
          group.aliases.add(alias);
          toggleAdd(false);
          renderGroups();
        };
        confirmBtn.addEventListener("click", addAlias);

        const chips = document.createElement("div");
        chips.style.display = "flex";
        chips.style.flexWrap = "wrap";
        chips.style.gap = "0.35rem";

        const aliases = Array.from(group.aliases).sort((a, b) => a.localeCompare(b, "de", { sensitivity: "base" }));
        if (!aliases.length) {
          const placeholder = document.createElement("span");
          placeholder.className = "group-meta";
          placeholder.textContent = "Keine Aliase";
          chips.appendChild(placeholder);
        } else {
          aliases.forEach(alias => {
            const chip = document.createElement("span");
            chip.className = "chip";
            chip.textContent = resolvePlayerDisplayName(alias);
            const promoteBtn = document.createElement("button");
            promoteBtn.title = "Als Hauptnamen setzen";
            promoteBtn.textContent = "⭐";
            promoteBtn.addEventListener("click", () => {
              if (setCurrentName(group, alias)) renderGroups();
            });
            const removeBtn = document.createElement("button");
            removeBtn.title = "Alias entfernen";
            removeBtn.textContent = "✕";
            removeBtn.addEventListener("click", () => {
              group.aliases.delete(alias);
              renderGroups();
            });
            chip.appendChild(promoteBtn);
            chip.appendChild(removeBtn);
            chip.addEventListener("dblclick", () => moveAlias(alias, group.canonicalKey));
            chips.appendChild(chip);
          });
        }

        aliasLine.appendChild(chips);
        aliasLine.appendChild(addInline);
        row.appendChild(aliasLine);

        const duplicate = duplicateMap.get(group.canonicalKey);
        if (duplicate) {
          const hint = document.createElement("div");
          hint.className = "hint";
          const names = duplicate.groups
            .map(g => resolvePlayerDisplayName(g.currentName || g.canonicalLabel))
            .join(", ");
          hint.textContent = `⚠️ Diese Namen sehen gleich aus: ${names}`;
          const mergeBtn = document.createElement("button");
          mergeBtn.textContent = "Zusammenführen";
          mergeBtn.addEventListener("click", () => mergeGroups(duplicate.groups));
          hint.appendChild(mergeBtn);
          row.appendChild(hint);
        }

        elements.groupList.appendChild(row);
      });
      buildNameIndex();
    }

    function moveAlias(alias, fromKey) {
      const targets = Array.from(state.groups.values()).filter(g => g.canonicalKey !== fromKey);
      if (!targets.length) return;
      const choice = prompt("Zu welchem Hauptnamen verschieben?", targets[0].currentName);
      if (!choice) return;
      const match = targets.find(t => t.currentName === choice || t.canonicalLabel === choice || canonicalNameJS(t.currentName) === canonicalNameJS(choice));
      if (!match) { alert("Keine passende Gruppe gefunden."); return; }
      const from = state.groups.get(fromKey);
      from?.aliases.delete(alias);
      match.aliases.add(alias);
      renderGroups();
    }

    function buildVisualKey(value) {
      const canon = canonicalNameJS(value || "");
      const digitFold = canon.replace(/[01]/g, ch => (ch === "0" ? "o" : "l"))
        .replace(/[3]/g, "e")
        .replace(/[4]/g, "a")
        .replace(/[5]/g, "s")
        .replace(/[7]/g, "t")
        .replace(/[8]/g, "b");
      return digitFold.replace(/[^a-z0-9]/g, "");
    }

    function levenshtein(a, b) {
      const s = buildVisualKey(a);
      const t = buildVisualKey(b);
      if (!s || !t) return Number.MAX_SAFE_INTEGER;
      if (s === t) return 0;
      const dp = Array.from({ length: s.length + 1 }, () => new Array(t.length + 1).fill(0));
      for (let i = 0; i <= s.length; i += 1) dp[i][0] = i;
      for (let j = 0; j <= t.length; j += 1) dp[0][j] = j;
      for (let i = 1; i <= s.length; i += 1) {
        for (let j = 1; j <= t.length; j += 1) {
          const cost = s[i - 1] === t[j - 1] ? 0 : 1;
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + cost,
          );
        }
      }
      return dp[s.length][t.length];
    }

    function looksSimilar(a, b) {
      const keyA = buildVisualKey(a);
      const keyB = buildVisualKey(b);
      if (!keyA || !keyB) return false;
      if (keyA === keyB) return true;
      const distance = levenshtein(keyA, keyB);
      const maxLen = Math.max(keyA.length, keyB.length);
      return distance <= 1 || (maxLen >= 5 && distance <= 2);
    }

    function collectNames(group) {
      return [group.currentName, group.canonicalLabel, ...group.aliases].filter(Boolean);
    }

    function buildDuplicateSuggestions() {
      const bucket = new Map();
      const visualBucket = new Map();
      state.groups.forEach(group => {
        const allNames = collectNames(group);
        allNames.forEach(name => {
          const canonKey = canonicalNameJS(name);
          if (canonKey) {
            if (!bucket.has(canonKey)) bucket.set(canonKey, new Set());
            bucket.get(canonKey).add(group.canonicalKey);
          }
          const visual = buildVisualKey(name);
          if (visual) {
            if (!visualBucket.has(visual)) visualBucket.set(visual, new Set());
            visualBucket.get(visual).add(group.canonicalKey);
          }
        });
      });

      const suggestions = [];
      const seenPairs = new Set();
      const register = owners => {
        if (owners.size <= 1) return;
        const involved = Array.from(owners).map(k => state.groups.get(k)).filter(Boolean);
        if (involved.length < 2) return;
        const key = involved.map(g => g.canonicalKey).sort().join("::");
        if (seenPairs.has(key)) return;
        seenPairs.add(key);
        suggestions.push({ groups: involved });
      };

      bucket.forEach(register);
      visualBucket.forEach(register);

      const groups = Array.from(state.groups.values());
      for (let i = 0; i < groups.length; i += 1) {
        for (let j = i + 1; j < groups.length; j += 1) {
          const leftNames = collectNames(groups[i]);
          const rightNames = collectNames(groups[j]);
          const similar = leftNames.some(ln => rightNames.some(rn => looksSimilar(ln, rn)));
          if (similar) register(new Set([groups[i].canonicalKey, groups[j].canonicalKey]));
        }
      }

      return suggestions;
    }

    function resolveGroupByQuery(rawQuery) {
      const query = (rawQuery || "").trim();
      if (!query) return null;
      const canon = canonicalNameJS(query);
      const lc = query.toLowerCase();
      return Array.from(state.groups.values()).find(g => {
        if (g.canonicalKey === query || g.canonicalKey === canon) return true;
        const names = [g.currentName, g.canonicalLabel, ...Array.from(g.aliases)];
        return names.some(name => {
          if (!name) return false;
          return canonicalNameJS(name) === canon || name.toLowerCase().includes(lc);
        });
      }) || null;
    }

    function attachPlayerAutocomplete(inputEl, { onCommit } = {}) {
      if (!inputEl) return null;
      const parent = inputEl.parentElement;
      if (parent && !parent.classList.contains("autocomplete-wrapper")) {
        parent.classList.add("autocomplete-wrapper");
      }
      const dropdown = document.createElement("div");
      dropdown.className = "autocomplete-menu";
      dropdown.style.display = "none";
      (parent || inputEl).appendChild(dropdown);

      let items = [];
      let activeIndex = -1;
      let blurTimer = null;

      const closeMenu = () => {
        dropdown.style.display = "none";
        dropdown.innerHTML = "";
        items = [];
        activeIndex = -1;
      };

      const commitValue = (value) => {
        inputEl.value = value;
        if (typeof onCommit === "function") onCommit(value);
        inputEl.dispatchEvent(new Event("input", { bubbles: true }));
        closeMenu();
      };

      const setActive = (nextIndex) => {
        activeIndex = nextIndex;
        Array.from(dropdown.children).forEach((child, idx) => {
          child.classList.toggle("active", idx === activeIndex);
        });
      };

      const renderList = (list) => {
        dropdown.innerHTML = "";
        list.forEach((name, idx) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "autocomplete-item";
          btn.textContent = name;
          btn.addEventListener("mousedown", (e) => { e.preventDefault(); commitValue(name); });
          btn.addEventListener("mousemove", () => setActive(idx));
          dropdown.appendChild(btn);
        });
        dropdown.style.display = list.length ? "block" : "none";
      };

      const updateList = () => {
        const term = inputEl.value || "";
        const trimmed = term.trim();
        if (!trimmed) { closeMenu(); return; }
        const maxItems = 16;
        const results = window.dsroShared?.queryPlayerNamesForAdmin
          ? window.dsroShared.queryPlayerNamesForAdmin(trimmed, maxItems)
          : Array.from(state.groups.values())
            .map(g => resolvePlayerDisplayName(g.currentName || g.canonicalLabel))
            .filter(name => (name || "").toLowerCase().includes(trimmed.toLowerCase()))
            .slice(0, maxItems);
        items = results;
        renderList(items);
        setActive(items.length ? 0 : -1);
      };

      inputEl.addEventListener("input", updateList);
      inputEl.addEventListener("focus", updateList);
      inputEl.addEventListener("keydown", (e) => {
        if (e.key === "ArrowDown") {
          if (!items.length) updateList();
          if (items.length) { e.preventDefault(); setActive(activeIndex < items.length - 1 ? activeIndex + 1 : 0); }
        } else if (e.key === "ArrowUp") {
          if (!items.length) updateList();
          if (items.length) { e.preventDefault(); setActive(activeIndex > 0 ? activeIndex - 1 : items.length - 1); }
        } else if (e.key === "Enter") {
          if (items.length && activeIndex >= 0) { e.preventDefault(); commitValue(items[activeIndex]); }
        } else if (e.key === "Escape") {
          if (dropdown.style.display !== "none") { e.preventDefault(); closeMenu(); }
        }
      });

      inputEl.addEventListener("blur", () => {
        blurTimer = setTimeout(() => closeMenu(), 120);
      });
      dropdown.addEventListener("mousedown", () => { if (blurTimer) { clearTimeout(blurTimer); blurTimer = null; } });

      return { refresh: updateList, close: closeMenu };
    }

    function mergeGroups(groups) {
      if (!groups || groups.length < 2) return;
      const target = groups[0];
      const addAlias = (alias) => {
        const normalized = normalizePlayerName(alias);
        if (normalized && normalized !== target.currentName) target.aliases.add(normalized);
      };
      for (let i = 1; i < groups.length; i += 1) {
        const donor = groups[i];
        addAlias(donor.currentName);
        addAlias(donor.canonicalLabel);
        donor.aliases.forEach(addAlias);
        donor.rows.forEach(r => {
          r[state.playerNameField] = target.currentName;
          r.canonicalKey = target.canonicalKey;
          target.rows.push(r);
        });
        state.groups.delete(donor.canonicalKey);
      }
      renderGroups();
    }

    function deriveAllianceRows() {
      const rows = [];
      state.groups.forEach(group => {
        group.rows.forEach(row => {
          const clone = { ...row };
          clone[state.playerNameField] = group.currentName;
          clone.currentName = group.currentName;
          clone.canonicalKey = group.canonicalKey;
          rows.push(clone);
        });
      });
      return rows;
    }

    function buildAllianceCsv() {
      const derived = deriveAllianceRows();
      state.allianceRows = derived;
      return buildCsvFromRows(state.playerHeaders, derived);
    }

    function buildAliasCsv() {
      const headers = state.aliasHeaders && state.aliasHeaders.length ? state.aliasHeaders : [state.aliasCanonicalField, state.aliasAliasField];
      const rows = [];
      const nextAliasRows = [];
      state.groups.forEach(group => {
        const canon = group.canonicalLabel || group.currentName || group.canonicalKey;
        const ensureAlias = (alias) => {
          const row = {};
          headers.forEach(h => row[h] = "");
          row[state.aliasCanonicalField] = canon;
          row[state.aliasAliasField] = alias;
          rows.push(row);
          nextAliasRows.push({ canonical: canon, alias });
        };
        const allAliases = new Set(group.aliases);
        if (canonicalNameJS(group.currentName) !== group.canonicalKey) {
          allAliases.add(group.currentName);
        }
        allAliases.forEach(ensureAlias);
      });
      state.aliasRows = nextAliasRows;
      return buildCsvFromRows(headers, rows);
    }

    function handleSearchInput() {
      const match = resolveGroupByQuery(elements.searchInput.value);
      state.highlightedKey = match ? match.canonicalKey : "";
      renderGroups();
    }

    function toggleShowAll() {
      state.showAllPlayers = !state.showAllPlayers;
      elements.showAllToggle.textContent = state.showAllPlayers ? "Nur Alias-Gruppen anzeigen" : "Alle Spieler anzeigen";
      renderGroups();
    }

    function buildNewAllianceRow(name, canonicalKey) {
      const headers = state.playerHeaders && state.playerHeaders.length ? state.playerHeaders : [state.playerNameField];
      const row = {};
      headers.forEach(h => { row[h] = ""; });
      row[state.playerNameField] = name;
      if (headers.includes("InAlliance")) row.InAlliance = "1";
      if (headers.includes("Note")) row.Note = row.Note ?? "";
      row.canonicalKey = canonicalKey;
      row.currentName = name;
      return row;
    }

    function applyNewPlayerFocus(canonicalKey, name) {
      state.showAllPlayers = true;
      if (elements.showAllToggle) elements.showAllToggle.textContent = "Nur Alias-Gruppen anzeigen";
      state.highlightedKey = canonicalKey;
      if (elements.searchInput) elements.searchInput.value = name;
      renderGroups();
    }

    async function createPlayer() {
      setCreateError("");
      if (!isDataLoaded()) { setCreateError("CSV noch nicht geladen – bitte zuerst Neu laden."); return; }
      if (state.loading || state.saving) return;

      const newName = normalizePlayerName(elements.newPlayerName?.value || "");
      if (!newName) { setCreateError("Spielername darf nicht leer sein."); return; }
      const newKey = canonicalNameJS(newName);

      if (state.groups.has(newKey)) { setCreateError("Spieler existiert bereits."); return; }
      const nameCollision = Array.from(state.groups.values())
        .find(g => (g.currentName || "").toLowerCase() === newName.toLowerCase());
      if (nameCollision) { setCreateError("Spieler existiert bereits."); return; }

      const aliases = parseAliasInput(elements.newPlayerAliases?.value || "", newName);
      for (const alias of aliases) {
        const owner = findAliasOwner(alias);
        if (owner) {
          const ownerName = resolvePlayerDisplayName(owner.currentName || owner.canonicalLabel || owner.canonicalKey);
          setCreateError(`Alias '${alias}' existiert bereits bei '${ownerName}'`);
          return;
        }
      }

      const adminKey = window.dsroShared?.getAdminKey?.();
      if (!adminKey) {
        alert("Admin-Key fehlt – bitte einloggen.");
        renderAdminKeyStatus({ message: "Admin-Key fehlt.", tone: "warn", showAlert: true });
        setCreateError("Admin-Key fehlt.");
        return;
      }

      rememberSettings();
      state.saving = true; elements.saveBtn.disabled = true; updateCreateState(); setStatus("Speichere neuen Spieler…", "info");

      const prevGroups = state.groups;
      const prevAllianceRows = state.allianceRows;
      const nextGroups = new Map(state.groups);
      const newGroup = {
        canonicalKey: newKey,
        canonicalLabel: newName,
        currentName: newName,
        aliases: new Set(),
        rows: [],
      };
      aliases.forEach(a => newGroup.aliases.add(a));
      const newRow = buildNewAllianceRow(newName, newKey);
      newGroup.rows.push(newRow);
      nextGroups.set(newKey, newGroup);

      state.groups = nextGroups;
      state.allianceRows = [...state.allianceRows, newRow];

      const branch = elements.branchInput.value.trim() || "main";
      const workerUrl = elements.workerUrl.value.trim();
      const headers = window.dsroShared.buildAdminHeaders({ adminKey, headers: { "Content-Type": "application/json" } });
      const payload = async (path, content) => {
        const res = await fetch(workerUrl, { method: "POST", headers, body: JSON.stringify({ path, content, branch }) });
        const json = await res.json().catch(() => ({}));
        if (!res.ok || !json.ok) throw new Error(json.error || json.detail || `Schreiben fehlgeschlagen (${path})`);
      };

      let aliasWriteFailed = false;
      try {
        const allianceCsv = buildAllianceCsv();
        await payload("data/alliance.csv", allianceCsv);
        if (aliases.length) {
          const aliasCsv = buildAliasCsv();
          try {
            await payload("data/aliases.csv", aliasCsv);
            setStatus("Spieler und Aliase gespeichert.", "ok");
          } catch (err) {
            aliasWriteFailed = true;
            console.error(err);
            setStatus("Spieler angelegt, Aliase nicht gespeichert", "error");
            setCreateError("Alias-Schreiben fehlgeschlagen.");
          }
        } else {
          setStatus("Spieler angelegt.", "ok");
        }

        elements.newPlayerName.value = "";
        if (elements.newPlayerAliases) elements.newPlayerAliases.value = "";
        await reloadData();
        applyNewPlayerFocus(newKey, newName);
        if (aliasWriteFailed) {
          state.groups.get(newKey)?.aliases.clear();
          renderGroups();
        }
      } catch (err) {
        console.error(err);
        setStatus(err.message || "Speichern fehlgeschlagen", "error");
        setCreateError(err.message || "Speichern fehlgeschlagen");
        state.groups = prevGroups;
        state.allianceRows = prevAllianceRows;
        renderGroups();
      } finally {
        state.saving = false; elements.saveBtn.disabled = false; updateCreateState();
      }
    }

    async function saveChanges() {
      rememberSettings();
      const adminKey = window.dsroShared?.getAdminKey?.();
      if (!adminKey) {
        alert("Admin-Key fehlt – bitte einloggen.");
        renderAdminKeyStatus({ message: "Admin-Key fehlt.", tone: "warn", showAlert: true });
        return;
      }
      state.saving = true; elements.saveBtn.disabled = true; updateCreateState(); setStatus("Speichere…", "info");
      const allianceCsv = buildAllianceCsv();
      const aliasesCsv = buildAliasCsv();
      const branch = elements.branchInput.value.trim() || "main";
      const workerUrl = elements.workerUrl.value.trim();
      const headers = window.dsroShared.buildAdminHeaders({ adminKey, headers: { "Content-Type": "application/json" } });
      const payload = async (path, content) => {
        const res = await fetch(workerUrl, { method: "POST", headers, body: JSON.stringify({ path, content, branch }) });
        const json = await res.json().catch(() => ({}));
        if (!res.ok || !json.ok) throw new Error(json.error || json.detail || `Schreiben fehlgeschlagen (${path})`);
      };
      try {
        await payload("data/alliance.csv", allianceCsv);
        await payload("data/aliases.csv", aliasesCsv);
        setStatus("Gespeichert.", "ok");
      } catch (err) {
        console.error(err);
        setStatus(err.message || "Speichern fehlgeschlagen", "error");
        openAdminSettings();
      } finally {
        state.saving = false; elements.saveBtn.disabled = false; updateCreateState();
      }
    }

    async function reloadData() {
      state.loading = true; elements.reloadBtn.disabled = true; elements.saveBtn.disabled = true; updateCreateState(); setStatus("Lade…", "info");
      try {
        state.highlightedKey = "";
        state.showAllPlayers = false;
        state.playerHeaders = [];
        state.playerNameField = "PlayerName";
        state.allianceRows = [];
        state.originalAllianceCsv = "";
        state.aliasHeaders = ["Canonical", "Alias"];
        state.aliasCanonicalField = "Canonical";
        state.aliasAliasField = "Alias";
        state.aliasRows = [];
        state.originalAliasesCsv = "";
        if (elements.showAllToggle) elements.showAllToggle.textContent = "Alle Spieler anzeigen";
        if (elements.searchInput) elements.searchInput.value = "";
        state.groups = new Map();
        await loadAlliance();
        await loadAliases();
        rebuildGroupsFromAlliance();
        renderGroups();
        setStatus(`Geladen (${state.groups.size} Gruppen).`, "ok");
      } catch (err) {
        console.error(err);
        setStatus(err.message || "Laden fehlgeschlagen", "error");
      } finally {
        state.loading = false; elements.reloadBtn.disabled = false; elements.saveBtn.disabled = false; updateCreateState();
      }
    }

    function initAdminKeyGate() {
      if (!window.dsroShared?.initAdminKeyGate) return;
      window.dsroShared.initAdminKeyGate({
        statusEl: elements.adminKeyStatus,
        fallbackInput: elements.adminKeyFallback,
        fallbackRow: elements.adminKeyFallbackRow,
        fallbackButton: elements.adminKeyFallbackBtn,
        settingsToggle: elements.adminSettings,
        renderStatus: renderAdminKeyStatus,
      });
    }

    function init() {
      initAdminKeyGate();
      restoreSettings();
      const auto = attachPlayerAutocomplete(elements.searchInput, {
        onCommit: (value) => {
          const match = resolveGroupByQuery(value);
          state.highlightedKey = match ? match.canonicalKey : "";
        },
      });
      if (elements.createPlayerBtn) elements.createPlayerBtn.addEventListener("click", createPlayer);
      if (elements.newPlayerName) elements.newPlayerName.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter") { ev.preventDefault(); createPlayer(); }
      });
      if (elements.newPlayerAliases) elements.newPlayerAliases.addEventListener("input", () => setCreateError(""));
      if (elements.newPlayerName) elements.newPlayerName.addEventListener("input", () => setCreateError(""));
      elements.searchInput.addEventListener("input", handleSearchInput);
      elements.showAllToggle.addEventListener("click", toggleShowAll);
      elements.reloadBtn.addEventListener("click", reloadData);
      elements.saveBtn.addEventListener("click", saveChanges);
      updateCreateState();
      reloadData();
    }

    init();
  </script>
</body>
</html>
