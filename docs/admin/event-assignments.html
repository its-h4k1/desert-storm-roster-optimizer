<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Event-Zusagen &amp; manuelle Gruppen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <link rel="stylesheet" href="admin.css" />
  <style>
    body { margin: 0; background: var(--bg); color: var(--text); }
    .page-header { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-end; position:sticky; top:0; background:var(--glass); padding:1.1rem; border-bottom:1px solid var(--border); z-index:5; }
    .page-header h1 { margin:0; flex:1 1 240px; }
    .page-header p { margin:0; color:var(--text-muted); }
    .settings { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-end; }
    label { display:flex; flex-direction:column; gap:0.35rem; font-size:0.9rem; color:var(--text-muted); }
    input[type="text"], input[type="search"], input[type="password"], select, textarea { font:inherit; padding:0.5rem 0.65rem; border-radius:0.75rem; border:1px solid var(--border); background:var(--bg-alt); color:var(--text); min-width:12rem; }
    input:focus, select:focus, textarea:focus { outline:2px solid rgba(37,99,235,0.35); outline-offset:1px; }
    textarea { resize:vertical; min-height:48px; }
    button { font:inherit; border:1px solid var(--border); border-radius:0.75rem; padding:0.55rem 1rem; background:#fff; color:var(--text); cursor:pointer; display:inline-flex; align-items:center; gap:0.4rem; }
    button:hover { background:#f8fafc; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    .admin-content { width:min(1400px,100%); }
    .page-inner { max-width:1400px; }
    .admin-section { padding:1.1rem; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:1rem; padding:1rem; box-shadow:var(--shadow-panel,0 18px 40px rgba(15,23,42,0.08)); display:grid; gap:0.75rem; }
    .panel h2 { margin:0; }
    .help-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:0.85rem; }
    .help-card { padding:0.85rem; background:var(--panel-muted); border:1px solid var(--border); border-radius:0.85rem; display:grid; gap:0.45rem; }
    .controls { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center; }
    .spacer { flex:1; min-width:40px; }
    .pill { display:inline-flex; align-items:center; gap:0.35rem; padding:0.25rem 0.6rem; border-radius:999px; font-size:0.85rem; background:var(--bg-alt); color:var(--text); border:1px solid var(--border); }
    .pill.info { background:#e0f2fe; color:#075985; border-color:#bae6fd; }
    .table-wrapper { border:1px solid var(--border); border-radius:0.85rem; overflow:auto; box-shadow:var(--shadow-card); background:var(--panel-muted); }
    table { width:100%; border-collapse:collapse; min-width:960px; }
    thead { background:var(--bg-alt); position:sticky; top:0; z-index:3; text-transform:uppercase; font-size:0.8rem; letter-spacing:0.04em; }
    th, td { padding:0.7rem 0.85rem; border-bottom:1px solid var(--border); text-align:left; vertical-align:top; }
    tbody tr:nth-child(2n) td { background:var(--panel-muted); }
    .row-actions { display:flex; gap:0.4rem; flex-wrap:wrap; }
    .tags { display:flex; gap:0.35rem; flex-wrap:wrap; }
    .tag { padding:0.25rem 0.55rem; border-radius:0.65rem; border:1px solid var(--border); background:var(--bg-alt); font-size:0.8rem; color:var(--text-muted); }
    .status-bar { position:sticky; bottom:0; background:var(--glass); border-top:1px solid var(--border); padding:0.75rem 1rem; display:flex; gap:0.6rem; align-items:center; box-shadow:0 -8px 24px rgba(15,23,42,0.08); flex-wrap:wrap; }
    .status-badge { display:inline-flex; align-items:center; gap:0.35rem; padding:0.35rem 0.7rem; border-radius:999px; font-weight:600; font-size:0.9rem; }
    .status-info { background:#e0f2fe; color:#075985; }
    .status-warn { background:#fff7ed; color:#9a3412; }
    .status-ok { background:#dcfce7; color:#14532d; }
    .status-error { background:#fee2e2; color:#991b1b; }
    @media (max-width: 960px) { .page-header { position:static; } label { width:100%; } input, select, textarea, button { width:100%; } button { justify-content:center; } table { min-width:880px; } }
  </style>
</head>
<body>
  <div class="admin-shell">
    <aside class="admin-sidebar">
      <div class="admin-sidebar-header">
        <div class="admin-logo">ELT Admin</div>
        <button class="sidebar-close" aria-label="Navigation schließen">✕</button>
      </div>
      <nav class="admin-nav">
        <a href="index.html">CSV &amp; Datei-Tools</a>
        <a href="events.html">Events erfassen</a>
        <a href="players.html">Spieler &amp; Aliase</a>
        <a href="absences.html">Absenzen</a>
        <a href="group-preferences.html">Gruppenpräferenzen</a>
        <a href="event-assignments.html" class="active">Event-Zusagen</a>
        <a href="noshow-dashboard.html">No-Show Analyse</a>
        <a href="callup-assistant.html">Callup-Assistent</a>
      </nav>
    </aside>

    <div class="admin-main">
      <header class="admin-header">
        <button class="sidebar-toggle" aria-label="Navigation öffnen">☰</button>
        <div class="page-title">
          <p>Admin · Events</p>
          <h1>Event-Zusagen &amp; manuelle Gruppen</h1>
        </div>
        <div class="admin-header-actions">
          <a class="btn ghost" href="../index.html">Zur Roster-Ansicht</a>
        </div>
      </header>

      <main class="admin-content">
        <section class="admin-section page-wrapper">
          <div class="page-inner">
            <header class="page-header">
              <div style="flex:1;min-width:260px;">
                <h1>Event-spezifische Zuordnungen</h1>
                <p>Erfasst Zusagen für ein konkretes Event (EventID) und ordnet sie Gruppe A/B zu – ohne langfristige Präferenzen zu verändern.</p>
              </div>
              <div class="settings">
                <label>Worker URL
                  <input id="workerUrl" type="text" value="https://ds-commit.hak1.workers.dev/write-file" spellcheck="false">
                </label>
                <label>Branch
                  <input id="branchInput" type="text" value="main" spellcheck="false">
                </label>
                <label>Admin-Key
                  <input id="adminKey" type="password" placeholder="r4-admin" autocomplete="off">
                </label>
                <button id="reloadBtn" class="ghost">Neu laden</button>
                <button id="saveBtn">Speichern</button>
              </div>
            </header>

            <main class="page-main" style="display:grid;gap:1rem;">
              <section class="panel">
                <h2>Konzept-Trennung</h2>
                <div class="help-grid">
                  <div class="help-card">
                    <strong>Dauerhafte Gruppenpräferenzen</strong>
                    <p>Stehen in <code>data/alliance.csv</code> (Spalten <code>PrefGroup</code>, <code>PrefMode</code>, <code>PrefBoost</code>) und beeinflussen den Optimizer über mehrere Events hinweg.</p>
                  </div>
                  <div class="help-card">
                    <strong>Event-spezifische Zuordnung</strong>
                    <p>Gilt nur für die ausgewählte <code>EventID</code>: Zusage / Wunschgruppe für ein einzelnes Event, z. B. zum Nachbesetzen bei kurzfristigen Änderungen.</p>
                  </div>
                  <div class="help-card">
                    <strong>Saubere Trennung</strong>
                    <p>Die neue Datei <code>data/event_assignments.csv</code> speichert ausschließlich Event-Zusagen und wird losgelöst von <code>PrefGroup</code> gepflegt. Eigener Tab statt Misch-UI, damit langfristige Präferenzen (Optimizer) und kurzfristige Event-Zusagen klar getrennt bleiben.</p>
                  </div>
                </div>
              </section>

              <section class="panel">
                <div class="controls">
                  <div style="display:flex;flex-direction:column;gap:0.35rem;min-width:240px;flex:1;">
                    <label style="margin:0;">Event-ID (Datalist verfügbar)
                      <input type="text" id="eventId" list="eventOptions" placeholder="DS-2025-11-21-A" autocomplete="off">
                    </label>
                    <small class="hint" id="eventHint" style="color:var(--text-muted);">Wähle das Event, dessen Zusagen du bearbeiten möchtest.</small>
                  </div>
                  <div class="spacer"></div>
                  <span class="pill info" id="assignmentCount">–</span>
                </div>
                <div class="controls" style="gap:0.5rem;">
                  <label style="min-width:220px;flex:1;">Spieler (Allianz oder Roster)
                    <input type="search" id="playerInput" list="playerOptions" placeholder="Name eingeben…" autocomplete="off">
                  </label>
                  <label>Gruppe
                    <select id="groupInput">
                      <option value="">–</option>
                      <option value="A">A</option>
                      <option value="B">B</option>
                    </select>
                  </label>
                  <label>Rolle
                    <select id="roleInput">
                      <option value="">–</option>
                      <option value="Start">Start</option>
                      <option value="Ersatz">Ersatz</option>
                    </select>
                  </label>
                  <label>Quelle
                    <select id="sourceInput">
                      <option value="manual">manual</option>
                      <option value="callup-confirmed">callup-confirmed</option>
                      <option value="notes">notes</option>
                    </select>
                  </label>
                  <label style="flex:1;min-width:200px;">Notiz
                    <input type="text" id="noteInput" placeholder="z.B. Discord-Zusage">
                  </label>
                  <button id="addBtn">Hinzufügen</button>
                </div>
                <p class="hint" style="color:var(--text-muted);">Einträge werden in <code>data/event_assignments.csv</code> gespeichert; Sortierung erfolgt nach EventID und Spielername.</p>
              </section>

              <section class="panel">
                <div class="controls" style="margin-bottom:0.5rem;">
                  <h2 style="margin:0;">Zugeordnete Teilnehmer</h2>
                  <span id="eventMeta" class="hint" style="color:var(--text-muted);"></span>
                </div>
                <div class="table-wrapper">
                  <table>
                    <thead>
                      <tr>
                        <th>Spieler</th>
                        <th>Gruppe</th>
                        <th>Rolle</th>
                        <th>Quelle</th>
                        <th>Notiz</th>
                        <th>Kontext</th>
                        <th>Aktion</th>
                      </tr>
                    </thead>
                    <tbody id="assignmentBody"></tbody>
                  </table>
                </div>
                <div id="emptyState" class="hint" style="color:var(--text-muted);display:none;">Keine event-spezifischen Zuordnungen für diese EventID.</div>
              </section>
            </main>
          </div>
        </section>
      </main>
    </div>
  </div>
  <div class="admin-overlay"></div>

  <div class="status-bar">
    <span id="statusBadge" class="status-badge status-info">Bereit</span>
    <div id="statusText" class="status-text">Noch keine Änderungen.</div>
  </div>

  <datalist id="eventOptions"></datalist>
  <datalist id="playerOptions"></datalist>

  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="admin.js"></script>
  <script>
    (function(){
      const elements = {
        workerUrl: document.getElementById('workerUrl'),
        branch: document.getElementById('branchInput'),
        adminKey: document.getElementById('adminKey'),
        reloadBtn: document.getElementById('reloadBtn'),
        saveBtn: document.getElementById('saveBtn'),
        eventId: document.getElementById('eventId'),
        eventOptions: document.getElementById('eventOptions'),
        playerInput: document.getElementById('playerInput'),
        playerOptions: document.getElementById('playerOptions'),
        groupInput: document.getElementById('groupInput'),
        roleInput: document.getElementById('roleInput'),
        sourceInput: document.getElementById('sourceInput'),
        noteInput: document.getElementById('noteInput'),
        addBtn: document.getElementById('addBtn'),
        assignmentBody: document.getElementById('assignmentBody'),
        assignmentCount: document.getElementById('assignmentCount'),
        emptyState: document.getElementById('emptyState'),
        statusBadge: document.getElementById('statusBadge'),
        statusText: document.getElementById('statusText'),
        eventMeta: document.getElementById('eventMeta'),
        eventHint: document.getElementById('eventHint'),
      };

      const SETTINGS_KEY = 'dsro-event-assignments-settings';
      const DEFAULT_HEADERS = ['EventID','PlayerName','Group','Role','Source','Note'];
      const state = {
        assignments: [],
        headers: [],
        originalCsv: '',
        loading: false,
        saving: false,
        selectedEventId: '',
        alliancePlayers: [],
        rosterPlayers: [],
        eventList: [],
      };

      // Konzept-Notiz: Dauerhafte Gruppenpräferenzen (data/alliance.csv: PrefGroup/PrefMode/PrefBoost) steuern den Optimizer langfristig.
      // Event-spezifische Zuordnungen (data/event_assignments.csv) dokumentieren nur Zusagen/Plätze für eine konkrete EventID und überschreiben nichts dauerhaft.

      function normalizeLineEndings(text) { return (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n'); }
      function ensureTrailingNewline(text) { if (!text) return '\n'; return /\n$/.test(text) ? text : text + '\n'; }
      function formatCsvValue(value) {
        if (value === null || value === undefined) return '';
        const str = value.toString();
        if (str.includes('"') || str.includes(',') || str.includes('\n')) return `"${str.replace(/"/g, '""')}"`;
        return str;
      }
      function parseCsv(text) {
        const res = Papa.parse(normalizeLineEndings(text || ''), { header:true, skipEmptyLines:true });
        const rows = Array.isArray(res.data) ? res.data : [];
        return { headers: res.meta?.fields || [], rows };
      }
      function buildCsv(headers, rows) {
        const headerLine = headers.join(',');
        const lines = rows.map(row => headers.map(h => formatCsvValue(row[h] ?? '')).join(','));
        return ensureTrailingNewline([headerLine, ...lines].join('\n'));
      }
      async function fetchText(path) {
        const res = await fetch(path, { cache:'no-store' });
        if (!res.ok) throw new Error(`${path}: HTTP ${res.status}`);
        return await res.text();
      }
      async function loadAssignments() {
        try {
          const text = await fetchText('../../data/event_assignments.csv');
          const { headers, rows } = parseCsv(text);
          state.headers = headers.length ? headers : [...DEFAULT_HEADERS];
          state.assignments = rows.map(r => ({ ...DEFAULT_HEADERS.reduce((acc,k)=>({ ...acc, [k]:''}),{}), ...r }));
          state.originalCsv = buildCurrentCsv();
        } catch (err) {
          console.warn('event_assignments.csv nicht ladbar, starte leer', err);
          state.headers = [...DEFAULT_HEADERS];
          state.assignments = [];
          state.originalCsv = buildCurrentCsv();
        }
      }
      async function loadAlliance() {
        const text = await fetchText('../../data/alliance.csv');
        const { rows } = parseCsv(text);
        state.alliancePlayers = rows.map(r => (r.PlayerName || '').toString()).filter(Boolean);
      }
      async function loadRoster() {
        try {
          const data = await fetch('../../out/latest.json', { cache:'no-store' }).then(r => r.json());
          const players = Array.isArray(data?.players) ? data.players : [];
          state.rosterPlayers = players.map(p => ({ name: p.display || p.canon || '', group: p.group || '', role: p.role || '' })).filter(p => p.name);
        } catch (err) {
          console.warn('latest.json nicht verfügbar', err);
          state.rosterPlayers = [];
        }
      }
      async function loadEventList() {
        const collected = new Set();
        state.assignments.forEach(a => { if (a.EventID) collected.add(a.EventID); });
        try {
          const text = await fetchText('../../data/callups.csv');
          const { rows } = parseCsv(text);
          rows.forEach(r => { if (r.EventID) collected.add(r.EventID); });
        } catch (err) { console.warn('callups.csv nicht verfügbar', err); }
        state.eventList = Array.from(collected).sort((a,b) => b.localeCompare(a,'de',{sensitivity:'base'}));
      }

      function buildCurrentCsv() {
        const headers = state.headers.length ? state.headers : [...DEFAULT_HEADERS];
        const rows = state.assignments.map(entry => {
          const out = {};
          headers.forEach(h => { out[h] = entry[h] ?? ''; });
          return out;
        });
        rows.sort((a,b) => {
          const ea = (a.EventID || '').toString();
          const eb = (b.EventID || '').toString();
          if (ea === eb) return (a.PlayerName || '').localeCompare((b.PlayerName || ''), 'de', { sensitivity:'base' });
          return ea.localeCompare(eb, 'de', { sensitivity:'base' });
        });
        return buildCsv(headers, rows);
      }
      function hasChanges() {
        const current = buildCurrentCsv();
        return normalizeLineEndings(current).trim() !== normalizeLineEndings(state.originalCsv).trim();
      }
      function setStatus(message, tone='info') {
        const toneClass = tone === 'ok' ? 'status-ok' : tone === 'warn' ? 'status-warn' : tone === 'error' ? 'status-error' : 'status-info';
        elements.statusBadge.className = 'status-badge ' + toneClass;
        elements.statusBadge.textContent = tone === 'ok' ? 'OK' : tone === 'error' ? 'Fehler' : tone === 'warn' ? 'Hinweis' : 'Status';
        elements.statusText.textContent = message;
      }
      function setLoading(isLoading) {
        state.loading = isLoading;
        elements.reloadBtn.disabled = isLoading || state.saving;
        updateSaveButtonState();
        if (isLoading) setStatus('Lade Daten…', 'info');
      }
      function setSaving(isSaving) {
        state.saving = isSaving;
        updateSaveButtonState();
      }
      function updateSaveButtonState() {
        elements.saveBtn.disabled = state.loading || state.saving || !hasChanges();
        elements.saveBtn.textContent = state.saving ? 'Speichert…' : 'Speichern';
      }

      function populatePlayers() {
        const set = new Set();
        state.alliancePlayers.forEach(n => set.add(n));
        state.rosterPlayers.forEach(p => set.add(p.name));
        const names = Array.from(set).sort((a,b) => a.localeCompare(b, 'de', { sensitivity:'base' }));
        elements.playerOptions.innerHTML = '';
        names.forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          elements.playerOptions.appendChild(opt);
        });
      }
      function populateEvents() {
        elements.eventOptions.innerHTML = '';
        state.eventList.forEach(ev => {
          const opt = document.createElement('option');
          opt.value = ev;
          elements.eventOptions.appendChild(opt);
        });
        if (!elements.eventId.value && state.eventList.length) {
          elements.eventId.value = state.eventList[0];
          state.selectedEventId = state.eventList[0];
        }
      }

      function ensureAssignment(eventId, playerName) {
        const existing = state.assignments.find(r => (r.EventID || '') === eventId && (r.PlayerName || '') === playerName);
        if (existing) return existing;
        const blank = { EventID: eventId, PlayerName: playerName, Group:'', Role:'', Source:'manual', Note:'' };
        state.assignments.push(blank);
        return blank;
      }

      function renderAssignments() {
        const eventId = elements.eventId.value.trim();
        state.selectedEventId = eventId;
        const rows = state.assignments.filter(r => (r.EventID || '') === eventId);
        elements.assignmentBody.innerHTML = '';
        elements.assignmentCount.textContent = `${rows.length} Einträge`;
        elements.eventMeta.textContent = eventId ? `Bearbeite event-spezifische Zuordnungen für ${eventId}` : 'Bitte EventID wählen.';
        elements.emptyState.style.display = rows.length ? 'none' : 'block';
        rows.forEach((row, idx) => {
          const tr = document.createElement('tr');
          const playerTd = document.createElement('td');
          playerTd.textContent = row.PlayerName || '–';
          tr.appendChild(playerTd);

          const groupTd = document.createElement('td');
          const groupSel = document.createElement('select');
          ['', 'A', 'B'].forEach(v => {
            const opt = document.createElement('option');
            opt.value = v; opt.textContent = v || '–';
            if ((row.Group || '') === v) opt.selected = true;
            groupSel.appendChild(opt);
          });
          groupSel.addEventListener('change', () => { row.Group = groupSel.value; updateSaveButtonState(); });
          groupTd.appendChild(groupSel);
          tr.appendChild(groupTd);

          const roleTd = document.createElement('td');
          const roleSel = document.createElement('select');
          ['', 'Start', 'Ersatz'].forEach(v => {
            const opt = document.createElement('option'); opt.value = v; opt.textContent = v || '–';
            if ((row.Role || '') === v) opt.selected = true;
            roleSel.appendChild(opt);
          });
          roleSel.addEventListener('change', () => { row.Role = roleSel.value; updateSaveButtonState(); });
          roleTd.appendChild(roleSel);
          tr.appendChild(roleTd);

          const sourceTd = document.createElement('td');
          const sourceSel = document.createElement('select');
          ['manual','callup-confirmed','notes','other'].forEach(v => {
            const opt = document.createElement('option'); opt.value = v; opt.textContent = v;
            if ((row.Source || '') === v) opt.selected = true;
            sourceSel.appendChild(opt);
          });
          sourceSel.addEventListener('change', () => { row.Source = sourceSel.value; updateSaveButtonState(); });
          sourceTd.appendChild(sourceSel);
          tr.appendChild(sourceTd);

          const noteTd = document.createElement('td');
          const noteInput = document.createElement('input');
          noteInput.type = 'text';
          noteInput.value = row.Note || '';
          noteInput.placeholder = 'z.B. Discord-Zusage';
          noteInput.addEventListener('input', () => { row.Note = noteInput.value; updateSaveButtonState(); });
          noteTd.appendChild(noteInput);
          tr.appendChild(noteTd);

          const ctxTd = document.createElement('td');
          const tags = document.createElement('div');
          tags.className = 'tags';
          const inAlliance = state.alliancePlayers.includes(row.PlayerName);
          const rosterEntry = state.rosterPlayers.find(p => p.name === row.PlayerName);
          if (inAlliance) { const tag = document.createElement('span'); tag.className='tag'; tag.textContent='In Allianz'; tags.appendChild(tag); }
          if (rosterEntry) { const tag = document.createElement('span'); tag.className='tag'; tag.textContent=`EB-Roster ${rosterEntry.group || ''} ${rosterEntry.role || ''}`.trim(); tags.appendChild(tag); }
          if (!tags.children.length) { const tag = document.createElement('span'); tag.className='tag'; tag.textContent='kein Kontext'; tags.appendChild(tag); }
          ctxTd.appendChild(tags);
          tr.appendChild(ctxTd);

          const actionTd = document.createElement('td');
          const delBtn = document.createElement('button');
          delBtn.textContent = 'Löschen';
          delBtn.addEventListener('click', () => {
            const idxGlobal = state.assignments.indexOf(row);
            if (idxGlobal >= 0) { state.assignments.splice(idxGlobal, 1); renderAssignments(); updateSaveButtonState(); }
          });
          actionTd.appendChild(delBtn);
          tr.appendChild(actionTd);

          elements.assignmentBody.appendChild(tr);
        });
        elements.emptyState.style.display = rows.length ? 'none' : 'block';
      }

      function addAssignment() {
        const eventId = elements.eventId.value.trim();
        const player = elements.playerInput.value.trim();
        if (!eventId) { setStatus('Bitte EventID wählen.', 'warn'); elements.eventId.focus(); return; }
        if (!player) { setStatus('Bitte Spieler auswählen.', 'warn'); elements.playerInput.focus(); return; }
        const entry = ensureAssignment(eventId, player);
        entry.Group = elements.groupInput.value;
        entry.Role = elements.roleInput.value;
        entry.Source = elements.sourceInput.value || 'manual';
        entry.Note = elements.noteInput.value;
        if (!state.eventList.includes(eventId)) { state.eventList.unshift(eventId); populateEvents(); }
        renderAssignments();
        updateSaveButtonState();
        setStatus('Eintrag hinzugefügt/aktualisiert.', 'info');
      }

      async function reloadData() {
        setLoading(true);
        try {
          await loadAssignments();
          await Promise.all([loadAlliance(), loadRoster()]);
          await loadEventList();
          populatePlayers();
          populateEvents();
          renderAssignments();
          setStatus('Daten geladen.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus(`Laden fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setLoading(false);
          updateSaveButtonState();
        }
      }

      async function saveChanges() {
        if (state.loading || state.saving) return;
        const workerUrl = elements.workerUrl.value.trim();
        const adminKey = elements.adminKey.value.trim();
        const branch = elements.branch.value.trim() || 'main';
        if (!workerUrl) { setStatus('Worker-URL fehlt.', 'error'); return; }
        if (!adminKey) { setStatus('Admin-Key erforderlich.', 'error'); return; }
        const content = buildCurrentCsv();
        setSaving(true);
        setStatus('Speichere event_assignments.csv…', 'info');
        try {
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_assignments.csv',
            content,
            branch,
            message: 'admin: update event_assignments.csv via event assignments ui',
          });
          state.originalCsv = content;
          setStatus('Event-Zusagen gespeichert.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus(`Speichern fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setSaving(false);
          updateSaveButtonState();
        }
      }

      async function writeFile(workerUrl, adminKey, payload) {
        const headers = { 'Content-Type': 'application/json', 'X-Admin-Key': adminKey };
        const response = await fetch(workerUrl, { method:'POST', headers, body: JSON.stringify(payload) });
        if (!response.ok) { const text = await response.text().catch(() => ''); throw new Error(text || `HTTP ${response.status}`); }
        const result = await response.json().catch(() => ({}));
        if (result && result.ok === false) throw new Error(result.error || 'Worker-Fehler');
        return result;
      }

      function persistSettings() {
        const payload = { workerUrl: elements.workerUrl.value, branch: elements.branch.value, adminKey: elements.adminKey.value, eventId: elements.eventId.value };
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(payload));
      }
      function restoreSettings() {
        const saved = localStorage.getItem(SETTINGS_KEY);
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
            if (parsed.branch) elements.branch.value = parsed.branch;
            if (parsed.adminKey) elements.adminKey.value = parsed.adminKey;
            if (parsed.eventId) { elements.eventId.value = parsed.eventId; state.selectedEventId = parsed.eventId; }
          } catch (err) { console.warn('Settings konnten nicht gelesen werden', err); }
        } else {
          const shared = localStorage.getItem('dsro-admin-settings');
          if (shared) {
            try {
              const parsed = JSON.parse(shared);
              if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
              if (parsed.customBranch) elements.branch.value = parsed.customBranch;
              if (parsed.branchSelect) elements.branch.value = parsed.branchSelect;
              if (parsed.adminKey) elements.adminKey.value = parsed.adminKey;
            } catch (err) { console.warn('Shared settings konnten nicht gelesen werden', err); }
          }
        }
      }

      function initEvents() {
        elements.reloadBtn.addEventListener('click', reloadData);
        elements.saveBtn.addEventListener('click', saveChanges);
        elements.addBtn.addEventListener('click', addAssignment);
        elements.eventId.addEventListener('change', () => { state.selectedEventId = elements.eventId.value.trim(); persistSettings(); renderAssignments(); });
        ['workerUrl','branch','adminKey'].forEach(key => elements[key].addEventListener('change', persistSettings));
        elements.playerInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addAssignment(); } });
      }

      restoreSettings();
      initEvents();
      reloadData();
    })();
  </script>
</body>
</html>
