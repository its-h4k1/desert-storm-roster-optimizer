<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Event-Zusagen &amp; manuelle Gruppen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <link rel="stylesheet" href="admin.css" />
  <style>
    body { margin: 0; background: var(--bg); color: var(--text); }
    .page-header { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-end; position:sticky; top:0; background:var(--glass); padding:1.1rem; border-bottom:1px solid var(--border); z-index:5; }
    .page-header h1 { margin:0; flex:1 1 240px; }
    .page-header p { margin:0; color:var(--text-muted); }
    .settings { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-end; }
    label { display:flex; flex-direction:column; gap:0.35rem; font-size:0.9rem; color:var(--text-muted); }
    input[type="text"], input[type="search"], input[type="password"], select, textarea { font:inherit; padding:0.5rem 0.65rem; border-radius:0.75rem; border:1px solid var(--border); background:var(--bg-alt); color:var(--text); min-width:12rem; }
    input:focus, select:focus, textarea:focus { outline:2px solid rgba(37,99,235,0.35); outline-offset:1px; }
    textarea { resize:vertical; min-height:48px; }
    button { font:inherit; border:1px solid var(--border); border-radius:0.75rem; padding:0.55rem 1rem; background:#fff; color:var(--text); cursor:pointer; display:inline-flex; align-items:center; gap:0.4rem; }
    button:hover { background:#f8fafc; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    .admin-content { width:min(1400px,100%); }
    .page-inner { max-width:1400px; }
    .admin-section { padding:1.1rem; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:1rem; padding:1rem; box-shadow:var(--shadow-panel,0 18px 40px rgba(15,23,42,0.08)); display:grid; gap:0.75rem; }
    .panel h2 { margin:0; }
    .help-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:0.85rem; }
    .help-card { padding:0.85rem; background:var(--panel-muted); border:1px solid var(--border); border-radius:0.85rem; display:grid; gap:0.45rem; }
    .controls { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center; }
    .spacer { flex:1; min-width:40px; }
    .pill { display:inline-flex; align-items:center; gap:0.35rem; padding:0.25rem 0.6rem; border-radius:999px; font-size:0.85rem; background:var(--bg-alt); color:var(--text); border:1px solid var(--border); }
    .pill.info { background:#e0f2fe; color:#075985; border-color:#bae6fd; }
    .table-wrapper { border:1px solid var(--border); border-radius:0.85rem; overflow:auto; box-shadow:var(--shadow-card); background:var(--panel-muted); }
    table { width:100%; border-collapse:collapse; min-width:960px; }
    thead { background:var(--bg-alt); position:sticky; top:0; z-index:3; text-transform:uppercase; font-size:0.8rem; letter-spacing:0.04em; }
    th, td { padding:0.7rem 0.85rem; border-bottom:1px solid var(--border); text-align:left; vertical-align:top; }
    tbody tr:nth-child(2n) td { background:var(--panel-muted); }
    .row-actions { display:flex; gap:0.4rem; flex-wrap:wrap; }
    .tags { display:flex; gap:0.35rem; flex-wrap:wrap; }
    .tag { padding:0.25rem 0.55rem; border-radius:0.65rem; border:1px solid var(--border); background:var(--bg-alt); font-size:0.8rem; color:var(--text-muted); }
    .tag-hard { background:#fef2f2; border-color:#fecaca; color:#991b1b; font-weight:600; }
    .status-bar { position:sticky; bottom:0; background:var(--glass); border-top:1px solid var(--border); padding:0.75rem 1rem; display:flex; gap:0.6rem; align-items:center; box-shadow:0 -8px 24px rgba(15,23,42,0.08); flex-wrap:wrap; }
    .status-badge { display:inline-flex; align-items:center; gap:0.35rem; padding:0.35rem 0.7rem; border-radius:999px; font-weight:600; font-size:0.9rem; }
    .status-info { background:#e0f2fe; color:#075985; }
    .status-warn { background:#fff7ed; color:#9a3412; }
    .status-ok { background:#dcfce7; color:#14532d; }
    .status-error { background:#fee2e2; color:#991b1b; }
    .roster-preview { display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:0.75rem; }
    .roster-card { border:1px solid var(--border); border-radius:0.85rem; padding:0.85rem; background:var(--panel-muted); display:grid; gap:0.4rem; }
    .roster-card h3 { margin:0; font-size:1rem; display:flex; align-items:center; justify-content:space-between; gap:0.5rem; }
    .roster-list { list-style:none; padding:0; margin:0.35rem 0 0; display:grid; gap:0.25rem; }
    .roster-badge { display:inline-flex; align-items:center; gap:0.35rem; padding:0.2rem 0.55rem; border-radius:999px; background:#eef2ff; color:#312e81; border:1px solid #c7d2fe; font-size:0.78rem; }
    .extra-pill { background:#ecfeff; border:1px solid #a5f3fc; color:#0f172a; }
    @media (max-width: 960px) { .page-header { position:static; } label { width:100%; } input, select, textarea, button { width:100%; } button { justify-content:center; } table { min-width:880px; } }
  </style>
</head>
<body>
  <div class="admin-shell">
    <aside class="admin-sidebar">
      <div class="admin-sidebar-header">
        <div class="admin-logo">ELT Admin</div>
        <button class="sidebar-close" aria-label="Navigation schließen">✕</button>
      </div>
      <nav class="admin-nav">
        <a href="index.html">CSV &amp; Datei-Tools</a>
        <a href="events.html">Events erfassen</a>
        <a href="players.html">Spieler &amp; Aliase</a>
        <a href="absences.html">Absenzen</a>
        <a href="group-preferences.html">Gruppenpräferenzen</a>
        <a href="event-assignments.html" class="active">Event-Zusagen</a>
        <a href="noshow-dashboard.html">No-Show Analyse</a>
        <a href="callup-assistant.html">Callup-Assistent</a>
      </nav>
    </aside>

    <div class="admin-main">
      <header class="admin-header">
        <button class="sidebar-toggle" aria-label="Navigation öffnen">☰</button>
        <div class="page-title">
          <p>Admin · Events</p>
          <h1>Event-Zusagen &amp; manuelle Gruppen</h1>
        </div>
        <div class="admin-header-actions">
          <a class="btn ghost" href="../index.html">Zur Roster-Ansicht</a>
        </div>
      </header>

      <main class="admin-content">
        <section class="admin-section page-wrapper">
          <div class="page-inner">
            <header class="page-header">
              <div style="flex:1;min-width:260px;">
                <h1>Zusage-Pool fürs nächste Event</h1>
                <p>Pflegt Zusagen und A/B-Wünsche für das kommende Event (aktuelle Aufstellung in <code>out/latest.json</code>). Kein Event-Browser – der Pool gehört immer zum nächsten Event.</p>
              </div>
              <div class="settings">
                <label>Worker URL
                  <input id="workerUrl" type="text" value="https://ds-commit.hak1.workers.dev/write-file" spellcheck="false">
                </label>
                <label>Branch
                  <input id="branchInput" type="text" value="main" spellcheck="false">
                </label>
                <label>Admin-Key
                  <input id="adminKey" type="password" placeholder="r4-admin" autocomplete="off">
                </label>
                <button id="reloadBtn" class="ghost">Neu laden</button>
                <button id="saveBtn">Speichern</button>
              </div>
            </header>

            <main class="page-main" style="display:grid;gap:1rem;">
              <section class="panel">
                <h2>Konzept-Trennung</h2>
                <div class="help-grid">
                  <div class="help-card">
                    <strong>Dauerhafte Gruppenpräferenzen</strong>
                    <p>Stehen in <code>data/alliance.csv</code> (Spalten <code>PrefGroup</code>, <code>PrefMode</code>, <code>PrefBoost</code>) und beeinflussen den Optimizer über mehrere Events hinweg.</p>
                  </div>
                  <div class="help-card">
                    <strong>Event-Zusagen (nächstes Event)</strong>
                    <p>Pool für das <em>nächste</em> Event: Zusage / Wunschgruppe als Overlay zur aktuellen Aufstellung. Kein Event-Browser, der Pool gilt immer für <code>out/latest.json</code> und wird nach dem nächsten Build in <code>latest.json</code> gespiegelt.</p>
                  </div>
                  <div class="help-card">
                    <strong>Verbindlichkeit &amp; Trennung</strong>
                    <p><code>Commitment=hard</code> wird beim nächsten Roster-Build als Forced-Slot behandelt. Event-Zusagen in <code>data/event_signups_next.csv</code> sind unabhängig von <code>PrefGroup</code>; Reset leert nur den Zusage-Pool.</p>
                  </div>
                </div>
              </section>

              <section class="panel">
                <div class="controls" style="align-items:flex-start;">
                  <div style="display:flex;flex-direction:column;gap:0.35rem;min-width:280px;flex:1;">
                    <label style="margin:0;">Kontext
                      <div id="contextMeta" class="hint" style="color:var(--text-muted);">Lädt out/latest.json …</div>
                    </label>
                    <small class="hint" style="color:var(--text-muted);">Alle Einträge gelten für das nächste Event (aktuelles Roster). <code>Commitment=hard</code> = Fixplatz im nächsten Build; bei Event-Wechsel den Pool leeren.</small>
                  </div>
                  <div class="spacer"></div>
                  <button id="resetBtn" class="ghost" style="border-color:var(--border);color:#b91c1c;">Zusage-Pool für nächstes Event zurücksetzen</button>
                  <span class="pill info" id="assignmentCount">–</span>
                </div>
                <div class="controls" style="gap:0.5rem;">
                  <label style="min-width:220px;flex:1;">Spieler (Allianz oder Roster)
                    <input type="search" id="playerInput" list="playerOptions" placeholder="Name eingeben…" autocomplete="off">
                  </label>
                  <label>Gruppe
                    <select id="groupInput">
                      <option value="">–</option>
                      <option value="A">A</option>
                      <option value="B">B</option>
                    </select>
                  </label>
                  <label>Rolle
                    <select id="roleInput">
                      <option value="">–</option>
                      <option value="Start">Start</option>
                      <option value="Ersatz">Ersatz</option>
                    </select>
                  </label>
                  <label>Verbindlichkeit
                    <select id="commitmentInput">
                      <option value="none">Nur Info</option>
                      <option value="hard">Verbindlich (fix in Aufstellung)</option>
                    </select>
                  </label>
                  <label>Quelle
                    <select id="sourceInput">
                      <option value="manual">manual</option>
                      <option value="callup-confirmed">callup-confirmed</option>
                      <option value="notes">notes</option>
                    </select>
                  </label>
                  <label style="flex:1;min-width:200px;">Notiz
                    <input type="text" id="noteInput" placeholder="z.B. Discord-Zusage">
                  </label>
                  <button id="addBtn">Hinzufügen</button>
                </div>
                <p class="hint" style="color:var(--text-muted);">Einträge werden in <code>data/event_signups_next.csv</code> gespeichert; Sortierung erfolgt nach Gruppe und Spielername.</p>
              </section>

              <section class="panel">
                <div class="controls" style="margin-bottom:0.5rem;">
                  <h2 style="margin:0;">Zugeordnete Teilnehmer (Pool nächstes Event)</h2>
                  <span id="eventMeta" class="hint" style="color:var(--text-muted);"></span>
                </div>
                <div class="table-wrapper">
                  <table>
                    <thead>
                      <tr>
                        <th>Spieler</th>
                        <th>Gruppe</th>
                        <th>Rolle</th>
                        <th>Verbindlichkeit</th>
                        <th>Quelle</th>
                        <th>Notiz</th>
                        <th>Roster-Kontext</th>
                        <th>Aktion</th>
                      </tr>
                    </thead>
                    <tbody id="assignmentBody"></tbody>
                  </table>
                </div>
                <div id="emptyState" class="hint" style="color:var(--text-muted);display:none;">Noch keine Zusagen im Pool.</div>
              </section>

              <section class="panel" id="rosterPreviewPanel">
                <div class="controls" style="margin-bottom:0.5rem;">
                  <h2 style="margin:0;">Optimierte Aufstellung (nächstes Event)</h2>
                  <span id="rosterMeta" class="hint" style="color:var(--text-muted);"></span>
                </div>
                <div id="rosterPreview" class="roster-preview"></div>
              </section>
            </main>
          </div>
        </section>
      </main>
    </div>
  </div>
  <div class="admin-overlay"></div>

  <div class="status-bar">
    <span id="statusBadge" class="status-badge status-info">Bereit</span>
    <div id="statusText" class="status-text">Noch keine Änderungen.</div>
  </div>

  <datalist id="playerOptions"></datalist>

  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="admin.js"></script>
  <script>
    (function(){
      const elements = {
        workerUrl: document.getElementById('workerUrl'),
        branch: document.getElementById('branchInput'),
        adminKey: document.getElementById('adminKey'),
        reloadBtn: document.getElementById('reloadBtn'),
        saveBtn: document.getElementById('saveBtn'),
        playerInput: document.getElementById('playerInput'),
        playerOptions: document.getElementById('playerOptions'),
        groupInput: document.getElementById('groupInput'),
        roleInput: document.getElementById('roleInput'),
        commitmentInput: document.getElementById('commitmentInput'),
        sourceInput: document.getElementById('sourceInput'),
        noteInput: document.getElementById('noteInput'),
        addBtn: document.getElementById('addBtn'),
        assignmentBody: document.getElementById('assignmentBody'),
        assignmentCount: document.getElementById('assignmentCount'),
        emptyState: document.getElementById('emptyState'),
        statusBadge: document.getElementById('statusBadge'),
        statusText: document.getElementById('statusText'),
        eventMeta: document.getElementById('eventMeta'),
        contextMeta: document.getElementById('contextMeta'),
        resetBtn: document.getElementById('resetBtn'),
        rosterPreview: document.getElementById('rosterPreview'),
        rosterMeta: document.getElementById('rosterMeta'),
      };

      const SETTINGS_KEY = 'dsro-event-assignments-settings';
      // Commitment existierte bereits als CSV-Spalte, wurde in dieser UI jedoch ignoriert; jetzt wird sie mitgelesen und mitgeschrieben.
      const DEFAULT_HEADERS = ['PlayerName','Group','Role','Commitment','Source','Note'];
      const state = {
        assignments: [],
        headers: [],
        originalCsv: '',
        loading: false,
        saving: false,
        alliancePool: [],
        rosterPlayers: [],
        rosterGroups: {},
        rosterMeta: null,
        eventSignupsMeta: null,
      };

      // Konzept-Notiz: Dauerhafte Gruppenpräferenzen (data/alliance.csv: PrefGroup/PrefMode/PrefBoost) steuern den Optimizer langfristig.
      // Der Zusage-Pool (data/event_signups_next.csv) gehört immer zum nächsten Event (aktuelles out/latest.json) und überschreibt den Optimizer nicht dauerhaft.

      function normalizeLineEndings(text) { return (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n'); }
      function ensureTrailingNewline(text) { if (!text) return '\n'; return /\n$/.test(text) ? text : text + '\n'; }
      function formatCsvValue(value) {
        if (value === null || value === undefined) return '';
        const str = value.toString();
        if (str.includes('"') || str.includes(',') || str.includes('\n')) return `"${str.replace(/"/g, '""')}"`;
        return str;
      }
      function parseCsv(text) {
        const res = Papa.parse(normalizeLineEndings(text || ''), { header:true, skipEmptyLines:true });
        const rows = Array.isArray(res.data) ? res.data : [];
        return { headers: res.meta?.fields || [], rows };
      }
      function buildCsv(headers, rows) {
        const headerLine = headers.join(',');
        const lines = rows.map(row => headers.map(h => formatCsvValue(row[h] ?? '')).join(','));
        return ensureTrailingNewline([headerLine, ...lines].join('\n'));
      }
      async function fetchText(path) {
        const res = await fetch(path, { cache:'no-store' });
        if (!res.ok) throw new Error(`${path}: HTTP ${res.status}`);
        return await res.text();
      }
      async function loadAssignments() {
        try {
          const text = await fetchText('../../data/event_signups_next.csv');
          const { headers, rows } = parseCsv(text);
          const mergedHeaders = headers.length ? Array.from(new Set([...headers, ...DEFAULT_HEADERS])) : [...DEFAULT_HEADERS];
          state.headers = mergedHeaders;
          const baseRow = DEFAULT_HEADERS.reduce((acc, k) => ({ ...acc, [k]: k === 'Commitment' ? 'none' : '' }), {});
          state.assignments = rows.map(r => ({ ...baseRow, ...r, Commitment: r.Commitment || r.commitment || baseRow.Commitment }));
          state.originalCsv = buildCurrentCsv();
        } catch (err) {
          console.warn('event_signups_next.csv nicht ladbar, starte leer', err);
          state.headers = [...DEFAULT_HEADERS];
          state.assignments = [];
          state.originalCsv = buildCurrentCsv();
        }
      }
      async function loadRoster() {
        try {
          const data = await fetch('../../out/latest.json', { cache:'no-store' }).then(r => r.json());
          const players = Array.isArray(data?.players) ? data.players : [];
          state.alliancePool = Array.isArray(data?.alliance_pool) ? data.alliance_pool : [];
          state.rosterPlayers = players
            .map(p => ({
              name: p.display || p.canon || '',
              group: p.group || '',
              role: p.role || '',
              canon: canonicalNameJS(p.canon || p.display || ''),
            }))
            .filter(p => p.name);
          state.rosterGroups = (data && data.groups) || {};
          state.rosterMeta = data?.generated_at || null;
          state.eventSignupsMeta = data?.event_signups || null;
          updateContextMeta();
        } catch (err) {
          console.warn('latest.json nicht verfügbar', err);
          state.rosterPlayers = [];
          state.rosterGroups = {};
          state.rosterMeta = null;
          state.alliancePool = [];
          state.eventSignupsMeta = null;
          updateContextMeta();
        }
      }
      function buildCurrentCsv() {
        const headers = state.headers.length ? Array.from(new Set([...state.headers, ...DEFAULT_HEADERS])) : [...DEFAULT_HEADERS];
        const rows = state.assignments.map(entry => {
          const out = {};
          headers.forEach(h => { out[h] = entry[h] ?? ''; });
          return out;
        });
        rows.sort((a,b) => {
          const ga = (a.Group || '').toString();
          const gb = (b.Group || '').toString();
          if (ga !== gb) return ga.localeCompare(gb, 'de', { sensitivity:'base' });
          return (a.PlayerName || '').localeCompare((b.PlayerName || ''), 'de', { sensitivity:'base' });
        });
        return buildCsv(headers, rows);
      }
      function hasChanges() {
        const current = buildCurrentCsv();
        return normalizeLineEndings(current).trim() !== normalizeLineEndings(state.originalCsv).trim();
      }
      function setStatus(message, tone='info') {
        const toneClass = tone === 'ok' ? 'status-ok' : tone === 'warn' ? 'status-warn' : tone === 'error' ? 'status-error' : 'status-info';
        elements.statusBadge.className = 'status-badge ' + toneClass;
        elements.statusBadge.textContent = tone === 'ok' ? 'OK' : tone === 'error' ? 'Fehler' : tone === 'warn' ? 'Hinweis' : 'Status';
        elements.statusText.textContent = message;
      }
      function setLoading(isLoading) {
        state.loading = isLoading;
        elements.reloadBtn.disabled = isLoading || state.saving;
        if (elements.resetBtn) elements.resetBtn.disabled = isLoading || state.saving;
        updateSaveButtonState();
        if (isLoading) setStatus('Lade Daten…', 'info');
      }
      function setSaving(isSaving) {
        state.saving = isSaving;
        if (elements.resetBtn) elements.resetBtn.disabled = isSaving || state.loading;
        updateSaveButtonState();
      }
      function updateSaveButtonState() {
        elements.saveBtn.disabled = state.loading || state.saving || !hasChanges();
        elements.saveBtn.textContent = state.saving ? 'Speichert…' : 'Speichern';
      }

      function updateContextMeta() {
        const parts = [];
        if (state.rosterMeta) parts.push(`latest.json gebaut: ${state.rosterMeta}`);
        if (state.eventSignupsMeta && typeof state.eventSignupsMeta.total_entries === 'number') {
          parts.push(`Pool laut Build: ${state.eventSignupsMeta.total_entries} Einträge`);
        }
        const rebuildHint = 'Hinweis: Änderungen an event_signups_next.csv landen nach dem nächsten Roster-Build in latest.json.';
        const text = parts.length ? `${parts.join(' · ')} · ${rebuildHint}` : rebuildHint;
        if (elements.contextMeta) elements.contextMeta.textContent = text;
        if (elements.rosterMeta) elements.rosterMeta.textContent = text;
      }

      function populatePlayers() {
        const set = new Set();
        state.alliancePool.forEach(n => set.add(n.display || n.canon || ''));
        state.rosterPlayers.forEach(p => set.add(p.name));
        const names = Array.from(set).sort((a,b) => a.localeCompare(b, 'de', { sensitivity:'base' }));
        elements.playerOptions.innerHTML = '';
        names.forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          elements.playerOptions.appendChild(opt);
        });
      }

      function ensureAssignment(playerName) {
        const existing = state.assignments.find(r => (r.PlayerName || '') === playerName);
        if (existing) return existing;
        const blank = { PlayerName: playerName, Group:'', Role:'', Commitment:'none', Source:'manual', Note:'' };
        state.assignments.push(blank);
        return blank;
      }

      function renderAssignments() {
        const rows = [...state.assignments];
        elements.assignmentBody.innerHTML = '';
        elements.assignmentCount.textContent = `${rows.length} Einträge`;
        elements.eventMeta.textContent = 'Alle Einträge beziehen sich auf das nächste Event (aktuelles Roster); Commitment=hard erzwingt Slots im nächsten Build.';
        elements.emptyState.style.display = rows.length ? 'none' : 'block';
        rows.forEach((row, idx) => {
          const tr = document.createElement('tr');
          const playerTd = document.createElement('td');
          playerTd.textContent = row.PlayerName || '–';
          tr.appendChild(playerTd);

          const groupTd = document.createElement('td');
          const groupSel = document.createElement('select');
          ['', 'A', 'B'].forEach(v => {
            const opt = document.createElement('option');
            opt.value = v; opt.textContent = v || '–';
            if ((row.Group || '') === v) opt.selected = true;
            groupSel.appendChild(opt);
          });
          groupSel.addEventListener('change', () => { row.Group = groupSel.value; updateSaveButtonState(); });
          groupTd.appendChild(groupSel);
          tr.appendChild(groupTd);

          const roleTd = document.createElement('td');
          const roleSel = document.createElement('select');
          ['', 'Start', 'Ersatz'].forEach(v => {
            const opt = document.createElement('option'); opt.value = v; opt.textContent = v || '–';
            if ((row.Role || '') === v) opt.selected = true;
            roleSel.appendChild(opt);
          });
          roleSel.addEventListener('change', () => { row.Role = roleSel.value; updateSaveButtonState(); });
          roleTd.appendChild(roleSel);
          tr.appendChild(roleTd);

          const commitmentTd = document.createElement('td');
          const commitmentSel = document.createElement('select');
          const commitmentBadge = document.createElement('span');
          commitmentBadge.className = 'tag';
          [['none','Nur Info'], ['hard','Verbindlich']].forEach(([value, label]) => {
            const opt = document.createElement('option');
            opt.value = value; opt.textContent = label;
            if ((row.Commitment || 'none') === value) opt.selected = true;
            commitmentSel.appendChild(opt);
          });
          const updateCommitmentBadge = () => {
            const c = row.Commitment || 'none';
            commitmentBadge.textContent = c === 'hard' ? 'verbindlich' : 'Info';
            commitmentBadge.className = c === 'hard' ? 'tag tag-hard' : 'tag';
          };
          commitmentSel.addEventListener('change', () => {
            row.Commitment = commitmentSel.value || 'none';
            updateCommitmentBadge();
            updateSaveButtonState();
          });
          updateCommitmentBadge();
          commitmentTd.appendChild(commitmentSel);
          commitmentTd.appendChild(commitmentBadge);
          commitmentTd.style.display = 'flex';
          commitmentTd.style.flexDirection = 'column';
          commitmentTd.style.gap = '0.35rem';
          tr.appendChild(commitmentTd);

          const sourceTd = document.createElement('td');
          const sourceSel = document.createElement('select');
          ['manual','callup-confirmed','notes','other'].forEach(v => {
            const opt = document.createElement('option'); opt.value = v; opt.textContent = v;
            if ((row.Source || '') === v) opt.selected = true;
            sourceSel.appendChild(opt);
          });
          sourceSel.addEventListener('change', () => { row.Source = sourceSel.value; updateSaveButtonState(); });
          sourceTd.appendChild(sourceSel);
          tr.appendChild(sourceTd);

          const noteTd = document.createElement('td');
          const noteInput = document.createElement('input');
          noteInput.type = 'text';
          noteInput.value = row.Note || '';
          noteInput.placeholder = 'z.B. Discord-Zusage';
          noteInput.addEventListener('input', () => { row.Note = noteInput.value; updateSaveButtonState(); });
          noteTd.appendChild(noteInput);
          tr.appendChild(noteTd);

          const ctxTd = document.createElement('td');
          const tags = document.createElement('div');
          tags.className = 'tags';
          const inAlliance = state.alliancePool.some(p => (p.display || '') === row.PlayerName && Number(p.in_alliance) === 1);
          const rosterEntry = state.rosterPlayers.find(p => p.name === row.PlayerName);
          if (inAlliance) { const tag = document.createElement('span'); tag.className='tag'; tag.textContent='In Allianz'; tags.appendChild(tag); }
          if (rosterEntry) { const tag = document.createElement('span'); tag.className='tag'; tag.textContent=`EB-Roster ${rosterEntry.group || ''} ${rosterEntry.role || ''}`.trim(); tags.appendChild(tag); }
          if (!tags.children.length) { const tag = document.createElement('span'); tag.className='tag'; tag.textContent='kein Kontext'; tags.appendChild(tag); }
          ctxTd.appendChild(tags);
          tr.appendChild(ctxTd);

          const actionTd = document.createElement('td');
          const delBtn = document.createElement('button');
          delBtn.textContent = 'Löschen';
          delBtn.addEventListener('click', () => {
            const idxGlobal = state.assignments.indexOf(row);
            if (idxGlobal >= 0) { state.assignments.splice(idxGlobal, 1); renderAssignments(); updateSaveButtonState(); }
          });
          actionTd.appendChild(delBtn);
          tr.appendChild(actionTd);

          elements.assignmentBody.appendChild(tr);
        });
        elements.emptyState.style.display = rows.length ? 'none' : 'block';
        renderRosterPreview();
      }

      function renderRosterPreview() {
        const container = elements.rosterPreview;
        if (!container) return;
        const groups = state.rosterGroups || {};
        if (!Object.keys(groups).length) {
          container.textContent = 'Keine Aufstellung geladen (latest.json fehlt).';
          return;
        }
        const signupsByCanon = new Map();
        state.assignments.forEach(a => {
          const canon = canonicalNameJS(a.PlayerName || '');
          if (!canon) return;
          signupsByCanon.set(canon, a);
        });
        const rosterCanon = new Set(state.rosterPlayers.map(p => p.canon).filter(Boolean));
        const extraByGroup = { A: [], B: [] };
        state.assignments.forEach(a => {
          const g = (a.Group || '').toUpperCase();
          const canon = canonicalNameJS(a.PlayerName || '');
          if (!canon || (g !== 'A' && g !== 'B')) return;
          if (!rosterCanon.has(canon)) extraByGroup[g].push(a);
        });

        const makeList = (entries, { highlight }) => {
          const ul = document.createElement('ul');
          ul.className = 'roster-list';
          if (!entries.length) {
            const li = document.createElement('li');
            li.textContent = '–';
            ul.appendChild(li);
            return ul;
          }
          entries.forEach(entry => {
            const li = document.createElement('li');
            const canon = canonicalNameJS(entry || entry.PlayerName || '');
            const signup = highlight && signupsByCanon.get(canon);
            const note = signup && signup.Note ? ` <span class="hint">${escapeHtml(signup.Note)}</span>` : '';
            if (typeof entry === 'string') {
              li.innerHTML = `${escapeHtml(entry)}${signup ? ' <span class="roster-badge">Event-Zusage</span>' : ''}${note}`;
            } else {
              const badge = `<span class="roster-badge extra-pill">Event-Zusage</span>`;
              const details = [];
              if (entry.Role) details.push(entry.Role);
              if (entry.Source) details.push(entry.Source);
              const meta = details.length ? ` <span class="hint">(${escapeHtml(details.join(' · '))})</span>` : '';
              li.innerHTML = `${escapeHtml(entry.PlayerName || '–')} ${badge}${meta}${entry.Note ? ` <span class="hint">${escapeHtml(entry.Note)}</span>` : ''}`;
            }
            ul.appendChild(li);
          });
          return ul;
        };

        container.innerHTML = '';
        ['A','B'].forEach(group => {
          const card = document.createElement('div');
          card.className = 'roster-card';
          const header = document.createElement('h3');
          header.textContent = `Gruppe ${group}`;
          card.appendChild(header);

          const startList = Array.isArray(groups[group]?.Start) ? groups[group].Start : [];
          const ersatzList = Array.isArray(groups[group]?.Ersatz) ? groups[group].Ersatz : [];

          const startLabel = document.createElement('div');
          startLabel.textContent = 'Start';
          card.appendChild(startLabel);
          card.appendChild(makeList(startList, { highlight: true }));

          const ersatzLabel = document.createElement('div');
          ersatzLabel.textContent = 'Ersatz';
          card.appendChild(ersatzLabel);
          card.appendChild(makeList(ersatzList, { highlight: true }));

          const extraLabel = document.createElement('div');
          extraLabel.textContent = 'Zusätzliche Zusagen (außerhalb Optimizer)';
          card.appendChild(extraLabel);
          card.appendChild(makeList(extraByGroup[group] || [], { highlight: false }));

          container.appendChild(card);
        });
      }

      function addAssignment() {
        const player = elements.playerInput.value.trim();
        if (!player) { setStatus('Bitte Spieler auswählen.', 'warn'); elements.playerInput.focus(); return; }
        const entry = ensureAssignment(player);
        entry.Group = elements.groupInput.value;
        entry.Role = elements.roleInput.value;
        entry.Commitment = elements.commitmentInput.value || 'none';
        entry.Source = elements.sourceInput.value || 'manual';
        entry.Note = elements.noteInput.value;
        renderAssignments();
        updateSaveButtonState();
        setStatus('Eintrag hinzugefügt/aktualisiert.', 'info');
      }

      async function reloadData() {
        setLoading(true);
        try {
          await loadAssignments();
          await loadRoster();
          populatePlayers();
          renderAssignments();
          setStatus('Daten geladen.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus(`Laden fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setLoading(false);
          updateSaveButtonState();
        }
      }

      async function saveChanges() {
        if (state.loading || state.saving) return;
        const workerUrl = elements.workerUrl.value.trim();
        const adminKey = elements.adminKey.value.trim();
        const branch = elements.branch.value.trim() || 'main';
        if (!workerUrl) { setStatus('Worker-URL fehlt.', 'error'); return; }
        if (!adminKey) { setStatus('Admin-Key erforderlich.', 'error'); return; }
        const content = buildCurrentCsv();
        setSaving(true);
        setStatus('Speichere event_signups_next.csv…', 'info');
        try {
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_signups_next.csv',
            content,
            branch,
            message: 'admin: update event_signups_next.csv via event assignments ui',
          });
          state.originalCsv = content;
          setStatus('Event-Zusagen gespeichert.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus(`Speichern fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setSaving(false);
          updateSaveButtonState();
        }
      }

      async function resetPool() {
        if (state.loading || state.saving) return;
        const workerUrl = elements.workerUrl.value.trim();
        const adminKey = elements.adminKey.value.trim();
        const branch = elements.branch.value.trim() || 'main';
        if (!workerUrl) { setStatus('Worker-URL fehlt.', 'error'); return; }
        if (!adminKey) { setStatus('Admin-Key erforderlich.', 'error'); return; }
        const confirmReset = window.confirm('Pool wirklich leeren? Alle Zusagen für das nächste Event werden entfernt.');
        if (!confirmReset) return;
        const headers = state.headers.length ? state.headers : [...DEFAULT_HEADERS];
        const emptyCsv = buildCsv(headers, []);
        setSaving(true);
        setStatus('Leere event_signups_next.csv…', 'info');
        try {
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_signups_next.csv',
            content: emptyCsv,
            branch,
            message: 'admin: reset event_signups_next.csv via event assignments ui',
          });
          state.assignments = [];
          state.originalCsv = emptyCsv;
          renderAssignments();
          setStatus('Pool geleert.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus(`Reset fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setSaving(false);
          updateSaveButtonState();
        }
      }

      async function writeFile(workerUrl, adminKey, payload) {
        const headers = { 'Content-Type': 'application/json', 'X-Admin-Key': adminKey };
        const response = await fetch(workerUrl, { method:'POST', headers, body: JSON.stringify(payload) });
        if (!response.ok) { const text = await response.text().catch(() => ''); throw new Error(text || `HTTP ${response.status}`); }
        const result = await response.json().catch(() => ({}));
        if (result && result.ok === false) throw new Error(result.error || 'Worker-Fehler');
        return result;
      }

      function persistSettings() {
        const payload = { workerUrl: elements.workerUrl.value, branch: elements.branch.value, adminKey: elements.adminKey.value };
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(payload));
      }
      function restoreSettings() {
        const saved = localStorage.getItem(SETTINGS_KEY);
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
            if (parsed.branch) elements.branch.value = parsed.branch;
            if (parsed.adminKey) elements.adminKey.value = parsed.adminKey;
          } catch (err) { console.warn('Settings konnten nicht gelesen werden', err); }
        } else {
          const shared = localStorage.getItem('dsro-admin-settings');
          if (shared) {
            try {
              const parsed = JSON.parse(shared);
              if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
              if (parsed.customBranch) elements.branch.value = parsed.customBranch;
              if (parsed.branchSelect) elements.branch.value = parsed.branchSelect;
              if (parsed.adminKey) elements.adminKey.value = parsed.adminKey;
            } catch (err) { console.warn('Shared settings konnten nicht gelesen werden', err); }
          }
        }
      }

      function initEvents() {
        elements.reloadBtn.addEventListener('click', reloadData);
        elements.saveBtn.addEventListener('click', saveChanges);
        elements.addBtn.addEventListener('click', addAssignment);
        if (elements.resetBtn) elements.resetBtn.addEventListener('click', resetPool);
        ['workerUrl','branch','adminKey'].forEach(key => elements[key].addEventListener('change', persistSettings));
        elements.playerInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addAssignment(); } });
      }

      restoreSettings();
      initEvents();
      reloadData();
    })();
  </script>
</body>
</html>
