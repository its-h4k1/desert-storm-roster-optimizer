<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Event-Zusagen &amp; manuelle Gruppen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <link rel="stylesheet" href="admin.css" />
  <style>
    body { margin: 0; background: var(--bg); color: var(--text); }
    .page-header { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-start; position:sticky; top:0; background:var(--glass); padding:1rem 1.1rem; border-bottom:1px solid var(--border); z-index:5; }
    .page-header h1 { margin:0; font-size:1.45rem; }
    .page-header .eyebrow { margin:0; color:var(--text-muted); font-size:0.9rem; letter-spacing:0.02em; text-transform:uppercase; }
    .page-header .meta-line { margin:0.15rem 0 0; color:var(--text-muted); font-size:0.95rem; }
    .header-meta { display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap; margin-left:auto; }
    .labelled-value { display:flex; gap:0.4rem; align-items:center; padding:0.35rem 0.65rem; border:1px solid var(--border); border-radius:0.75rem; background:var(--panel-muted); color:var(--text-muted); font-weight:600; }
    .settings { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-end; }
    .settings-toggle { border:1px solid var(--border); border-radius:0.85rem; padding:0.35rem 0.65rem; background:var(--panel-muted); }
    .settings-toggle summary { list-style:none; cursor:pointer; display:flex; align-items:center; gap:0.4rem; font-weight:600; color:var(--text-muted); }
    .settings-toggle summary::marker { display:none; }
    .settings-toggle summary::-webkit-details-marker { display:none; }
    .settings-toggle[open] { background:var(--panel); }
    .settings-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:0.75rem; margin-top:0.75rem; }
    .settings-actions { display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; justify-content:flex-end; margin-top:0.5rem; }
    .toolbar { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center; justify-content:space-between; padding:0.75rem 0; }
    .toolbar-actions { display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; }
    .toolbar-meta { display:flex; gap:0.6rem; flex-wrap:wrap; align-items:center; }
    label { display:flex; flex-direction:column; gap:0.35rem; font-size:0.9rem; color:var(--text-muted); }
    input[type="text"], input[type="search"], input[type="password"], select, textarea { font:inherit; padding:0.5rem 0.65rem; border-radius:0.75rem; border:1px solid var(--border); background:var(--bg-alt); color:var(--text); min-width:12rem; }
    input:focus, select:focus, textarea:focus { outline:2px solid rgba(37,99,235,0.35); outline-offset:1px; }
    textarea { resize:vertical; min-height:48px; }
    button { font:inherit; border:1px solid var(--border); border-radius:0.75rem; padding:0.55rem 1rem; background:#fff; color:var(--text); cursor:pointer; display:inline-flex; align-items:center; gap:0.4rem; }
    button:hover { background:#f8fafc; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    .admin-content { width:min(1400px,100%); }
    .page-inner { max-width:1400px; }
    .admin-section { padding:1.1rem; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:1rem; padding:1rem; box-shadow:var(--shadow-panel,0 18px 40px rgba(15,23,42,0.08)); display:grid; gap:0.75rem; }
    .panel h2 { margin:0; }
    .panel.compact { gap:0.5rem; }
    .help-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); gap:0.75rem; }
    .help-card { padding:0.85rem; background:var(--panel-muted); border:1px solid var(--border); border-radius:0.85rem; display:grid; gap:0.35rem; }
    .accordion { border:1px solid var(--border); border-radius:0.9rem; background:var(--panel-muted); }
    .accordion summary { cursor:pointer; padding:0.85rem 1rem; list-style:none; display:flex; align-items:center; justify-content:space-between; gap:0.5rem; font-weight:600; }
    .accordion summary::marker { display:none; }
    .accordion summary::-webkit-details-marker { display:none; }
    .accordion[open] { background:var(--panel); }
    .accordion .accordion-body { padding:0 1rem 1rem; display:grid; gap:0.75rem; }
    .layout-two-col { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
    .add-help { color:var(--text-muted); font-size:0.9rem; }
    .controls { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center; }
    .spacer { flex:1; min-width:40px; }
    .pill { display:inline-flex; align-items:center; gap:0.35rem; padding:0.25rem 0.6rem; border-radius:999px; font-size:0.85rem; background:var(--bg-alt); color:var(--text); border:1px solid var(--border); }
    .pill.info { background:#e0f2fe; color:#075985; border-color:#bae6fd; }
    .table-wrapper { border:1px solid var(--border); border-radius:0.85rem; overflow:auto; box-shadow:var(--shadow-card); background:var(--panel-muted); }
    table { width:100%; border-collapse:collapse; min-width:860px; }
    thead { background:var(--bg-alt); position:sticky; top:0; z-index:3; text-transform:uppercase; font-size:0.8rem; letter-spacing:0.04em; }
    th, td { padding:0.7rem 0.85rem; border-bottom:1px solid var(--border); text-align:left; vertical-align:top; }
    tbody tr:nth-child(2n) td { background:var(--panel-muted); }
    .row-actions { display:flex; gap:0.4rem; flex-wrap:wrap; }
    .tags { display:flex; gap:0.35rem; flex-wrap:wrap; }
    .tag { padding:0.25rem 0.55rem; border-radius:0.65rem; border:1px solid var(--border); background:var(--bg-alt); font-size:0.8rem; color:var(--text-muted); }
    .tag-hard { background:#fef2f2; border-color:#fecaca; color:#991b1b; font-weight:600; }
    .tag-callup { background:#eff6ff; border-color:#bfdbfe; color:#1d4ed8; font-weight:600; }
    .tag-fix { background:#f5f5f5; border-color:#d4d4d8; color:#3f3f46; font-weight:600; display:inline-flex; align-items:center; gap:0.35rem; }
    .callup-note { color:#1d4ed8; font-weight:600; font-size:0.9rem; display:inline-flex; align-items:center; gap:0.3rem; }
    tr.from-callup td { background:linear-gradient(90deg, rgba(239,246,255,0.6), rgba(255,255,255,0)); }
    .status-bar { position:sticky; bottom:0; background:var(--glass); border-top:1px solid var(--border); padding:0.75rem 1rem; display:flex; gap:0.6rem; align-items:center; box-shadow:0 -8px 24px rgba(15,23,42,0.08); flex-wrap:wrap; }
    .status-badge { display:inline-flex; align-items:center; gap:0.35rem; padding:0.35rem 0.7rem; border-radius:999px; font-weight:600; font-size:0.9rem; }
    .status-info { background:#e0f2fe; color:#075985; }
    .status-warn { background:#fff7ed; color:#9a3412; }
    .status-ok { background:#dcfce7; color:#14532d; }
    .status-error { background:#fee2e2; color:#991b1b; }
    .roster-preview { display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:0.75rem; }
    .roster-card { border:1px solid var(--border); border-radius:0.85rem; padding:0.85rem; background:var(--panel-muted); display:grid; gap:0.4rem; }
    .roster-card h3 { margin:0; font-size:1rem; display:flex; align-items:center; justify-content:space-between; gap:0.5rem; }
    .roster-list { list-style:none; padding:0; margin:0.35rem 0 0; display:grid; gap:0.25rem; }
    .roster-badge { display:inline-flex; align-items:center; gap:0.35rem; padding:0.2rem 0.55rem; border-radius:999px; background:#eef2ff; color:#312e81; border:1px solid #c7d2fe; font-size:0.78rem; }
    .extra-pill { background:#ecfeff; border:1px solid #a5f3fc; color:#0f172a; }
    @media (max-width: 960px) { .page-header { position:static; } label { width:100%; } input, select, textarea, button { width:100%; } button { justify-content:center; } table { min-width:800px; } .header-meta { width:100%; justify-content:flex-start; } .toolbar { flex-direction:column; align-items:flex-start; } }
  </style>
</head>
<body>
  <div class="admin-shell">
    <aside class="admin-sidebar">
      <div class="admin-sidebar-header">
        <div class="admin-logo">ELT Admin</div>
        <button class="sidebar-close" aria-label="Navigation schlie√üen">‚úï</button>
      </div>
      <nav class="admin-nav">
        <a href="index.html">CSV &amp; Datei-Tools</a>
        <a href="events.html">Events erfassen</a>
        <a href="players.html">Spieler &amp; Aliase</a>
        <a href="absences.html">Absenzen</a>
        <a href="group-preferences.html">Gruppenpr√§ferenzen</a>
        <a href="event-assignments.html" class="active">Event-Zusagen</a>
        <a href="noshow-dashboard.html">No-Show Analyse</a>
        <a href="callup-assistant.html">Callup-Assistent</a>
      </nav>
    </aside>

    <div class="admin-main">
      <header class="admin-header">
        <button class="sidebar-toggle" aria-label="Navigation √∂ffnen">‚ò∞</button>
        <div class="page-title">
          <p>Admin ¬∑ Events</p>
          <h1>Event-Zusagen &amp; manuelle Gruppen</h1>
        </div>
        <div class="admin-header-actions">
          <a class="btn ghost" href="../index.html">Zur Roster-Ansicht</a>
        </div>
      </header>

      <main class="admin-content">
        <section class="admin-section page-wrapper">
          <div class="page-inner">
            <header class="page-header">
              <div style="flex:1;min-width:260px;">
                <p class="eyebrow">Admin ¬∑ Event-Pool</p>
                <h1>Zusage-Pool f√ºrs n√§chste Event</h1>
                <p id="contextMeta" class="meta-line">L√§dt out/latest.json ‚Ä¶</p>
              </div>
              <div class="header-meta">
                <div class="labelled-value" id="eventQuickMeta">n√§chstes Event ¬∑ l√§dt ‚Ä¶</div>
                <span class="pill info" id="assignmentCount">‚Äì</span>
                <details class="settings-toggle">
                  <summary>‚öôÔ∏è Einstellungen</summary>
                  <div class="settings-grid">
                    <label>Worker URL
                      <input id="workerUrl" type="text" value="https://ds-commit.hak1.workers.dev/write-file" spellcheck="false">
                    </label>
                    <label>Branch
                      <input id="branchInput" type="text" value="main" spellcheck="false">
                    </label>
                    <label>Admin-Key
                      <input id="adminKey" type="password" placeholder="r4-admin" autocomplete="off">
                    </label>
                  </div>
                  <div class="settings-actions">
                    <small class="hint" style="color:var(--text-muted);">Wird lokal gespeichert; wirkt auf Speichern/Reset.</small>
                  </div>
                </details>
              </div>
            </header>

            <main class="page-main" style="display:grid;gap:1rem;">
              <section class="panel compact">
                <div class="toolbar">
                  <div style="display:grid; gap:0.35rem; min-width:280px;">
                    <strong>Kontext n√§chstes Event</strong>
                    <small class="hint" style="color:var(--text-muted);">Alle Eintr√§ge gelten f√ºr das kommende Event (aktuelles Roster). <code>Commitment=hard</code> = verbindliche Zusage / Fixplatz im n√§chsten Build; bei Event-Wechsel den Pool leeren.</small>
                  </div>
                  <div class="toolbar-meta">
                    <button id="resetBtn" class="ghost" style="border-color:var(--border);color:#b91c1c;">Zusage-Pool leeren</button>
                    <div class="toolbar-actions">
                      <button id="reloadBtn" class="ghost">Neu laden</button>
                      <button id="saveBtn">Speichern</button>
                    </div>
                  </div>
                </div>
              </section>

              <div class="layout-two-col">
                <section class="panel">
                  <h2>Spieler hinzuf√ºgen</h2>
                  <div class="controls" style="gap:0.65rem;">
                    <label style="min-width:220px;flex:1;">Spieler (Allianz oder Roster)
                      <input type="search" id="playerInput" list="playerOptions" placeholder="Name eingeben‚Ä¶" autocomplete="off">
                    </label>
                    <label>Gruppe
                      <select id="groupInput">
                        <option value="">‚Äì</option>
                        <option value="A">A</option>
                        <option value="B">B</option>
                      </select>
                    </label>
                    <label>Rolle
                      <select id="roleInput">
                        <option value="">‚Äì</option>
                        <option value="Start">Start</option>
                        <option value="Ersatz">Ersatz</option>
                      </select>
                    </label>
                    <label>Verbindlichkeit
                      <select id="commitmentInput">
                        <option value="none">Nur Info</option>
                        <option value="hard">Verbindlich (Commitment=hard)</option>
                      </select>
                    </label>
                    <label style="flex:1;min-width:200px;">Notiz (optional)
                      <input type="text" id="noteInput" placeholder="z.B. Discord-Zusage">
                    </label>
                    <button id="addBtn">Hinzuf√ºgen</button>
                  </div>
                  <p class="add-help">Quelle wird automatisch gesetzt (z.B. manuell oder aus Callup) und dient nur zur Dokumentation.</p>
                </section>

                <section class="panel">
                  <div class="controls" style="margin-bottom:0.5rem; align-items:flex-start; gap:0.35rem;">
                    <div style="display:grid; gap:0.25rem;">
                      <h2 style="margin:0;">Zugeordnete Teilnehmer</h2>
                      <span id="eventMeta" class="hint" style="color:var(--text-muted);"></span>
                    </div>
                  </div>
                  <div class="table-wrapper">
                    <table>
                      <thead>
                        <tr>
                          <th>Spieler</th>
                          <th>Gruppe</th>
                          <th>Rolle</th>
                          <th>Verbindlichkeit</th>
                          <th>Quelle</th>
                          <th>Notiz</th>
                          <th>Roster-Kontext</th>
                          <th>Aktion</th>
                        </tr>
                      </thead>
                      <tbody id="assignmentBody"></tbody>
                    </table>
                  </div>
                  <div id="emptyState" class="hint" style="color:var(--text-muted);display:none;">Noch keine Zusagen im Pool.</div>
                  <p class="hint" style="color:var(--text-muted);">Quelle beeinflusst die Aufstellung nicht; sie zeigt nur an, ob ein Eintrag manuell oder aus dem Callup-Assistenten stammt.</p>
                </section>
              </div>

              <details class="accordion" id="rosterPreviewPanel">
                <summary>
                  <div style="display:grid; gap:0.1rem;">
                    <span>Optimierte Aufstellung (n√§chstes Event)</span>
                    <small style="color:var(--text-muted);">Zeigt die aktuelle Aufstellung aus <code>latest.json</code>; wirkt nach n√§chstem Roster-Build.</small>
                  </div>
                  <span id="rosterMeta" class="hint" style="color:var(--text-muted);"></span>
                </summary>
                <div class="accordion-body">
                  <div id="rosterPreview" class="roster-preview"></div>
                </div>
              </details>

              <details class="accordion">
                <summary>Hintergrund &amp; Funktionsweise</summary>
                <div class="accordion-body">
                  <div class="help-grid">
                    <div class="help-card">
                      <strong>Dauerhafte Gruppenpr√§ferenzen</strong>
                      <ul>
                        <li>Quelle: <code>data/alliance.csv</code> (Spalten <code>PrefGroup</code>, <code>PrefMode</code>, <code>PrefBoost</code>).</li>
                        <li>Wirken langfristig auf den Optimizer.</li>
                      </ul>
                    </div>
                    <div class="help-card">
                      <strong>Event-Zusagen (n√§chstes Event)</strong>
                      <ul>
                        <li>Overlay f√ºr das <em>n√§chste</em> Event: basiert auf <code>out/latest.json</code>.</li>
                        <li>Kein Event-Browser; der Pool gilt immer f√ºr das n√§chste Build.</li>
                        <li>Wird nach dem n√§chsten Build in <code>latest.json</code> gespiegelt.</li>
                      </ul>
                    </div>
                    <div class="help-card">
                      <strong>Verbindlichkeit &amp; Trennung</strong>
                      <ul>
                        <li><code>Commitment=hard</code> = verbindliche Zusage / Fixplatz im n√§chsten Roster-Build.</li>
                        <li>Event-Zusagen sind unabh√§ngig von <code>PrefGroup</code>; Reset leert nur den Zusage-Pool.</li>
                      </ul>
                    </div>
                    <div class="help-card">
                      <strong>Sync aus Callup-Assistent</strong>
                      <ul>
                        <li><code>Source=callup-confirmed</code> kommt vom Callup-Assistenten (‚ÄûZugesagt (Roster √ºbernehmen)‚Äú).</li>
                        <li>Beim Speichern werden diese Eintr√§ge dort automatisch aktualisiert.</li>
                        <li>Meist keine Anpassung n√∂tig; Quelle bleibt zur Dokumentation erhalten.</li>
                      </ul>
                    </div>
                  </div>
                </div>
              </details>
            </main>
          </div>
        </section>
      </main>
    </div>
  </div>
  <div class="admin-overlay"></div>

  <div class="status-bar">
    <span id="statusBadge" class="status-badge status-info">Bereit</span>
    <div id="statusText" class="status-text">Noch keine √Ñnderungen.</div>
  </div>

  <datalist id="playerOptions"></datalist>

  <script src="../shared.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="admin.js"></script>
  <script>
    (function(){
      const elements = {
        workerUrl: document.getElementById('workerUrl'),
        branch: document.getElementById('branchInput'),
        adminKey: document.getElementById('adminKey'),
        reloadBtn: document.getElementById('reloadBtn'),
        saveBtn: document.getElementById('saveBtn'),
        playerInput: document.getElementById('playerInput'),
        playerOptions: document.getElementById('playerOptions'),
        groupInput: document.getElementById('groupInput'),
        roleInput: document.getElementById('roleInput'),
        commitmentInput: document.getElementById('commitmentInput'),
        noteInput: document.getElementById('noteInput'),
        addBtn: document.getElementById('addBtn'),
        assignmentBody: document.getElementById('assignmentBody'),
        assignmentCount: document.getElementById('assignmentCount'),
        emptyState: document.getElementById('emptyState'),
        statusBadge: document.getElementById('statusBadge'),
        statusText: document.getElementById('statusText'),
        eventMeta: document.getElementById('eventMeta'),
        contextMeta: document.getElementById('contextMeta'),
        eventQuickMeta: document.getElementById('eventQuickMeta'),
        resetBtn: document.getElementById('resetBtn'),
        rosterPreview: document.getElementById('rosterPreview'),
        rosterMeta: document.getElementById('rosterMeta'),
      };

      const SETTINGS_KEY = 'dsro-event-assignments-settings';
      // Commitment existierte bereits als CSV-Spalte, wurde in dieser UI jedoch ignoriert; jetzt wird sie mitgelesen und mitgeschrieben.
      const DEFAULT_HEADERS = ['PlayerName','Group','Role','Commitment','Source','Note'];
      const branchOverride = (new URL(location.href)).searchParams.get('branch');
      const cacheBuster = `?v=${Date.now()}`;
      const canonicalNameJS = (window.dsroShared && typeof window.dsroShared.canonicalNameJS === 'function')
        ? window.dsroShared.canonicalNameJS
        : (value => {
            if (value == null) return '';
            return String(value).toLowerCase().trim().replace(/\s+/g, ' ');
          });
      const escapeHtml = (window.dsroShared && typeof window.dsroShared.escapeHtml === 'function')
        ? window.dsroShared.escapeHtml
        : (value => value == null ? '' : String(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;'));
      const computeSiteRoot = (window.dsroShared && typeof window.dsroShared.computeSiteRoot === 'function')
        ? window.dsroShared.computeSiteRoot
        : (pathname => {
            const path = pathname || '/';
            const adminIdx = path.indexOf('/admin/');
            if (adminIdx !== -1) return path.slice(0, adminIdx + 1);
            return path.endsWith('/') ? path : path.replace(/[^/]*$/, '/');
          });
      const buildLatestJsonUrl = (window.dsroShared && typeof window.dsroShared.buildLatestJsonUrl === 'function')
        ? window.dsroShared.buildLatestJsonUrl
        : ({ branchOverride: bOverride, cacheBuster: buster, siteRoot }) => {
            const base = siteRoot || computeSiteRoot(location.pathname || '/');
            if (bOverride) {
              return `https://raw.githubusercontent.com/its-h4k1/desert-storm-roster-optimizer/${bOverride}/out/latest.json${buster}`;
            }
            return `${base}out/latest.json${buster}`;
          };
      const SITE_ROOT = computeSiteRoot(location.pathname || '/');
      const LATEST_JSON_URL = buildLatestJsonUrl({ branchOverride, cacheBuster, siteRoot: SITE_ROOT });
      const REPO_OWNER = 'its-h4k1';
      const REPO_NAME = 'desert-storm-roster-optimizer';
      // Admin Event Assignments uses the same latest.json source as the main roster UI: docs/out/latest.json via GitHub Pages (raw URL only when ?branch=<name> is set).
      const state = {
        assignments: [],
        headers: [],
        originalCsv: '',
        loading: false,
        saving: false,
        alliancePool: [],
        rosterPlayers: [],
        rosterIndex: new Map(),
        rosterGroups: {},
        rosterMeta: null,
        eventSignupsMeta: null,
      };

      // Konzept-Notiz: Dauerhafte Gruppenpr√§ferenzen (data/alliance.csv: PrefGroup/PrefMode/PrefBoost) steuern den Optimizer langfristig.
      // Der Zusage-Pool (data/event_signups_next.csv) geh√∂rt immer zum n√§chsten Event (aktuelles out/latest.json) und √ºberschreibt den Optimizer nicht dauerhaft.

      function normalizeLineEndings(text) { return (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n'); }
      function ensureTrailingNewline(text) { if (!text) return '\n'; return /\n$/.test(text) ? text : text + '\n'; }
      function formatSourceLabel(value) {
        if (value === 'manual') return 'Manuell';
        if (value === 'callup-confirmed') return 'Aus Callup';
        return value || '‚Äì';
      }
      const FORCED_SOURCE_LABELS = { manual: 'Manuell', 'callup-confirmed': 'Callup' };
      function normalizeForcedSignup(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const commitment = (raw.commitment || raw.Commitment || '').toString().toLowerCase();
        if (commitment !== 'hard') return null;
        const source = raw.source || raw.Source || '';
        const note = raw.note || raw.Note || '';
        const overbooked = Boolean(raw.overbooked || raw.Overbooked);
        return { commitment, source, note, overbooked };
      }
      function buildFixBadge(forcedSignup) {
        const normalized = normalizeForcedSignup(forcedSignup);
        if (!normalized) return '';
        const sourceLabel = normalized.source ? (FORCED_SOURCE_LABELS[normalized.source] || normalized.source) : '';
        const label = sourceLabel ? `verbindlich ¬∑ ${sourceLabel}` : 'verbindlich';
        const tooltipParts = ['Verbindliche Zusage aus event_signups_next.csv'];
        if (sourceLabel) tooltipParts.push(`Quelle: ${sourceLabel}`);
        if (normalized.overbooked) tooltipParts.push('√ºber Kapazit√§t');
        return `<span class="tag tag-fix" title="${escapeHtml(tooltipParts.join(' ¬∑ '))}">üîí ${escapeHtml(label)}</span>`;
      }
      function formatCsvValue(value) {
        if (value === null || value === undefined) return '';
        const str = value.toString();
        if (str.includes('"') || str.includes(',') || str.includes('\n')) return `"${str.replace(/"/g, '""')}"`;
        return str;
      }
      function parseCsv(text) {
        const res = Papa.parse(normalizeLineEndings(text || ''), { header:true, skipEmptyLines:true });
        const rows = Array.isArray(res.data) ? res.data : [];
        return { headers: res.meta?.fields || [], rows };
      }
      function buildCsv(headers, rows) {
        const headerLine = headers.join(',');
        const lines = rows.map(row => headers.map(h => formatCsvValue(row[h] ?? '')).join(','));
        return ensureTrailingNewline([headerLine, ...lines].join('\n'));
      }
      function safeBranchName(value) {
        const trimmed = (value || '').trim();
        const cleaned = trimmed.replace(/[^\w\-\/]/g, '');
        return cleaned || 'main';
      }
      function buildRawDataUrl(relativePath, branchValue) {
        const cleanPath = (relativePath || '').replace(/^\//, '');
        const branch = safeBranchName(branchValue || 'main');
        return `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${branch}/${cleanPath}${cacheBuster}`;
      }
      async function fetchText(path, { allow404 = false } = {}) {
        const res = await fetch(path, { cache:'no-store' });
        if (!res.ok) {
          if (allow404 && res.status === 404) return null;
          throw new Error(`${path}: HTTP ${res.status}`);
        }
        return await res.text();
      }
      async function loadAssignments() {
        const branch = branchOverride || elements.branch.value || 'main';
        const csvUrl = buildRawDataUrl('data/event_signups_next.csv', branch);
        try {
          const text = await fetchText(csvUrl, { allow404: true });
          if (!text) {
            state.headers = [...DEFAULT_HEADERS];
            state.assignments = [];
            state.originalCsv = buildCurrentCsv();
            return;
          }
          const { headers, rows } = parseCsv(text);
          const mergedHeaders = headers.length ? Array.from(new Set([...headers, ...DEFAULT_HEADERS])) : [...DEFAULT_HEADERS];
          state.headers = mergedHeaders;
          const baseRow = DEFAULT_HEADERS.reduce((acc, k) => ({ ...acc, [k]: k === 'Commitment' ? 'none' : '' }), {});
          state.assignments = rows.map(r => ({
            ...baseRow,
            ...r,
            Source: r.Source || r.source || 'manual',
            Commitment: r.Commitment || r.commitment || baseRow.Commitment,
          }));
          state.originalCsv = buildCurrentCsv();
        } catch (err) {
          console.warn('event_signups_next.csv konnte nicht geladen werden, starte leer', err);
          state.headers = [...DEFAULT_HEADERS];
          state.assignments = [];
          state.originalCsv = buildCurrentCsv();
        }
      }
      async function loadRoster() {
        const rosterPath = LATEST_JSON_URL;
        try {
          const response = await fetch(rosterPath, { cache:'no-store' });
          if (!response.ok) throw new Error(`${rosterPath}: HTTP ${response.status}`);
          const data = await response.json();
          const players = Array.isArray(data?.players) ? data.players : [];
          state.alliancePool = Array.isArray(data?.alliance_pool) ? data.alliance_pool : [];
          const rosterIndex = new Map();
          state.rosterPlayers = players
            .map(p => ({
              name: p.display || p.canon || '',
              group: p.group || '',
              role: p.role || '',
              canon: canonicalNameJS(p.canon || p.display || ''),
              forcedSignup: normalizeForcedSignup(p.forced_signup || (p.has_forced_signup ? { commitment:'hard', source:p.event_signup?.source } : null)),
            }))
            .filter(p => p.name);
          state.rosterPlayers.forEach(p => { if (p.canon) rosterIndex.set(p.canon, p); });
          state.rosterIndex = rosterIndex;
          state.rosterGroups = (data && data.groups) || {};
          state.rosterMeta = data?.generated_at || null;
          state.eventSignupsMeta = data?.event_signups || null;
          updateContextMeta();
        } catch (err) {
          console.warn('latest.json nicht verf√ºgbar', err);
          state.rosterPlayers = [];
          state.rosterIndex = new Map();
          state.rosterGroups = {};
          state.rosterMeta = null;
          state.alliancePool = [];
          state.eventSignupsMeta = null;
          updateContextMeta();
        }
      }
      function buildCurrentCsv() {
        const headers = state.headers.length ? Array.from(new Set([...state.headers, ...DEFAULT_HEADERS])) : [...DEFAULT_HEADERS];
        const rows = state.assignments.map(entry => {
          const out = {};
          headers.forEach(h => { out[h] = entry[h] ?? ''; });
          return out;
        });
        rows.sort((a,b) => {
          const ga = (a.Group || '').toString();
          const gb = (b.Group || '').toString();
          if (ga !== gb) return ga.localeCompare(gb, 'de', { sensitivity:'base' });
          return (a.PlayerName || '').localeCompare((b.PlayerName || ''), 'de', { sensitivity:'base' });
        });
        return buildCsv(headers, rows);
      }
      function hasChanges() {
        const current = buildCurrentCsv();
        return normalizeLineEndings(current).trim() !== normalizeLineEndings(state.originalCsv).trim();
      }
      function setStatus(message, tone='info') {
        const toneClass = tone === 'ok' ? 'status-ok' : tone === 'warn' ? 'status-warn' : tone === 'error' ? 'status-error' : 'status-info';
        elements.statusBadge.className = 'status-badge ' + toneClass;
        elements.statusBadge.textContent = tone === 'ok' ? 'OK' : tone === 'error' ? 'Fehler' : tone === 'warn' ? 'Hinweis' : 'Status';
        elements.statusText.textContent = message;
      }
      function setLoading(isLoading) {
        state.loading = isLoading;
        elements.reloadBtn.disabled = isLoading || state.saving;
        if (elements.resetBtn) elements.resetBtn.disabled = isLoading || state.saving;
        updateSaveButtonState();
        if (isLoading) setStatus('Lade Daten‚Ä¶', 'info');
      }
      function setSaving(isSaving) {
        state.saving = isSaving;
        if (elements.resetBtn) elements.resetBtn.disabled = isSaving || state.loading;
        updateSaveButtonState();
      }
      function updateSaveButtonState() {
        elements.saveBtn.disabled = state.loading || state.saving || !hasChanges();
        elements.saveBtn.textContent = state.saving ? 'Speichert‚Ä¶' : 'Speichern';
      }

      function updateContextMeta() {
        const parts = [];
        if (state.rosterMeta) parts.push(`latest.json gebaut: ${state.rosterMeta}`);
        if (state.eventSignupsMeta && typeof state.eventSignupsMeta.total_entries === 'number') {
          parts.push(`Pool laut Build: ${state.eventSignupsMeta.total_entries} Eintr√§ge`);
        }
        const rebuildHint = 'Hinweis: √Ñnderungen an event_signups_next.csv landen nach dem n√§chsten Roster-Build in latest.json.';
        const text = parts.length ? `${parts.join(' ¬∑ ')} ¬∑ ${rebuildHint}` : rebuildHint;
        if (elements.contextMeta) elements.contextMeta.textContent = text;
        if (elements.rosterMeta) elements.rosterMeta.textContent = text;
        updateQuickMeta();
      }

      function updateQuickMeta() {
        const parts = [];
        if (state.eventSignupsMeta?.event_id) parts.push(`Event ${state.eventSignupsMeta.event_id}`);
        if (state.rosterMeta) parts.push(`Build: ${state.rosterMeta}`);
        parts.push(`Pool: ${state.assignments.length}`);
        const text = parts.length ? parts.join(' ¬∑ ') : 'n√§chstes Event';
        if (elements.eventQuickMeta) elements.eventQuickMeta.textContent = text;
      }

      function populatePlayers() {
        const set = new Set();
        state.alliancePool.forEach(n => set.add(n.display || n.canon || ''));
        state.rosterPlayers.forEach(p => set.add(p.name));
        const names = Array.from(set).sort((a,b) => a.localeCompare(b, 'de', { sensitivity:'base' }));
        elements.playerOptions.innerHTML = '';
        names.forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          elements.playerOptions.appendChild(opt);
        });
      }

      function ensureAssignment(playerName) {
        const existing = state.assignments.find(r => (r.PlayerName || '') === playerName);
        if (existing) return existing;
        const blank = { PlayerName: playerName, Group:'', Role:'', Commitment:'none', Source:'manual', Note:'' };
        state.assignments.push(blank);
        return blank;
      }

      function renderAssignments() {
        const rows = [...state.assignments];
        elements.assignmentBody.innerHTML = '';
        elements.assignmentCount.textContent = `${rows.length} Eintr√§ge`;
        elements.eventMeta.textContent = 'Alle Eintr√§ge beziehen sich auf das n√§chste Event (aktuelles Roster); Callup-Eintr√§ge sind blau markiert und nur zur Dokumentation.';
        elements.emptyState.style.display = rows.length ? 'none' : 'block';
        rows.forEach((row, idx) => {
          const tr = document.createElement('tr');
          const fromCallup = (row.Source || '') === 'callup-confirmed';
          if (fromCallup) tr.classList.add('from-callup');
          const playerTd = document.createElement('td');
          playerTd.textContent = row.PlayerName || '‚Äì';
          tr.appendChild(playerTd);

          const groupTd = document.createElement('td');
          const groupSel = document.createElement('select');
          ['', 'A', 'B'].forEach(v => {
            const opt = document.createElement('option');
            opt.value = v; opt.textContent = v || '‚Äì';
            if ((row.Group || '') === v) opt.selected = true;
            groupSel.appendChild(opt);
          });
          groupSel.disabled = fromCallup;
          groupSel.addEventListener('change', () => { row.Group = groupSel.value; updateSaveButtonState(); });
          groupTd.appendChild(groupSel);
          tr.appendChild(groupTd);

          const roleTd = document.createElement('td');
          const roleSel = document.createElement('select');
          ['', 'Start', 'Ersatz'].forEach(v => {
            const opt = document.createElement('option'); opt.value = v; opt.textContent = v || '‚Äì';
            if ((row.Role || '') === v) opt.selected = true;
            roleSel.appendChild(opt);
          });
          roleSel.disabled = fromCallup;
          roleSel.addEventListener('change', () => { row.Role = roleSel.value; updateSaveButtonState(); });
          roleTd.appendChild(roleSel);
          tr.appendChild(roleTd);

          const commitmentTd = document.createElement('td');
          const commitmentSel = document.createElement('select');
          const commitmentBadge = document.createElement('span');
          commitmentBadge.className = 'tag';
          [['none','Nur Info'], ['hard','Verbindlich']].forEach(([value, label]) => {
            const opt = document.createElement('option');
            opt.value = value; opt.textContent = label;
            if ((row.Commitment || 'none') === value) opt.selected = true;
            commitmentSel.appendChild(opt);
          });
          const updateCommitmentBadge = () => {
            const c = row.Commitment || 'none';
            commitmentBadge.textContent = c === 'hard' ? 'verbindlich' : 'Info';
            commitmentBadge.className = c === 'hard' ? 'tag tag-hard' : 'tag';
          };
          commitmentSel.disabled = fromCallup;
          commitmentSel.addEventListener('change', () => {
            row.Commitment = commitmentSel.value || 'none';
            updateCommitmentBadge();
            updateSaveButtonState();
          });
          updateCommitmentBadge();
          commitmentTd.appendChild(commitmentSel);
          commitmentTd.appendChild(commitmentBadge);
          commitmentTd.style.display = 'flex';
          commitmentTd.style.flexDirection = 'column';
          commitmentTd.style.gap = '0.35rem';
          tr.appendChild(commitmentTd);

          const sourceTd = document.createElement('td');
          const sourceText = document.createElement('span');
          sourceText.textContent = formatSourceLabel(row.Source);
          if (fromCallup) sourceText.className = 'tag tag-callup';
          sourceTd.appendChild(sourceText);
          if (fromCallup) {
            const note = document.createElement('div');
            note.className = 'callup-note';
            note.textContent = 'aus Callup-Assistent';
            sourceTd.appendChild(note);
          }
          tr.appendChild(sourceTd);

          const noteTd = document.createElement('td');
          const noteInput = document.createElement('input');
          noteInput.type = 'text';
          noteInput.value = row.Note || '';
          noteInput.placeholder = fromCallup ? 'Aus Callup; optional erg√§nzen' : 'z.B. Discord-Zusage';
          noteInput.addEventListener('input', () => { row.Note = noteInput.value; updateSaveButtonState(); });
          noteTd.appendChild(noteInput);
          tr.appendChild(noteTd);

          const ctxTd = document.createElement('td');
          const tags = document.createElement('div');
          tags.className = 'tags';
          const inAlliance = state.alliancePool.some(p => (p.display || '') === row.PlayerName && Number(p.in_alliance) === 1);
          const rosterEntry = state.rosterPlayers.find(p => p.name === row.PlayerName);
          if (inAlliance) { const tag = document.createElement('span'); tag.className='tag'; tag.textContent='In Allianz'; tags.appendChild(tag); }
          if (rosterEntry) { const tag = document.createElement('span'); tag.className='tag'; tag.textContent=`EB-Roster ${rosterEntry.group || ''} ${rosterEntry.role || ''}`.trim(); tags.appendChild(tag); }
          if (!tags.children.length) { const tag = document.createElement('span'); tag.className='tag'; tag.textContent='kein Kontext'; tags.appendChild(tag); }
          ctxTd.appendChild(tags);
          tr.appendChild(ctxTd);

          const actionTd = document.createElement('td');
          const delBtn = document.createElement('button');
          delBtn.textContent = 'L√∂schen';
          delBtn.addEventListener('click', () => {
            const idxGlobal = state.assignments.indexOf(row);
            if (idxGlobal >= 0) { state.assignments.splice(idxGlobal, 1); renderAssignments(); updateSaveButtonState(); }
          });
          actionTd.appendChild(delBtn);
          tr.appendChild(actionTd);

          elements.assignmentBody.appendChild(tr);
        });
        elements.emptyState.style.display = rows.length ? 'none' : 'block';
        renderRosterPreview();
        updateQuickMeta();
      }

      function renderRosterPreview() {
        const container = elements.rosterPreview;
        if (!container) return;
        const groups = state.rosterGroups || {};
        if (!Object.keys(groups).length) {
          container.textContent = 'Keine Aufstellung geladen (latest.json nicht verf√ºgbar).';
          return;
        }
        const signupsByCanon = new Map();
        state.assignments.forEach(a => {
          const canon = canonicalNameJS(a.PlayerName || '');
          if (!canon) return;
          signupsByCanon.set(canon, a);
        });
        const rosterCanon = new Set(state.rosterPlayers.map(p => p.canon).filter(Boolean));
        const forcedByCanon = new Map(state.rosterPlayers.filter(p => p.canon && p.forcedSignup).map(p => [p.canon, p.forcedSignup]));
        const extraByGroup = { A: [], B: [] };
        state.assignments.forEach(a => {
          const g = (a.Group || '').toUpperCase();
          const canon = canonicalNameJS(a.PlayerName || '');
          if (!canon || (g !== 'A' && g !== 'B')) return;
          if (!rosterCanon.has(canon)) extraByGroup[g].push(a);
        });

        const makeList = (entries, { highlight }) => {
          const ul = document.createElement('ul');
          ul.className = 'roster-list';
          if (!entries.length) {
            const li = document.createElement('li');
            li.textContent = '‚Äì';
            ul.appendChild(li);
            return ul;
          }
          entries.forEach(entry => {
            const li = document.createElement('li');
            const canon = canonicalNameJS(entry || entry.PlayerName || '');
            const signup = highlight && signupsByCanon.get(canon);
            const forcedBadge = buildFixBadge(forcedByCanon.get(canon));
            const note = signup && signup.Note ? ` <span class="hint">${escapeHtml(signup.Note)}</span>` : '';
            if (typeof entry === 'string') {
              li.innerHTML = `${escapeHtml(entry)}${forcedBadge ? ` ${forcedBadge}` : ''}${signup ? ' <span class="roster-badge">Event-Zusage</span>' : ''}${note}`;
            } else {
              const badge = `<span class="roster-badge extra-pill">Event-Zusage</span>`;
              const details = [];
              if (entry.Role) details.push(entry.Role);
              if (entry.Source) details.push(formatSourceLabel(entry.Source));
              const meta = details.length ? ` <span class="hint">(${escapeHtml(details.join(' ¬∑ '))})</span>` : '';
              li.innerHTML = `${escapeHtml(entry.PlayerName || '‚Äì')}${forcedBadge ? ` ${forcedBadge}` : ''} ${badge}${meta}${entry.Note ? ` <span class="hint">${escapeHtml(entry.Note)}</span>` : ''}`;
            }
            ul.appendChild(li);
          });
          return ul;
        };

        container.innerHTML = '';
        ['A','B'].forEach(group => {
          const card = document.createElement('div');
          card.className = 'roster-card';
          const header = document.createElement('h3');
          header.textContent = `Gruppe ${group}`;
          card.appendChild(header);

          const startList = Array.isArray(groups[group]?.Start) ? groups[group].Start : [];
          const ersatzList = Array.isArray(groups[group]?.Ersatz) ? groups[group].Ersatz : [];

          const startLabel = document.createElement('div');
          startLabel.textContent = 'Start';
          card.appendChild(startLabel);
          card.appendChild(makeList(startList, { highlight: true }));

          const ersatzLabel = document.createElement('div');
          ersatzLabel.textContent = 'Ersatz';
          card.appendChild(ersatzLabel);
          card.appendChild(makeList(ersatzList, { highlight: true }));

          const extraLabel = document.createElement('div');
          extraLabel.textContent = 'Zus√§tzliche Zusagen (au√üerhalb Optimizer)';
          card.appendChild(extraLabel);
          card.appendChild(makeList(extraByGroup[group] || [], { highlight: false }));

          container.appendChild(card);
        });
      }

      function addAssignment() {
        const player = elements.playerInput.value.trim();
        if (!player) { setStatus('Bitte Spieler ausw√§hlen.', 'warn'); elements.playerInput.focus(); return; }
        const entry = ensureAssignment(player);
        entry.Group = elements.groupInput.value;
        entry.Role = elements.roleInput.value;
        entry.Commitment = elements.commitmentInput.value || 'none';
        if (!entry.Source) entry.Source = 'manual';
        entry.Note = elements.noteInput.value;
        renderAssignments();
        updateSaveButtonState();
        setStatus('Eintrag hinzugef√ºgt/aktualisiert.', 'info');
      }

      async function reloadData() {
        setLoading(true);
        try {
          await loadAssignments();
          await loadRoster();
          populatePlayers();
          renderAssignments();
          setStatus('Daten geladen.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus(`Laden fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setLoading(false);
          updateSaveButtonState();
        }
      }

      async function saveChanges() {
        if (state.loading || state.saving) return;
        const workerUrl = elements.workerUrl.value.trim();
        const adminKey = elements.adminKey.value.trim();
        const branch = elements.branch.value.trim() || 'main';
        if (!workerUrl) { setStatus('Worker-URL fehlt.', 'error'); return; }
        if (!adminKey) { setStatus('Admin-Key erforderlich.', 'error'); return; }
        const content = buildCurrentCsv();
        setSaving(true);
        setStatus('Speichere event_signups_next.csv‚Ä¶', 'info');
        try {
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_signups_next.csv',
            content,
            branch,
            message: 'admin: update event_signups_next.csv via event assignments ui',
          });
          state.originalCsv = content;
          setStatus('Event-Zusagen gespeichert.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus(`Speichern fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setSaving(false);
          updateSaveButtonState();
        }
      }

      async function resetPool() {
        if (state.loading || state.saving) return;
        const workerUrl = elements.workerUrl.value.trim();
        const adminKey = elements.adminKey.value.trim();
        const branch = elements.branch.value.trim() || 'main';
        if (!workerUrl) { setStatus('Worker-URL fehlt.', 'error'); return; }
        if (!adminKey) { setStatus('Admin-Key erforderlich.', 'error'); return; }
        const confirmReset = window.confirm('Pool wirklich leeren? Alle Zusagen f√ºr das n√§chste Event werden entfernt.');
        if (!confirmReset) return;
        const headers = state.headers.length ? state.headers : [...DEFAULT_HEADERS];
        const emptyCsv = buildCsv(headers, []);
        setSaving(true);
        setStatus('Leere event_signups_next.csv‚Ä¶', 'info');
        try {
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_signups_next.csv',
            content: emptyCsv,
            branch,
            message: 'admin: reset event_signups_next.csv via event assignments ui',
          });
          state.assignments = [];
          state.originalCsv = emptyCsv;
          renderAssignments();
          setStatus('Pool geleert.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus(`Reset fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setSaving(false);
          updateSaveButtonState();
        }
      }

      async function writeFile(workerUrl, adminKey, payload) {
        const headers = { 'Content-Type': 'application/json', 'X-Admin-Key': adminKey };
        const response = await fetch(workerUrl, { method:'POST', headers, body: JSON.stringify(payload) });
        if (!response.ok) { const text = await response.text().catch(() => ''); throw new Error(text || `HTTP ${response.status}`); }
        const result = await response.json().catch(() => ({}));
        if (result && result.ok === false) throw new Error(result.error || 'Worker-Fehler');
        return result;
      }

      function persistSettings() {
        const payload = { workerUrl: elements.workerUrl.value, branch: elements.branch.value, adminKey: elements.adminKey.value };
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(payload));
      }
      function restoreSettings() {
        const saved = localStorage.getItem(SETTINGS_KEY);
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
            if (parsed.branch) elements.branch.value = parsed.branch;
            if (parsed.adminKey) elements.adminKey.value = parsed.adminKey;
          } catch (err) { console.warn('Settings konnten nicht gelesen werden', err); }
        } else {
          const shared = localStorage.getItem('dsro-admin-settings');
          if (shared) {
            try {
              const parsed = JSON.parse(shared);
              if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
              if (parsed.customBranch) elements.branch.value = parsed.customBranch;
              if (parsed.branchSelect) elements.branch.value = parsed.branchSelect;
              if (parsed.adminKey) elements.adminKey.value = parsed.adminKey;
            } catch (err) { console.warn('Shared settings konnten nicht gelesen werden', err); }
          }
        }
      }

      function initEvents() {
        elements.reloadBtn.addEventListener('click', reloadData);
        elements.saveBtn.addEventListener('click', saveChanges);
        elements.addBtn.addEventListener('click', addAssignment);
        if (elements.resetBtn) elements.resetBtn.addEventListener('click', resetPool);
        ['workerUrl','branch','adminKey'].forEach(key => elements[key].addEventListener('change', persistSettings));
        elements.playerInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addAssignment(); } });
      }

      restoreSettings();
      initEvents();
      reloadData();
    })();
  </script>
</body>
</html>
