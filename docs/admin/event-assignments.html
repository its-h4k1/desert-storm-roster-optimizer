<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Event-Zusagen &amp; manuelle Gruppen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <link rel="stylesheet" href="admin.css" />
  <style>
    body { margin: 0; background: var(--bg); color: var(--text); }
    .page-header { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-start; position:sticky; top:0; background:var(--glass); padding:1rem 1.1rem; border-bottom:1px solid var(--border); z-index:5; }
    .page-header h1 { margin:0; font-size:1.45rem; }
    .page-header .eyebrow { margin:0; color:var(--text-muted); font-size:0.9rem; letter-spacing:0.02em; text-transform:uppercase; }
    .page-header .meta-line { margin:0.15rem 0 0; color:var(--text-muted); font-size:0.95rem; }
    .header-meta { display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap; margin-left:auto; }
    .labelled-value { display:flex; gap:0.4rem; align-items:center; padding:0.35rem 0.65rem; border:1px solid var(--border); border-radius:0.75rem; background:var(--panel-muted); color:var(--text-muted); font-weight:600; }
    .build-status-line { display:flex; flex-wrap:wrap; gap:0.5rem; font-size:0.85rem; color:var(--text-muted); align-items:center; }
    .build-status-line a { color:#2563eb; text-decoration:none; }
    .build-status-line a:hover { text-decoration:underline; }
    .build-alert { border:1px solid #fcd34d; background:#fefce8; color:#92400e; border-radius:0.85rem; padding:0.85rem 1rem; display:grid; gap:0.35rem; }
    .build-alert strong { font-size:1rem; }
    .build-alert small { color:#b45309; }
    .settings { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-end; }
    .settings-toggle { border:1px solid var(--border); border-radius:0.85rem; padding:0.35rem 0.65rem; background:var(--panel-muted); }
    .settings-toggle summary { list-style:none; cursor:pointer; display:flex; align-items:center; gap:0.4rem; font-weight:600; color:var(--text-muted); }
    .settings-toggle summary::marker { display:none; }
    .settings-toggle summary::-webkit-details-marker { display:none; }
    .settings-toggle[open] { background:var(--panel); }
    .settings-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:0.75rem; margin-top:0.75rem; }
    .settings-actions { display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; justify-content:flex-end; margin-top:0.5rem; }
    .toolbar { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center; justify-content:space-between; padding:0.75rem 0; }
    .toolbar-actions { display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; }
    .toolbar-meta { display:flex; gap:0.6rem; flex-wrap:wrap; align-items:center; }
    label { display:flex; flex-direction:column; gap:0.35rem; font-size:0.9rem; color:var(--text-muted); }
    input[type="text"], input[type="search"], input[type="password"], select, textarea { font:inherit; padding:0.5rem 0.65rem; border-radius:0.75rem; border:1px solid var(--border); background:var(--bg-alt); color:var(--text); min-width:12rem; }
    input:focus, select:focus, textarea:focus { outline:2px solid rgba(37,99,235,0.35); outline-offset:1px; }
    textarea { resize:vertical; min-height:48px; }
    button { font:inherit; border:1px solid var(--border); border-radius:0.75rem; padding:0.55rem 1rem; background:#fff; color:var(--text); cursor:pointer; display:inline-flex; align-items:center; gap:0.4rem; }
    button:hover { background:#f8fafc; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    .admin-content { width:min(1400px,100%); }
    .page-inner { max-width:1400px; }
    .admin-section { padding:1.1rem; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:1rem; padding:1rem; box-shadow:var(--shadow-panel,0 18px 40px rgba(15,23,42,0.08)); display:grid; gap:0.75rem; }
    .panel h2 { margin:0; }
    .panel.compact { gap:0.5rem; }
    .help-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); gap:0.75rem; }
    .help-card { padding:0.85rem; background:var(--panel-muted); border:1px solid var(--border); border-radius:0.85rem; display:grid; gap:0.35rem; }
    .accordion { border:1px solid var(--border); border-radius:0.9rem; background:var(--panel-muted); }
    .accordion summary { cursor:pointer; padding:0.85rem 1rem; list-style:none; display:flex; align-items:center; justify-content:space-between; gap:0.5rem; font-weight:600; }
    .accordion summary::marker { display:none; }
    .accordion summary::-webkit-details-marker { display:none; }
    .accordion[open] { background:var(--panel); }
    .accordion .accordion-body { padding:0 1rem 1rem; display:grid; gap:0.75rem; }
    .layout-two-col { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
    .add-help { color:var(--text-muted); font-size:0.9rem; }
    .controls { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center; }
    .spacer { flex:1; min-width:40px; }
    .pill { display:inline-flex; align-items:center; gap:0.35rem; padding:0.25rem 0.6rem; border-radius:999px; font-size:0.85rem; background:var(--bg-alt); color:var(--text); border:1px solid var(--border); }
    .pill.info { background:#e0f2fe; color:#075985; border-color:#bae6fd; }
    .table-wrapper { border:1px solid var(--border); border-radius:0.85rem; overflow:auto; box-shadow:var(--shadow-card); background:var(--panel-muted); }
    table { width:100%; border-collapse:collapse; min-width:860px; }
    thead { background:var(--bg-alt); position:sticky; top:0; z-index:3; text-transform:uppercase; font-size:0.8rem; letter-spacing:0.04em; }
    th, td { padding:0.7rem 0.85rem; border-bottom:1px solid var(--border); text-align:left; vertical-align:top; }
    tbody tr:nth-child(2n) td { background:var(--panel-muted); }
    .row-actions { display:flex; gap:0.4rem; flex-wrap:wrap; }
    .tags { display:flex; gap:0.35rem; flex-wrap:wrap; }
    .tag { padding:0.25rem 0.55rem; border-radius:0.65rem; border:1px solid var(--border); background:var(--bg-alt); font-size:0.8rem; color:var(--text-muted); }
    .tag-hard { background:#fef2f2; border-color:#fecaca; color:#991b1b; font-weight:600; }
    .tag-callup { background:#eff6ff; border-color:#bfdbfe; color:#1d4ed8; font-weight:600; }
    .tag-decline { background:#fee2e2; border-color:#fecaca; color:#991b1b; font-weight:600; }
    .tag-noresp { background:#fff7ed; border-color:#fed7aa; color:#9a3412; font-weight:600; }
    .tag-fix { background:#f5f5f5; border-color:#d4d4d8; color:#3f3f46; font-weight:600; display:inline-flex; align-items:center; gap:0.35rem; }
    .callup-note { color:#1d4ed8; font-weight:600; font-size:0.9rem; display:inline-flex; align-items:center; gap:0.3rem; }
    tr.from-callup td { background:linear-gradient(90deg, rgba(239,246,255,0.6), rgba(255,255,255,0)); }
    .status-bar { position:sticky; bottom:0; background:var(--glass); border-top:1px solid var(--border); padding:0.75rem 1rem; display:flex; gap:0.6rem; align-items:center; box-shadow:0 -8px 24px rgba(15,23,42,0.08); flex-wrap:wrap; }
    .status-badge { display:inline-flex; align-items:center; gap:0.35rem; padding:0.35rem 0.7rem; border-radius:999px; font-weight:600; font-size:0.9rem; }
    .status-info { background:#e0f2fe; color:#075985; }
    .status-warn { background:#fff7ed; color:#9a3412; }
    .status-ok { background:#dcfce7; color:#14532d; }
    .status-error { background:#fee2e2; color:#991b1b; }
    .roster-preview { display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:0.75rem; }
    .roster-card { border:1px solid var(--border); border-radius:0.85rem; padding:0.85rem; background:var(--panel-muted); display:grid; gap:0.4rem; }
    .roster-card h3 { margin:0; font-size:1rem; display:flex; align-items:center; justify-content:space-between; gap:0.5rem; }
    .roster-list { list-style:none; padding:0; margin:0.35rem 0 0; display:grid; gap:0.25rem; }
    .roster-badge { display:inline-flex; align-items:center; gap:0.35rem; padding:0.2rem 0.55rem; border-radius:999px; background:#eef2ff; color:#312e81; border:1px solid #c7d2fe; font-size:0.78rem; }
    .extra-pill { background:#ecfeff; border:1px solid #a5f3fc; color:#0f172a; }
    .prefill-highlight { box-shadow:0 0 0 2px #bfdbfe; background:linear-gradient(90deg, rgba(239,246,255,0.6), rgba(255,255,255,0)); }
    @media (max-width: 960px) { .page-header { position:static; } label { width:100%; } input, select, textarea, button { width:100%; } button { justify-content:center; } table { min-width:800px; } .header-meta { width:100%; justify-content:flex-start; } .toolbar { flex-direction:column; align-items:flex-start; } }
  </style>
</head>
<body>
  <div class="admin-shell">
    <aside class="admin-sidebar">
      <div class="admin-sidebar-header">
        <div class="admin-logo">ELT Admin</div>
        <button class="sidebar-close" aria-label="Navigation schlie√üen">‚úï</button>
      </div>
      <nav class="admin-nav">
        <a href="index.html">CSV &amp; Datei-Tools</a>
        <a href="events.html">Events erfassen</a>
        <a href="players.html">Spieler &amp; Aliase</a>
        <a href="absences.html">Absenzen</a>
        <a href="group-preferences.html">Gruppenpr√§ferenzen</a>
        <a href="event-assignments.html" class="active">Event-Zusagen</a>
        <a href="attendance-config.html">Attendance-Config</a>
        <a href="noshow-dashboard.html">No-Show Analyse</a>
        <a href="callup-assistant.html">Callup-Assistent</a>
      </nav>
    </aside>

    <div class="admin-main">
      <header class="admin-header">
        <button class="sidebar-toggle" aria-label="Navigation √∂ffnen">‚ò∞</button>
        <div class="page-title">
          <p>Admin ¬∑ Events</p>
          <h1>Event-Zusagen &amp; manuelle Gruppen</h1>
        </div>
        <div class="admin-header-actions">
          <a class="btn ghost" href="../index.html">Zur Roster-Ansicht</a>
        </div>
      </header>

      <main class="admin-content">
        <section class="admin-section page-wrapper">
          <div class="page-inner">
            <header class="page-header">
              <div style="flex:1;min-width:260px;">
                <p class="eyebrow">Admin ¬∑ Event-Pool</p>
                <h1>Zusage-Pool f√ºrs n√§chste Event</h1>
                <p id="contextMeta" class="meta-line">L√§dt out/latest.json ‚Ä¶</p>
              </div>
              <div class="header-meta">
                <div class="labelled-value" id="eventQuickMeta">n√§chstes Event ¬∑ l√§dt ‚Ä¶</div>
                <span class="pill info" id="assignmentCount">‚Äì</span>
                <div class="build-status-line">
                  <span id="rebuildStatusText">Build-Status l√§dt ‚Ä¶</span>
                  <small class="hint" style="color:var(--text-muted);">Hinweis: √Ñnderungen an event_signups_next.csv werden automatisch in den n√§chsten Roster-Build √ºbernommen.</small>
                </div>
                <details class="settings-toggle">
                  <summary>‚öôÔ∏è Einstellungen</summary>
                  <div class="settings-grid">
                    <label>Worker URL
                      <input id="workerUrl" type="text" value="https://ds-commit.hak1.workers.dev/write-file" spellcheck="false">
                    </label>
                    <label>Branch
                      <input id="branchInput" type="text" value="main" spellcheck="false">
                    </label>
                    <label>Admin-Key
                      <input id="adminKey" type="password" placeholder="r4-admin" autocomplete="off">
                    </label>
                  </div>
                  <div class="settings-actions">
                    <small class="hint" style="color:var(--text-muted);">Wird lokal gespeichert; wirkt auf Speichern/Reset.</small>
                  </div>
                </details>
              </div>
            </header>

            <div id="buildSyncBanner" class="build-alert" style="display:none;" aria-live="polite">
              <strong>Es gibt Zusagen, die noch nicht in der aktuellen Aufstellung ber√ºcksichtigt sind.</strong>
              <p id="buildSyncBannerText"></p>
              <small id="buildSyncBannerMeta" style="display:none;"></small>
            </div>

            <main class="page-main" style="display:grid;gap:1rem;">
              <section class="panel compact">
                <div class="toolbar">
                  <div style="display:grid; gap:0.35rem; min-width:280px;">
                    <strong>Kontext n√§chstes Event</strong>
                    <small class="hint" style="color:var(--text-muted);">Alle Eintr√§ge gelten f√ºr das kommende Event (aktuelles Roster). <code>Commitment=hard</code> = verbindliche Zusage / Fixplatz im n√§chsten Build; nach einem gespielten Event √ºber ‚ÄûNeues Event vorbereiten‚Äú leeren.</small>
                  </div>
                  <div class="toolbar-meta">
                    <button id="resetBtn" class="ghost" style="border-color:var(--border);color:#b91c1c;">Neues Event vorbereiten</button>
                    <div class="toolbar-actions">
                      <button id="reloadBtn" class="ghost">Neu laden</button>
                      <button id="saveBtn">Speichern</button>
                    </div>
                  </div>
                </div>
              </section>

              <div class="layout-two-col">
                <section class="panel" id="addPanel">
                  <h2>Spieler hinzuf√ºgen</h2>
                  <div class="controls" style="gap:0.65rem;">
                    <label style="min-width:220px;flex:1;">Spieler (Allianz oder Roster)
                      <input type="search" id="playerInput" list="playerOptions" placeholder="Name eingeben‚Ä¶" autocomplete="off">
                    </label>
                    <label>Gruppe
                      <select id="groupInput">
                        <option value="">‚Äì</option>
                        <option value="A">A</option>
                        <option value="B">B</option>
                      </select>
                    </label>
                    <label>Rolle
                      <select id="roleInput">
                        <option value="">‚Äì</option>
                        <option value="Start">Start</option>
                        <option value="Ersatz">Ersatz</option>
                      </select>
                    </label>
                    <label>Verbindlichkeit
                      <select id="commitmentInput">
                        <option value="none">Nur Info</option>
                        <option value="hard">Verbindlich (Commitment=hard)</option>
                      </select>
                    </label>
                    <label style="flex:1;min-width:200px;">Notiz (optional)
                      <input type="text" id="noteInput" placeholder="z.B. Discord-Zusage">
                    </label>
                    <button id="addBtn">Hinzuf√ºgen</button>
                  </div>
                  <p class="add-help">Quelle wird automatisch gesetzt (z.B. manuell oder aus Callup) und dient nur zur Dokumentation.</p>
                </section>

                <section class="panel">
                  <div class="controls" style="margin-bottom:0.5rem; align-items:flex-start; gap:0.35rem;">
                    <div style="display:grid; gap:0.25rem;">
                      <h2 style="margin:0;">Zugeordnete Teilnehmer</h2>
                      <span id="eventMeta" class="hint" style="color:var(--text-muted);"></span>
                    </div>
                  </div>
                  <div class="table-wrapper">
                    <table>
                      <thead>
                        <tr>
                          <th>Spieler</th>
                          <th>Gruppe</th>
                          <th>Rolle</th>
                          <th>Verbindlichkeit</th>
                          <th>Quelle</th>
                          <th>Notiz</th>
                          <th>Roster-Kontext</th>
                          <th>Aktion</th>
                        </tr>
                      </thead>
                      <tbody id="assignmentBody"></tbody>
                    </table>
                  </div>
                  <div id="emptyState" class="hint" style="color:var(--text-muted);display:none;">Noch keine Zusagen im Pool.</div>
                  <p class="hint" style="color:var(--text-muted);">Quelle beeinflusst die Aufstellung nicht; sie zeigt nur an, ob ein Eintrag manuell oder aus dem Callup-Assistenten stammt.</p>
                </section>
              </div>

              <section class="panel">
                <div class="controls" style="margin-bottom:0.35rem; align-items:flex-start; gap:0.35rem;">
                  <div style="display:grid; gap:0.25rem;">
                    <h2 style="margin:0;">Event-Antworten (Absagen / Keine R√ºckmeldung)</h2>
                    <span id="responseMeta" class="hint" style="color:var(--text-muted);"></span>
                  </div>
                  <div class="controls" style="gap:0.5rem; margin-left:auto;">
                    <label>Antwort-Status setzen
                      <select id="responseStatusInput">
                        <option value="">Keine Antwort setzen</option>
                        <option value="decline">Absage</option>
                        <option value="no_response">Keine R√ºckmeldung</option>
                      </select>
                    </label>
                    <label style="min-width:220px;">Spieler (Allianz oder Roster)
                      <input type="search" id="responsePlayerInput" list="playerOptions" placeholder="Name eingeben‚Ä¶" autocomplete="off">
                    </label>
                    <label style="flex:1;min-width:180px;">Notiz (optional)
                      <input type="text" id="responseNoteInput" placeholder="z.B. Absage via Discord">
                    </label>
                    <button id="addResponseBtn">Antwort speichern</button>
                  </div>
                </div>
                <div class="table-wrapper">
                  <table>
                    <thead>
                      <tr>
                        <th>Spieler</th>
                        <th>Status</th>
                        <th>Notiz</th>
                        <th>Quelle</th>
                        <th>Aktion</th>
                      </tr>
                    </thead>
                    <tbody id="responseBody"></tbody>
                  </table>
                </div>
                <div id="responseEmptyState" class="hint" style="color:var(--text-muted);display:none;">Keine Event-Antworten gesetzt.</div>
                <p class="hint" style="color:var(--text-muted);">Responses gelten f√ºrs n√§chste Event und landen in <code>data/event_responses_next.csv</code>. Status "Keine Antwort setzen" entfernt vorhandene Eintr√§ge.</p>
              </section>

              <details class="accordion" id="rosterPreviewPanel">
                <summary>
                  <div style="display:grid; gap:0.1rem;">
                    <span>Optimierte Aufstellung (n√§chstes Event)</span>
                    <small style="color:var(--text-muted);">Zeigt die aktuelle Aufstellung aus <code>latest.json</code>; wirkt nach n√§chstem Roster-Build.</small>
                  </div>
                  <span id="rosterMeta" class="hint" style="color:var(--text-muted);"></span>
                </summary>
                <div class="accordion-body">
                  <div id="rosterPreview" class="roster-preview"></div>
                </div>
              </details>

              <details class="accordion">
                <summary>Hintergrund &amp; Funktionsweise</summary>
                <div class="accordion-body">
                  <div class="help-grid">
                    <div class="help-card">
                      <strong>Dauerhafte Gruppenpr√§ferenzen</strong>
                      <ul>
                        <li>Quelle: <code>data/alliance.csv</code> (Spalten <code>PrefGroup</code>, <code>PrefMode</code>, <code>PrefBoost</code>).</li>
                        <li>Wirken langfristig auf den Optimizer.</li>
                      </ul>
                    </div>
                    <div class="help-card">
                      <strong>Event-Zusagen (n√§chstes Event)</strong>
                      <ul>
                        <li>Overlay f√ºr das <em>n√§chste</em> Event: basiert auf <code>out/latest.json</code>.</li>
                        <li>Kein Event-Browser; der Pool gilt immer f√ºr das n√§chste Build.</li>
                        <li>Wird nach dem n√§chsten Build in <code>latest.json</code> gespiegelt.</li>
                      </ul>
                    </div>
                    <div class="help-card">
                      <strong>Verbindlichkeit &amp; Trennung</strong>
                      <ul>
                        <li><code>Commitment=hard</code> = verbindliche Zusage / Fixplatz im n√§chsten Roster-Build.</li>
                        <li>Event-Zusagen sind unabh√§ngig von <code>PrefGroup</code>; Reset leert nur den Zusage-Pool.</li>
                      </ul>
                    </div>
                    <div class="help-card">
                      <strong>Sync aus Callup-Assistent</strong>
                      <ul>
                        <li><code>Source=callup-confirmed</code> kommt vom Callup-Assistenten (‚ÄûZugesagt (Roster √ºbernehmen)‚Äú).</li>
                        <li>Beim Speichern werden diese Eintr√§ge dort automatisch aktualisiert.</li>
                        <li>Meist keine Anpassung n√∂tig; Quelle bleibt zur Dokumentation erhalten.</li>
                      </ul>
                    </div>
                  </div>
                </div>
              </details>
            </main>
          </div>
        </section>
      </main>
    </div>
  </div>
  <div class="admin-overlay"></div>

  <div class="status-bar">
    <span id="statusBadge" class="status-badge status-info">Bereit</span>
    <div id="statusText" class="status-text">Noch keine √Ñnderungen.</div>
  </div>

  <datalist id="playerOptions"></datalist>

  <script src="../shared.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    (function(){
      const elements = {
        workerUrl: document.getElementById('workerUrl'),
        branch: document.getElementById('branchInput'),
        adminKey: document.getElementById('adminKey'),
        reloadBtn: document.getElementById('reloadBtn'),
        saveBtn: document.getElementById('saveBtn'),
        playerInput: document.getElementById('playerInput'),
        playerOptions: document.getElementById('playerOptions'),
        groupInput: document.getElementById('groupInput'),
        roleInput: document.getElementById('roleInput'),
        commitmentInput: document.getElementById('commitmentInput'),
        noteInput: document.getElementById('noteInput'),
        addBtn: document.getElementById('addBtn'),
        assignmentBody: document.getElementById('assignmentBody'),
        assignmentCount: document.getElementById('assignmentCount'),
        emptyState: document.getElementById('emptyState'),
        responseStatusInput: document.getElementById('responseStatusInput'),
        responsePlayerInput: document.getElementById('responsePlayerInput'),
        responseNoteInput: document.getElementById('responseNoteInput'),
        addResponseBtn: document.getElementById('addResponseBtn'),
        responseBody: document.getElementById('responseBody'),
        responseEmptyState: document.getElementById('responseEmptyState'),
        responseMeta: document.getElementById('responseMeta'),
        rebuildStatus: document.getElementById('rebuildStatusText'),
        buildBanner: document.getElementById('buildSyncBanner'),
        buildBannerText: document.getElementById('buildSyncBannerText'),
        buildBannerMeta: document.getElementById('buildSyncBannerMeta'),
        statusBadge: document.getElementById('statusBadge'),
        statusText: document.getElementById('statusText'),
        eventMeta: document.getElementById('eventMeta'),
        contextMeta: document.getElementById('contextMeta'),
        eventQuickMeta: document.getElementById('eventQuickMeta'),
        resetBtn: document.getElementById('resetBtn'),
        rosterPreview: document.getElementById('rosterPreview'),
        rosterMeta: document.getElementById('rosterMeta'),
        addPanel: document.getElementById('addPanel'),
      };

      const SETTINGS_KEY = 'dsro-event-assignments-settings';
      const getAdminKey = () => dsroShared.getAdminKey(elements.adminKey?.value);
      const canonicalNameJS = (window.dsroShared && typeof window.dsroShared.canonicalNameJS === 'function')
        ? window.dsroShared.canonicalNameJS
        : (value => {
            if (value == null) return '';
            return String(value).toLowerCase().trim().replace(/\s+/g, ' ');
          });
      const escapeHtml = (window.dsroShared && typeof window.dsroShared.escapeHtml === 'function')
        ? window.dsroShared.escapeHtml
        : (value => value == null ? '' : String(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;'));
      const computeSiteRoot = (window.dsroShared && typeof window.dsroShared.computeSiteRoot === 'function')
        ? window.dsroShared.computeSiteRoot
        : (pathname => {
            const path = pathname || '/';
            const adminIdx = path.indexOf('/admin/');
            if (adminIdx !== -1) return path.slice(0, adminIdx + 1);
            return path.endsWith('/') ? path : path.replace(/[^/]*$/, '/');
          });
      const url = new URL(location.href);
      const playerPrefillRaw = url.searchParams.get('player') || '';
      const playerPrefillCanon = canonicalNameJS(playerPrefillRaw);
      // Commitment existierte bereits als CSV-Spalte, wurde in dieser UI jedoch ignoriert; jetzt wird sie mitgelesen und mitgeschrieben.
      const DEFAULT_HEADERS = ['PlayerName','Group','Role','Commitment','Source','Note'];
      const DEFAULT_RESPONSE_HEADERS = ['PlayerName','Status','Source','Note'];
      const ALLOWED_RESPONSE_STATUSES = ['decline','no_response'];
      const branchOverride = (new URL(location.href)).searchParams.get('branch');
      const cacheBuster = `?v=${Date.now()}`;
      const buildLatestJsonUrl = (window.dsroShared && typeof window.dsroShared.buildLatestJsonUrl === 'function')
        ? window.dsroShared.buildLatestJsonUrl
        : ({ branchOverride: bOverride, cacheBuster: buster, siteRoot }) => {
            const base = siteRoot || computeSiteRoot(location.pathname || '/');
            if (bOverride) {
              return `https://raw.githubusercontent.com/its-h4k1/desert-storm-roster-optimizer/${bOverride}/out/latest.json${buster}`;
            }
            return `${base}out/latest.json${buster}`;
          };
      const SITE_ROOT = computeSiteRoot(location.pathname || '/');
      const LATEST_JSON_URL = buildLatestJsonUrl({ branchOverride, cacheBuster, siteRoot: SITE_ROOT });
      const REPO_OWNER = 'its-h4k1';
      const REPO_NAME = 'desert-storm-roster-optimizer';
      // Admin Event Assignments uses the same latest.json source as the main roster UI: docs/out/latest.json via GitHub Pages (raw URL only when ?branch=<name> is set).
      const toNumberOrNull = (value) => {
        const n = Number(value);
        return Number.isFinite(n) ? n : null;
      };
      const extractBuildRowCount = (meta) => {
        if (!meta || typeof meta !== 'object') return null;
        const candidates = [
          meta.file_rows_total,
          meta.file_entries_total,
          meta.raw_rows,
          meta.total_entries,
        ];
        for (const candidate of candidates) {
          const num = toNumberOrNull(candidate);
          if (num != null) return num;
        }
        return null;
      };
      const extractBuildHardCount = (meta) => {
        if (!meta || typeof meta !== 'object') return null;
        const candidates = [
          meta.hard_commit_rows_total,
          meta.hard_commit_total,
          meta.hard_commitments_total,
          meta.hard_commitments,
        ];
        for (const candidate of candidates) {
          const num = toNumberOrNull(candidate);
          if (num != null) return num;
        }
        return null;
      };
      const countHardCommitments = (rows) => {
        if (!Array.isArray(rows)) return 0;
        return rows.reduce((sum, row) => {
          const commitment = (row.Commitment || row.commitment || '').toString().toLowerCase();
          return sum + (commitment === 'hard' ? 1 : 0);
        }, 0);
      };

      const state = {
        assignments: [],
        headers: [],
        originalCsv: '',
        responses: [],
        responseHeaders: [],
        originalResponseCsv: '',
        loading: false,
        saving: false,
        alliancePool: [],
        rosterPlayers: [],
        rosterIndex: new Map(),
        rosterGroups: {},
        rosterMeta: null,
        eventSignupsMeta: null,
        eventSignupCommit: null,
        currentBranch: branchOverride || 'main',
        buildSyncStatus: null,
        playerNames: [],
      };

      // Konzept-Notiz: Dauerhafte Gruppenpr√§ferenzen (data/alliance.csv: PrefGroup/PrefMode/PrefBoost) steuern den Optimizer langfristig.
      // Der Zusage-Pool (data/event_signups_next.csv) geh√∂rt immer zum n√§chsten Event (aktuelles out/latest.json) und √ºberschreibt den Optimizer nicht dauerhaft.

      function normalizeLineEndings(text) { return (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n'); }
      function ensureTrailingNewline(text) { if (!text) return '\n'; return /\n$/.test(text) ? text : text + '\n'; }
      function formatSourceLabel(value) {
        if (value === 'manual') return 'Manuell';
        if (value === 'callup-confirmed') return 'Aus Callup';
        return value || '‚Äì';
      }
      const FORCED_SOURCE_LABELS = { manual: 'Manuell', 'callup-confirmed': 'Callup' };
      function normalizeForcedSignup(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const commitment = (raw.commitment || raw.Commitment || '').toString().toLowerCase();
        if (commitment !== 'hard') return null;
        const source = raw.source || raw.Source || '';
        const note = raw.note || raw.Note || '';
        const overbooked = Boolean(raw.overbooked || raw.Overbooked);
        return { commitment, source, note, overbooked };
      }
      function buildFixBadge(forcedSignup) {
        const normalized = normalizeForcedSignup(forcedSignup);
        if (!normalized) return '';
        const sourceLabel = normalized.source ? (FORCED_SOURCE_LABELS[normalized.source] || normalized.source) : '';
        const label = sourceLabel ? `verbindlich ¬∑ ${sourceLabel}` : 'verbindlich';
        const tooltipParts = ['Verbindliche Zusage aus event_signups_next.csv'];
        if (sourceLabel) tooltipParts.push(`Quelle: ${sourceLabel}`);
        if (normalized.overbooked) tooltipParts.push('√ºber Kapazit√§t');
        return `<span class="tag tag-fix" title="${escapeHtml(tooltipParts.join(' ¬∑ '))}">üîí ${escapeHtml(label)}</span>`;
      }
      function formatCsvValue(value) {
        if (value === null || value === undefined) return '';
        const str = value.toString();
        if (str.includes('"') || str.includes(',') || str.includes('\n')) return `"${str.replace(/"/g, '""')}"`;
        return str;
      }
      function parseCsv(text) {
        const res = Papa.parse(normalizeLineEndings(text || ''), { header:true, skipEmptyLines:true });
        const rows = Array.isArray(res.data) ? res.data : [];
        return { headers: res.meta?.fields || [], rows };
      }
      function buildCsv(headers, rows) {
        const headerLine = headers.join(',');
        const lines = rows.map(row => headers.map(h => formatCsvValue(row[h] ?? '')).join(','));
        return ensureTrailingNewline([headerLine, ...lines].join('\n'));
      }
      function normalizeResponseStatus(value) {
        const norm = (value || '').toString().trim().toLowerCase();
        if (['decline','declined','absage','cancel','cancelled','canceled','no'].includes(norm)) return 'decline';
        if (['no_response','none','unanswered','missing','unknown'].includes(norm)) return 'no_response';
        return '';
      }
      function formatResponseLabel(status) {
        if (status === 'decline') return 'Absage';
        if (status === 'no_response') return 'Keine R√ºckmeldung';
        return '‚Äì';
      }

      async function fetchEventSignupCommit(branchValue) {
        const branch = safeBranchName(branchValue || 'main');
        const url = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/commits?path=data/event_signups_next.csv&sha=${encodeURIComponent(branch)}&per_page=1`;
        const response = await fetch(url, { headers: { 'Accept': 'application/vnd.github+json' } });
        if (!response.ok) {
          throw new Error(`GitHub API ${response.status}`);
        }
        const data = await response.json();
        if (!Array.isArray(data) || !data.length) return null;
        const commit = data[0];
        return {
          sha: commit?.sha || null,
          url: commit?.html_url || null,
          date: commit?.commit?.committer?.date || commit?.commit?.author?.date || null,
        };
      }

      async function refreshFileCommit(branchValue) {
        try {
          const info = await fetchEventSignupCommit(branchValue || state.currentBranch || 'main');
          state.eventSignupCommit = info;
        } catch (err) {
          console.warn('Commit-Info konnte nicht geladen werden', err);
          state.eventSignupCommit = null;
        } finally {
          refreshBuildSyncState();
        }
      }

      function safeBranchName(value) {
        const trimmed = (value || '').trim();
        const cleaned = trimmed.replace(/[^\w\-\/]/g, '');
        return cleaned || 'main';
      }
      function buildRawDataUrl(relativePath, branchValue) {
        const cleanPath = (relativePath || '').replace(/^\//, '');
        const branch = safeBranchName(branchValue || 'main');
        return `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${branch}/${cleanPath}${cacheBuster}`;
      }
      async function fetchText(path, { allow404 = false } = {}) {
        const res = await fetch(path, { cache:'no-store' });
        if (!res.ok) {
          if (allow404 && res.status === 404) return null;
          throw new Error(`${path}: HTTP ${res.status}`);
        }
        return await res.text();
      }
      async function loadAssignments() {
        const branch = branchOverride || elements.branch.value || 'main';
        state.currentBranch = branch;
        const csvUrl = buildRawDataUrl('data/event_signups_next.csv', branch);
        try {
          const text = await fetchText(csvUrl, { allow404: true });
          if (!text) {
            state.headers = [...DEFAULT_HEADERS];
            state.assignments = [];
            state.originalCsv = buildCurrentCsv();
            await refreshFileCommit(branch);
            return;
          }
          const { headers, rows } = parseCsv(text);
          const mergedHeaders = headers.length ? Array.from(new Set([...headers, ...DEFAULT_HEADERS])) : [...DEFAULT_HEADERS];
          state.headers = mergedHeaders;
          const baseRow = DEFAULT_HEADERS.reduce((acc, k) => ({ ...acc, [k]: k === 'Commitment' ? 'none' : '' }), {});
          state.assignments = rows.map(r => ({
            ...baseRow,
            ...r,
            Source: r.Source || r.source || 'manual',
            Commitment: r.Commitment || r.commitment || baseRow.Commitment,
          }));
          state.originalCsv = buildCurrentCsv();
          await refreshFileCommit(branch);
        } catch (err) {
          console.warn('event_signups_next.csv konnte nicht geladen werden, starte leer', err);
          state.headers = [...DEFAULT_HEADERS];
          state.assignments = [];
          state.originalCsv = buildCurrentCsv();
          await refreshFileCommit(branch);
        }
      }
      async function loadResponses() {
        const branch = branchOverride || elements.branch.value || 'main';
        const csvUrl = buildRawDataUrl('data/event_responses_next.csv', branch);
        try {
          const text = await fetchText(csvUrl, { allow404: true });
          if (!text) {
            state.responseHeaders = [...DEFAULT_RESPONSE_HEADERS];
            state.responses = [];
            state.originalResponseCsv = buildResponseCsv();
            return;
          }
          const { headers, rows } = parseCsv(text);
          const mergedHeaders = headers.length ? Array.from(new Set([...headers, ...DEFAULT_RESPONSE_HEADERS])) : [...DEFAULT_RESPONSE_HEADERS];
          state.responseHeaders = mergedHeaders;
          const baseRow = DEFAULT_RESPONSE_HEADERS.reduce((acc, k) => ({ ...acc, [k]: '' }), {});
          state.responses = rows
            .map(r => ({
              ...baseRow,
              ...r,
              Status: normalizeResponseStatus(r.Status || r.status),
              Source: r.Source || r.source || 'manual',
              Note: r.Note || r.note || '',
            }))
            .filter(r => ALLOWED_RESPONSE_STATUSES.includes(r.Status));
          state.originalResponseCsv = buildResponseCsv();
        } catch (err) {
          console.warn('event_responses_next.csv konnte nicht geladen werden, starte leer', err);
          state.responseHeaders = [...DEFAULT_RESPONSE_HEADERS];
          state.responses = [];
          state.originalResponseCsv = buildResponseCsv();
        }
      }
      async function loadRoster() {
        const rosterPath = LATEST_JSON_URL;
        try {
          const response = await fetch(rosterPath, { cache:'no-store' });
          if (!response.ok) throw new Error(`${rosterPath}: HTTP ${response.status}`);
          const data = await response.json();
          const players = Array.isArray(data?.players) ? data.players : [];
          state.alliancePool = Array.isArray(data?.alliance_pool) ? data.alliance_pool : [];
          const rosterIndex = new Map();
          state.rosterPlayers = players
            .map(p => ({
              name: p.display || p.canon || '',
              group: p.group || '',
              role: p.role || '',
              canon: canonicalNameJS(p.canon || p.display || ''),
              forcedSignup: normalizeForcedSignup(p.forced_signup || (p.has_forced_signup ? { commitment:'hard', source:p.event_signup?.source } : null)),
            }))
            .filter(p => p.name);
          state.rosterPlayers.forEach(p => { if (p.canon) rosterIndex.set(p.canon, p); });
          state.rosterIndex = rosterIndex;
          state.rosterGroups = (data && data.groups) || {};
          state.rosterMeta = data?.generated_at || null;
          state.eventSignupsMeta = data?.event_signups || null;
          hydrateAssignmentsFromBuild(data);
          updateContextMeta();
          refreshBuildSyncState();
        } catch (err) {
          console.warn('latest.json nicht verf√ºgbar', err);
          state.rosterPlayers = [];
          state.rosterIndex = new Map();
          state.rosterGroups = {};
          state.rosterMeta = null;
          state.alliancePool = [];
          state.eventSignupsMeta = null;
          updateContextMeta();
          refreshBuildSyncState();
        }
      }

      function hydrateAssignmentsFromBuild(data) {
        const fileEntries = data?.event_signups?.file_entries;
        if (!Array.isArray(fileEntries) || !fileEntries.length) return;
        // Nur √ºbernehmen, wenn Build und Datei denselben Stand haben, um frische CSV-√Ñnderungen
        // nicht mit alten Build-Daten zu √ºberschreiben.
        const buildCommit = extractBuildCommit(data?.event_signups);
        const fileCommit = state.eventSignupCommit?.sha || null;
        if (buildCommit && fileCommit && buildCommit !== fileCommit) return;
        const baseRow = DEFAULT_HEADERS.reduce((acc, k) => ({ ...acc, [k]: k === 'Commitment' ? 'none' : '' }), {});
        state.assignments = fileEntries.map(entry => ({
          ...baseRow,
          PlayerName: entry.player || entry.PlayerName || '',
          Group: entry.group_pref || entry.Group || entry.group || '',
          Role: entry.role_pref || entry.Role || entry.role || '',
          Commitment: entry.commitment || entry.Commitment || baseRow.Commitment,
          Source: entry.source || entry.Source || 'manual',
          Note: entry.note || entry.Note || '',
        }));
        state.headers = state.headers.length ? state.headers : [...DEFAULT_HEADERS];
        state.originalCsv = buildCurrentCsv();
      }
      function buildCurrentCsv() {
        const headers = state.headers.length ? Array.from(new Set([...state.headers, ...DEFAULT_HEADERS])) : [...DEFAULT_HEADERS];
        const rows = state.assignments.map(entry => {
          const out = {};
          headers.forEach(h => { out[h] = entry[h] ?? ''; });
          return out;
        });
        rows.sort((a,b) => {
          const ga = (a.Group || '').toString();
          const gb = (b.Group || '').toString();
          if (ga !== gb) return ga.localeCompare(gb, 'de', { sensitivity:'base' });
          return (a.PlayerName || '').localeCompare((b.PlayerName || ''), 'de', { sensitivity:'base' });
        });
        return buildCsv(headers, rows);
      }
      function buildResponseCsv() {
        const headers = state.responseHeaders.length
          ? Array.from(new Set([...state.responseHeaders, ...DEFAULT_RESPONSE_HEADERS]))
          : [...DEFAULT_RESPONSE_HEADERS];
        const rows = state.responses
          .filter(r => ALLOWED_RESPONSE_STATUSES.includes(r.Status))
          .map(entry => {
            const out = {};
            headers.forEach(h => { out[h] = entry[h] ?? ''; });
            return out;
          })
          .sort((a,b) => (a.PlayerName || '').localeCompare((b.PlayerName || ''), 'de', { sensitivity:'base' }));
        return buildCsv(headers, rows);
      }
      function hasChanges() {
        const currentAssignments = buildCurrentCsv();
        const currentResponses = buildResponseCsv();
        const assignmentsChanged = normalizeLineEndings(currentAssignments).trim() !== normalizeLineEndings(state.originalCsv).trim();
        const responsesChanged = normalizeLineEndings(currentResponses).trim() !== normalizeLineEndings(state.originalResponseCsv).trim();
        return assignmentsChanged || responsesChanged;
      }
      function setStatus(message, tone='info') {
        const toneClass = tone === 'ok' ? 'status-ok' : tone === 'warn' ? 'status-warn' : tone === 'error' ? 'status-error' : 'status-info';
        elements.statusBadge.className = 'status-badge ' + toneClass;
        elements.statusBadge.textContent = tone === 'ok' ? 'OK' : tone === 'error' ? 'Fehler' : tone === 'warn' ? 'Hinweis' : 'Status';
        elements.statusText.textContent = message;
      }
      function setLoading(isLoading) {
        state.loading = isLoading;
        elements.reloadBtn.disabled = isLoading || state.saving;
        if (elements.resetBtn) elements.resetBtn.disabled = isLoading || state.saving;
        updateSaveButtonState();
        if (isLoading) setStatus('Lade Daten‚Ä¶', 'info');
        updateBuildControls();
      }
      function setSaving(isSaving) {
        state.saving = isSaving;
        if (elements.resetBtn) elements.resetBtn.disabled = isSaving || state.loading;
        updateSaveButtonState();
        updateBuildControls();
      }
      function updateSaveButtonState() {
        elements.saveBtn.disabled = state.loading || state.saving || !hasChanges();
        elements.saveBtn.textContent = state.saving ? 'Speichert‚Ä¶' : 'Speichern';
      }

      function updateContextMeta() {
        const parts = [];
        if (state.rosterMeta) parts.push(`latest.json gebaut: ${state.rosterMeta}`);
        const buildCount = extractBuildRowCount(state.eventSignupsMeta);
        if (buildCount != null) {
          parts.push(`Pool laut Build: ${buildCount} Eintr√§ge`);
        }
        parts.push(`Responses gesetzt: ${state.responses.length}`);
        const rebuildHint = 'Hinweis: √Ñnderungen an event_signups_next.csv landen automatisch nach dem n√§chsten Roster-Build in latest.json.';
        const text = parts.length ? `${parts.join(' ¬∑ ')} ¬∑ ${rebuildHint}` : rebuildHint;
        if (elements.contextMeta) elements.contextMeta.textContent = text;
        if (elements.rosterMeta) elements.rosterMeta.textContent = text;
        updateQuickMeta();
      }

      function updateQuickMeta() {
        const parts = [];
        if (state.eventSignupsMeta?.event_id) parts.push(`Event ${state.eventSignupsMeta.event_id}`);
        if (state.rosterMeta) parts.push(`Build: ${state.rosterMeta}`);
        parts.push(`Pool: ${state.assignments.length}`);
        parts.push(`Responses: ${state.responses.length}`);
        const text = parts.length ? parts.join(' ¬∑ ') : 'n√§chstes Event';
        if (elements.eventQuickMeta) elements.eventQuickMeta.textContent = text;
      }

      function formatCommitShort(value) {
        if (!value) return '';
        return value.slice(0, 7);
      }

      function extractBuildCommit(meta) {
        if (!meta || typeof meta !== 'object') return null;
        return meta.source_commit || meta.commit || meta.commit_sha || meta.source_sha || meta.csv_sha || null;
      }

      function refreshBuildSyncState() {
        const buildMeta = state.eventSignupsMeta || {};
        const fileCount = state.assignments.length;
        const buildCount = extractBuildRowCount(buildMeta);
        const fileCommit = state.eventSignupCommit?.sha || null;
        const buildCommit = extractBuildCommit(buildMeta);
        const lastBuild = state.rosterMeta || null;
        const fileHardCount = countHardCommitments(state.assignments);
        const buildHardCount = extractBuildHardCount(buildMeta);
        const hasCountMismatch = buildCount != null && buildCount !== fileCount;
        const hasCommitMismatch = Boolean(fileCommit && buildCommit && fileCommit !== buildCommit);
        const hasHardMismatch = buildHardCount != null && buildHardCount !== fileHardCount;
        const needsBuild = hasCountMismatch || hasCommitMismatch || hasHardMismatch;
        state.buildSyncStatus = {
          fileCount,
          buildCount,
          fileHardCount,
          buildHardCount,
          fileCommit,
          buildCommit,
          lastBuild,
          hasHardMismatch,
          isSynced: !needsBuild,
        };
        updateBuildBanner();
        updateBuildControls();
      }

      function updateBuildBanner() {
        if (!elements.buildBanner) return;
        const status = state.buildSyncStatus;
        if (!status || status.isSynced) {
          elements.buildBanner.style.display = 'none';
          return;
        }
        const poolFile = typeof status.fileCount === 'number' ? status.fileCount : '‚Äì';
        const poolBuild = typeof status.buildCount === 'number' ? status.buildCount : '‚Äì';
        const buildStamp = status.lastBuild || 'unbekannt';
        elements.buildBanner.style.display = 'grid';
        if (elements.buildBannerText) {
          elements.buildBannerText.textContent = `Pool (Datei): ${poolFile} ¬∑ Pool im letzten Build: ${poolBuild} ¬∑ Letzter Build: ${buildStamp}.`;
        }
        if (elements.buildBannerMeta) {
          const parts = [];
          const hardFile = (typeof status.fileHardCount === 'number') ? status.fileHardCount : null;
          const hardBuild = (typeof status.buildHardCount === 'number') ? status.buildHardCount : null;
          if (hardFile != null || hardBuild != null) {
            parts.push(`Fixpl√§tze laut Datei: ${hardFile ?? '‚Äì'} ¬∑ Fixpl√§tze im Build: ${hardBuild ?? '‚Äì'}`);
          }
          if (status.fileCommit) parts.push(`CSV-Commit: ${formatCommitShort(status.fileCommit)}`);
          if (status.buildCommit) parts.push(`Build-Commit: ${formatCommitShort(status.buildCommit)}`);
          if (parts.length) {
            elements.buildBannerMeta.textContent = parts.join(' ¬∑ ');
            elements.buildBannerMeta.style.display = 'block';
          } else {
            elements.buildBannerMeta.textContent = '';
            elements.buildBannerMeta.style.display = 'none';
          }
        }
      }

      function updateBuildControls() {
        const status = state.buildSyncStatus;
        if (elements.rebuildStatus) {
          if (!status) {
            elements.rebuildStatus.textContent = 'Build-Status l√§dt ‚Ä¶';
          } else if (status.isSynced) {
            elements.rebuildStatus.textContent = status.lastBuild
              ? `Build aktuell (${status.lastBuild})`
              : 'Build-Status aktuell.';
          } else {
            elements.rebuildStatus.textContent = '√Ñnderungen warten auf den n√§chsten Build.';
          }
        }
      }

      function populatePlayers() {
        const set = new Set();
        state.alliancePool.forEach(n => set.add(n.display || n.canon || ''));
        state.rosterPlayers.forEach(p => set.add(p.name));
        state.responses.forEach(r => set.add(r.PlayerName || ''));
        state.playerNames = Array.from(set).sort((a,b) => a.localeCompare(b, 'de', { sensitivity:'base' }));
        elements.playerOptions.innerHTML = '';
        state.playerNames.forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          elements.playerOptions.appendChild(opt);
        });
        refreshAutocompletes();
      }

      function attachPlayerAutocomplete(inputEl, getNamesFn, opts={}) {
        if (!inputEl) return null;
        const maxItems = Number(opts.maxItems) || 8;
        const parent = inputEl.parentElement;
        if (parent && !parent.classList.contains('autocomplete-wrapper')) {
          parent.classList.add('autocomplete-wrapper');
        }
        const dropdown = document.createElement('div');
        dropdown.className = 'autocomplete-menu';
        dropdown.style.display = 'none';
        (parent || inputEl).appendChild(dropdown);

        let items = [];
        let activeIndex = -1;
        let blurTimer = null;

        const closeMenu = () => {
          dropdown.style.display = 'none';
          dropdown.innerHTML = '';
          items = [];
          activeIndex = -1;
        };

        const commitValue = (value) => {
          inputEl.value = value;
          closeMenu();
          inputEl.dispatchEvent(new Event('input', { bubbles: true }));
        };

        const setActive = (nextIndex) => {
          activeIndex = nextIndex;
          Array.from(dropdown.children).forEach((child, idx) => {
            if (idx === activeIndex) child.classList.add('active');
            else child.classList.remove('active');
          });
        };

        const renderList = (list) => {
          dropdown.innerHTML = '';
          list.forEach((name, idx) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'autocomplete-item';
            btn.textContent = name;
            btn.addEventListener('mousedown', (e) => {
              e.preventDefault();
              commitValue(name);
            });
            btn.addEventListener('mousemove', () => setActive(idx));
            dropdown.appendChild(btn);
          });
          dropdown.style.display = list.length ? 'block' : 'none';
        };

        const updateList = () => {
          const query = inputEl.value || '';
          const canonQuery = canonicalNameJS(query);
          if (!canonQuery) { closeMenu(); return; }
          const names = (typeof getNamesFn === 'function' ? getNamesFn() : []) || [];
          const filtered = names
            .map(name => ({ name, canon: canonicalNameJS(name) }))
            .filter(entry => {
              if (!entry.canon) return false;
              return entry.canon.startsWith(canonQuery) || entry.canon.includes(canonQuery);
            })
            .slice(0, maxItems)
            .map(entry => entry.name);
          items = filtered;
          activeIndex = filtered.length ? 0 : -1;
          renderList(filtered);
          setActive(activeIndex);
        };

        inputEl.addEventListener('input', updateList);
        inputEl.addEventListener('focus', updateList);
        inputEl.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowDown') {
            if (!items.length) updateList();
            if (items.length) {
              e.preventDefault();
              e.stopPropagation();
              const next = activeIndex < items.length - 1 ? activeIndex + 1 : 0;
              setActive(next);
            }
          } else if (e.key === 'ArrowUp') {
            if (!items.length) updateList();
            if (items.length) {
              e.preventDefault();
              e.stopPropagation();
              const next = activeIndex > 0 ? activeIndex - 1 : items.length - 1;
              setActive(next);
            }
          } else if (e.key === 'Enter') {
            if (items.length && activeIndex >= 0) {
              e.preventDefault();
              e.stopImmediatePropagation();
              commitValue(items[activeIndex]);
            }
          } else if (e.key === 'Escape') {
            if (dropdown.style.display !== 'none') {
              e.preventDefault();
              e.stopPropagation();
              closeMenu();
            }
          }
        });

        inputEl.addEventListener('blur', () => {
          blurTimer = setTimeout(() => closeMenu(), 140);
        });
        dropdown.addEventListener('mousedown', () => {
          if (blurTimer) { clearTimeout(blurTimer); blurTimer = null; }
        });

        return { refresh: updateList, close: closeMenu };
      }

      const autocompleteControllers = [];
      function initAutocompletes() {
        const getNames = () => state.playerNames;
        const opts = { maxItems: 8 };
        if (elements.playerInput) autocompleteControllers.push(attachPlayerAutocomplete(elements.playerInput, getNames, opts));
        if (elements.responsePlayerInput) autocompleteControllers.push(attachPlayerAutocomplete(elements.responsePlayerInput, getNames, opts));
      }
      function refreshAutocompletes() {
        autocompleteControllers.forEach(ctrl => { if (ctrl && typeof ctrl.refresh === 'function') ctrl.refresh(); });
      }

      function applyPlayerPrefill() {
        if (!playerPrefillCanon || !elements.playerInput) return;
        const options = Array.from(elements.playerOptions?.children || []);
        const match = options.find(opt => canonicalNameJS(opt.value || '') === playerPrefillCanon);
        const valueToUse = (match && match.value) ? match.value : (playerPrefillRaw || '');
        if (valueToUse) {
          elements.playerInput.value = valueToUse;
          if (elements.addPanel) elements.addPanel.classList.add('prefill-highlight');
        }
      }

      function ensureAssignment(playerName) {
        const existing = state.assignments.find(r => (r.PlayerName || '') === playerName);
        if (existing) return existing;
        const blank = { PlayerName: playerName, Group:'', Role:'', Commitment:'none', Source:'manual', Note:'' };
        state.assignments.push(blank);
        return blank;
      }

      function renderAssignments() {
        const rows = [...state.assignments];
        elements.assignmentBody.innerHTML = '';
        elements.assignmentCount.textContent = `${rows.length} Eintr√§ge`;
        elements.eventMeta.textContent = 'Alle Eintr√§ge beziehen sich auf das n√§chste Event (aktuelles Roster); Callup-Eintr√§ge sind blau markiert und nur zur Dokumentation.';
        elements.emptyState.style.display = rows.length ? 'none' : 'block';
        const responseByCanon = new Map();
        state.responses.forEach(r => {
          const canon = canonicalNameJS(r.PlayerName || '');
          if (canon) responseByCanon.set(canon, r);
        });
        rows.forEach((row, idx) => {
          const tr = document.createElement('tr');
          const canon = canonicalNameJS(row.PlayerName || '');
          if (canon) tr.dataset.playerCanon = canon;
          const fromCallup = (row.Source || '') === 'callup-confirmed';
          if (fromCallup) tr.classList.add('from-callup');
          if (playerPrefillCanon && canon && playerPrefillCanon === canon) {
            tr.classList.add('prefill-highlight');
          }
          const playerTd = document.createElement('td');
          const playerName = row.PlayerName || '‚Äì';
          playerTd.textContent = playerName;
          const response = canon ? responseByCanon.get(canon) : null;
          if (response) {
            const badge = document.createElement('div');
            badge.className = 'tags';
            const tag = document.createElement('span');
            tag.className = response.Status === 'decline' ? 'tag tag-decline' : 'tag tag-noresp';
            tag.textContent = response.Status === 'decline' ? 'Absage' : 'Keine R√ºckmeldung';
            badge.appendChild(tag);
            if (response.Note) {
              const note = document.createElement('span');
              note.className = 'tag';
              note.textContent = response.Note;
              badge.appendChild(note);
            }
            playerTd.appendChild(badge);
          }
          tr.appendChild(playerTd);

          const groupTd = document.createElement('td');
          const groupSel = document.createElement('select');
          ['', 'A', 'B'].forEach(v => {
            const opt = document.createElement('option');
            opt.value = v; opt.textContent = v || '‚Äì';
            if ((row.Group || '') === v) opt.selected = true;
            groupSel.appendChild(opt);
          });
          groupSel.disabled = fromCallup;
          groupSel.addEventListener('change', () => { row.Group = groupSel.value; updateSaveButtonState(); });
          groupTd.appendChild(groupSel);
          tr.appendChild(groupTd);

          const roleTd = document.createElement('td');
          const roleSel = document.createElement('select');
          ['', 'Start', 'Ersatz'].forEach(v => {
            const opt = document.createElement('option'); opt.value = v; opt.textContent = v || '‚Äì';
            if ((row.Role || '') === v) opt.selected = true;
            roleSel.appendChild(opt);
          });
          roleSel.disabled = fromCallup;
          roleSel.addEventListener('change', () => { row.Role = roleSel.value; updateSaveButtonState(); });
          roleTd.appendChild(roleSel);
          tr.appendChild(roleTd);

          const commitmentTd = document.createElement('td');
          const commitmentSel = document.createElement('select');
          const commitmentBadge = document.createElement('span');
          commitmentBadge.className = 'tag';
          [['none','Nur Info'], ['hard','Verbindlich']].forEach(([value, label]) => {
            const opt = document.createElement('option');
            opt.value = value; opt.textContent = label;
            if ((row.Commitment || 'none') === value) opt.selected = true;
            commitmentSel.appendChild(opt);
          });
          const updateCommitmentBadge = () => {
            const c = row.Commitment || 'none';
            commitmentBadge.textContent = c === 'hard' ? 'verbindlich' : 'Info';
            commitmentBadge.className = c === 'hard' ? 'tag tag-hard' : 'tag';
          };
          commitmentSel.disabled = fromCallup;
          commitmentSel.addEventListener('change', () => {
            row.Commitment = commitmentSel.value || 'none';
            updateCommitmentBadge();
            updateSaveButtonState();
          });
          updateCommitmentBadge();
          commitmentTd.appendChild(commitmentSel);
          commitmentTd.appendChild(commitmentBadge);
          commitmentTd.style.display = 'flex';
          commitmentTd.style.flexDirection = 'column';
          commitmentTd.style.gap = '0.35rem';
          tr.appendChild(commitmentTd);

          const sourceTd = document.createElement('td');
          const sourceText = document.createElement('span');
          sourceText.textContent = formatSourceLabel(row.Source);
          if (fromCallup) sourceText.className = 'tag tag-callup';
          sourceTd.appendChild(sourceText);
          if (fromCallup) {
            const note = document.createElement('div');
            note.className = 'callup-note';
            note.textContent = 'aus Callup-Assistent';
            sourceTd.appendChild(note);
          }
          tr.appendChild(sourceTd);

          const noteTd = document.createElement('td');
          const noteInput = document.createElement('input');
          noteInput.type = 'text';
          noteInput.value = row.Note || '';
          noteInput.placeholder = fromCallup ? 'Aus Callup; optional erg√§nzen' : 'z.B. Discord-Zusage';
          noteInput.addEventListener('input', () => { row.Note = noteInput.value; updateSaveButtonState(); });
          noteTd.appendChild(noteInput);
          tr.appendChild(noteTd);

          const ctxTd = document.createElement('td');
          const tags = document.createElement('div');
          tags.className = 'tags';
          const inAlliance = state.alliancePool.some(p => (p.display || '') === row.PlayerName && Number(p.in_alliance) === 1);
          const rosterEntry = state.rosterPlayers.find(p => p.name === row.PlayerName);
          if (inAlliance) { const tag = document.createElement('span'); tag.className='tag'; tag.textContent='In Allianz'; tags.appendChild(tag); }
          if (rosterEntry) { const tag = document.createElement('span'); tag.className='tag'; tag.textContent=`EB-Roster ${rosterEntry.group || ''} ${rosterEntry.role || ''}`.trim(); tags.appendChild(tag); }
          if (!tags.children.length) { const tag = document.createElement('span'); tag.className='tag'; tag.textContent='kein Kontext'; tags.appendChild(tag); }
          ctxTd.appendChild(tags);
          tr.appendChild(ctxTd);

          const actionTd = document.createElement('td');
          const delBtn = document.createElement('button');
          delBtn.textContent = 'L√∂schen';
          delBtn.addEventListener('click', () => {
            const idxGlobal = state.assignments.indexOf(row);
            if (idxGlobal >= 0) { state.assignments.splice(idxGlobal, 1); renderAssignments(); updateSaveButtonState(); }
          });
          actionTd.appendChild(delBtn);
          tr.appendChild(actionTd);

          elements.assignmentBody.appendChild(tr);
        });
        elements.emptyState.style.display = rows.length ? 'none' : 'block';
        renderRosterPreview();
        updateQuickMeta();
        refreshBuildSyncState();
      }

      function renderRosterPreview() {
        const container = elements.rosterPreview;
        if (!container) return;
        const groups = state.rosterGroups || {};
        if (!Object.keys(groups).length) {
          container.textContent = 'Keine Aufstellung geladen (latest.json nicht verf√ºgbar).';
          return;
        }
        const signupsByCanon = new Map();
        state.assignments.forEach(a => {
          const canon = canonicalNameJS(a.PlayerName || '');
          if (!canon) return;
          signupsByCanon.set(canon, a);
        });
        const rosterCanon = new Set(state.rosterPlayers.map(p => p.canon).filter(Boolean));
        const forcedByCanon = new Map(state.rosterPlayers.filter(p => p.canon && p.forcedSignup).map(p => [p.canon, p.forcedSignup]));
        const extraByGroup = { A: [], B: [] };
        state.assignments.forEach(a => {
          const g = (a.Group || '').toUpperCase();
          const canon = canonicalNameJS(a.PlayerName || '');
          if (!canon || (g !== 'A' && g !== 'B')) return;
          if (!rosterCanon.has(canon)) extraByGroup[g].push(a);
        });

        const makeList = (entries, { highlight }) => {
          const ul = document.createElement('ul');
          ul.className = 'roster-list';
          if (!entries.length) {
            const li = document.createElement('li');
            li.textContent = '‚Äì';
            ul.appendChild(li);
            return ul;
          }
          entries.forEach(entry => {
            const li = document.createElement('li');
            const canon = canonicalNameJS(entry || entry.PlayerName || '');
            const signup = highlight && signupsByCanon.get(canon);
            const forcedBadge = buildFixBadge(forcedByCanon.get(canon));
            const note = signup && signup.Note ? ` <span class="hint">${escapeHtml(signup.Note)}</span>` : '';
            if (typeof entry === 'string') {
              li.innerHTML = `${escapeHtml(entry)}${forcedBadge ? ` ${forcedBadge}` : ''}${signup ? ' <span class="roster-badge">Event-Zusage</span>' : ''}${note}`;
            } else {
              const badge = `<span class="roster-badge extra-pill">Event-Zusage</span>`;
              const details = [];
              if (entry.Role) details.push(entry.Role);
              if (entry.Source) details.push(formatSourceLabel(entry.Source));
              const meta = details.length ? ` <span class="hint">(${escapeHtml(details.join(' ¬∑ '))})</span>` : '';
              li.innerHTML = `${escapeHtml(entry.PlayerName || '‚Äì')}${forcedBadge ? ` ${forcedBadge}` : ''} ${badge}${meta}${entry.Note ? ` <span class="hint">${escapeHtml(entry.Note)}</span>` : ''}`;
            }
            ul.appendChild(li);
          });
          return ul;
        };

        container.innerHTML = '';
        ['A','B'].forEach(group => {
          const card = document.createElement('div');
          card.className = 'roster-card';
          const header = document.createElement('h3');
          header.textContent = `Gruppe ${group}`;
          card.appendChild(header);

          const startList = Array.isArray(groups[group]?.Start) ? groups[group].Start : [];
          const ersatzList = Array.isArray(groups[group]?.Ersatz) ? groups[group].Ersatz : [];

          const startLabel = document.createElement('div');
          startLabel.textContent = 'Start';
          card.appendChild(startLabel);
          card.appendChild(makeList(startList, { highlight: true }));

          const ersatzLabel = document.createElement('div');
          ersatzLabel.textContent = 'Ersatz';
          card.appendChild(ersatzLabel);
          card.appendChild(makeList(ersatzList, { highlight: true }));

          const extraLabel = document.createElement('div');
          extraLabel.textContent = 'Zus√§tzliche Zusagen (au√üerhalb Optimizer)';
          card.appendChild(extraLabel);
          card.appendChild(makeList(extraByGroup[group] || [], { highlight: false }));

          container.appendChild(card);
        });
      }

      function addAssignment() {
        const player = elements.playerInput.value.trim();
        if (!player) { setStatus('Bitte Spieler ausw√§hlen.', 'warn'); elements.playerInput.focus(); return; }
        const entry = ensureAssignment(player);
        entry.Group = elements.groupInput.value;
        entry.Role = elements.roleInput.value;
        entry.Commitment = elements.commitmentInput.value || 'none';
        if (!entry.Source) entry.Source = 'manual';
        entry.Note = elements.noteInput.value;
        renderAssignments();
        updateSaveButtonState();
        setStatus('Eintrag hinzugef√ºgt/aktualisiert.', 'info');
      }

      function findResponseIndexByCanon(canon) {
        if (!canon) return -1;
        return state.responses.findIndex(r => canonicalNameJS(r.PlayerName || '') === canon);
      }

      function renderResponses() {
        if (!elements.responseBody) return;
        const rows = [...state.responses].sort((a,b) => (a.PlayerName || '').localeCompare((b.PlayerName || ''), 'de', { sensitivity:'base' }));
        elements.responseBody.innerHTML = '';
        elements.responseEmptyState.style.display = rows.length ? 'none' : 'block';
        if (elements.responseMeta) {
          elements.responseMeta.textContent = `Gesetzt: ${rows.length} ¬∑ Speichern schreibt event_responses_next.csv`;
        }
        rows.forEach((row, idx) => {
          const tr = document.createElement('tr');

          const playerTd = document.createElement('td');
          playerTd.textContent = row.PlayerName || '‚Äì';
          tr.appendChild(playerTd);

          const statusTd = document.createElement('td');
          const statusSel = document.createElement('select');
          [['','Keine Antwort setzen'], ['decline','Absage'], ['no_response','Keine R√ºckmeldung']].forEach(([value, label]) => {
            const opt = document.createElement('option');
            opt.value = value; opt.textContent = label;
            if ((row.Status || '') === value) opt.selected = true;
            statusSel.appendChild(opt);
          });
          const badge = document.createElement('div');
          const updateBadge = () => {
            badge.className = 'tag ' + (row.Status === 'decline' ? 'tag-decline' : 'tag-noresp');
            badge.textContent = formatResponseLabel(row.Status);
          };
          statusSel.addEventListener('change', () => {
            const newStatus = normalizeResponseStatus(statusSel.value);
            if (!newStatus) {
              const canon = canonicalNameJS(row.PlayerName || '');
              const idxExisting = findResponseIndexByCanon(canon);
              if (idxExisting >= 0) state.responses.splice(idxExisting, 1);
              renderResponses();
              renderAssignments();
              updateSaveButtonState();
              return;
            }
            row.Status = newStatus;
            updateBadge();
            renderAssignments();
            updateSaveButtonState();
          });
          updateBadge();
          statusTd.appendChild(statusSel);
          statusTd.appendChild(badge);
          statusTd.style.display = 'flex';
          statusTd.style.flexDirection = 'column';
          statusTd.style.gap = '0.35rem';
          tr.appendChild(statusTd);

          const noteTd = document.createElement('td');
          const noteInput = document.createElement('input');
          noteInput.type = 'text';
          noteInput.value = row.Note || '';
          noteInput.placeholder = 'optional';
          noteInput.addEventListener('input', () => { row.Note = noteInput.value; updateSaveButtonState(); renderAssignments(); });
          noteTd.appendChild(noteInput);
          tr.appendChild(noteTd);

          const sourceTd = document.createElement('td');
          const source = document.createElement('span');
          source.className = 'tag';
          source.textContent = formatSourceLabel(row.Source || 'manual');
          sourceTd.appendChild(source);
          tr.appendChild(sourceTd);

          const actionTd = document.createElement('td');
          const delBtn = document.createElement('button');
          delBtn.textContent = 'Entfernen';
          delBtn.addEventListener('click', () => {
            const canon = canonicalNameJS(row.PlayerName || '');
            const idxExisting = findResponseIndexByCanon(canon);
            if (idxExisting >= 0) {
              state.responses.splice(idxExisting, 1);
              renderResponses();
              renderAssignments();
              updateSaveButtonState();
            }
          });
          actionTd.appendChild(delBtn);
          tr.appendChild(actionTd);

          elements.responseBody.appendChild(tr);
        });
        updateQuickMeta();
      }

      function addResponse() {
        const player = elements.responsePlayerInput.value.trim();
        const status = normalizeResponseStatus(elements.responseStatusInput.value);
        const note = elements.responseNoteInput.value || '';
        if (!player) { setStatus('Bitte Spieler f√ºr Antwort w√§hlen.', 'warn'); elements.responsePlayerInput.focus(); return; }

        const canon = canonicalNameJS(player);
        const idxExisting = findResponseIndexByCanon(canon);

        if (!status) {
          if (idxExisting >= 0) {
            state.responses.splice(idxExisting, 1);
            setStatus('Antwort entfernt.', 'info');
          } else {
            setStatus('Keine Antwort gesetzt.', 'info');
          }
          renderResponses();
          renderAssignments();
          updateSaveButtonState();
          return;
        }

        if (idxExisting >= 0) {
          state.responses[idxExisting] = { ...state.responses[idxExisting], PlayerName: player, Status: status, Note: note, Source: state.responses[idxExisting].Source || 'manual' };
        } else {
          state.responses.push({ PlayerName: player, Status: status, Source: 'manual', Note: note });
        }

        elements.responsePlayerInput.value = '';
        elements.responseNoteInput.value = '';
        elements.responseStatusInput.value = '';
        setStatus('Antwort gespeichert.', 'info');
        renderResponses();
        renderAssignments();
        updateSaveButtonState();
      }

      async function reloadData() {
        updateBuildControls();
        setLoading(true);
        try {
          await loadAssignments();
          await loadResponses();
          await loadRoster();
          populatePlayers();
          applyPlayerPrefill();
          renderAssignments();
          renderResponses();
          setStatus('Daten geladen.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus(`Laden fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setLoading(false);
          updateSaveButtonState();
        }
      }

      async function saveChanges() {
        if (state.loading || state.saving) return;
        const workerUrl = elements.workerUrl.value.trim();
        const adminKey = getAdminKey();
        const branch = elements.branch.value.trim() || 'main';
        if (!workerUrl) { setStatus('Worker-URL fehlt.', 'error'); return; }
        if (!adminKey) { setStatus('Admin-Key erforderlich.', 'error'); return; }
        const content = buildCurrentCsv();
        const responsesContent = buildResponseCsv();
        setSaving(true);
        setStatus('Speichere event_signups_next.csv & event_responses_next.csv‚Ä¶', 'info');
        let signupSaved = false;
        let responsesSaved = false;
        try {
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_signups_next.csv',
            content,
            branch,
            message: 'admin: update event_signups_next.csv via event assignments ui',
          });
          signupSaved = true;
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_responses_next.csv',
            content: responsesContent,
            branch,
            message: 'admin: update event_responses_next.csv via event assignments ui',
          });
          responsesSaved = true;
          state.originalCsv = content;
          state.originalResponseCsv = responsesContent;
          await refreshFileCommit(branch);
          setStatus('Event-Zusagen & Antworten gespeichert.', 'ok');
        } catch (err) {
          console.error(err);
          if (signupSaved) state.originalCsv = content;
          if (responsesSaved) state.originalResponseCsv = responsesContent;
          const prefix = signupSaved && !responsesSaved ? 'Responses fehlgeschlagen. ' : '';
          setStatus(`${prefix}Speichern fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setSaving(false);
          updateSaveButtonState();
        }
      }

      // Manual post-event action: clears the "next event" pool and response overrides
      // so R4/R5 can start from an empty slate for the following roster build.
      // Assumes we intentionally drop all commitments/answers (no archiving here).
      async function resetPool() {
        if (state.loading || state.saving) return;
        const workerUrl = elements.workerUrl.value.trim();
        const adminKey = getAdminKey();
        const branch = elements.branch.value.trim() || 'main';
        if (!workerUrl) { setStatus('Worker-URL fehlt.', 'error'); return; }
        if (!adminKey) { setStatus('Admin-Key erforderlich.', 'error'); return; }
        const confirmReset = window.confirm(
          'Neues Event vorbereiten?\n\nDamit werden alle Zusagen/Antworten f√ºr das bisherige "n√§chste" Event gel√∂scht ' +
          'und leere Dateien event_signups_next.csv & event_responses_next.csv geschrieben. ' +
          'Das ist der manuelle Startpunkt nach einem gespielten Event.'
        );
        if (!confirmReset) return;
        const headers = state.headers.length ? state.headers : [...DEFAULT_HEADERS];
        const emptyCsv = buildCsv(headers, []);
        const responseHeaders = state.responseHeaders.length ? state.responseHeaders : [...DEFAULT_RESPONSE_HEADERS];
        const emptyResponsesCsv = buildCsv(responseHeaders, []);
        setSaving(true);
        setStatus('Leere event_signups_next.csv & event_responses_next.csv‚Ä¶', 'info');
        try {
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_signups_next.csv',
            content: emptyCsv,
            branch,
            message: 'admin: reset event_signups_next.csv via event assignments ui',
          });
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_responses_next.csv',
            content: emptyResponsesCsv,
            branch,
            message: 'admin: reset event_responses_next.csv via event assignments ui',
          });
          state.assignments = [];
          state.responses = [];
          state.originalCsv = emptyCsv;
          state.originalResponseCsv = emptyResponsesCsv;
          await refreshFileCommit(branch);
          renderAssignments();
          renderResponses();
          setStatus('Zusage-Pool & Antworten geleert: neues Event kann bef√ºllt werden.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus(`Reset fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setSaving(false);
          updateSaveButtonState();
        }
      }

      async function writeFile(workerUrl, adminKey, payload) {
        const headers = dsroShared.buildAdminHeaders({
          adminKey,
          headers: { 'Content-Type': 'application/json' },
        });
        const response = await fetch(workerUrl, { method:'POST', headers, body: JSON.stringify(payload) });
        if (!response.ok) { const text = await response.text().catch(() => ''); throw new Error(text || `HTTP ${response.status}`); }
        const result = await response.json().catch(() => ({}));
        if (result && result.ok === false) throw new Error(result.error || 'Worker-Fehler');
        return result;
      }

      function persistSettings() {
        const payload = { workerUrl: elements.workerUrl.value, branch: elements.branch.value, adminKey: elements.adminKey.value };
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(payload));
        dsroShared.saveAdminKey(payload.adminKey);
      }
      function restoreSettings() {
        const saved = localStorage.getItem(SETTINGS_KEY);
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
            if (parsed.branch) elements.branch.value = parsed.branch;
            if (parsed.adminKey) {
              elements.adminKey.value = parsed.adminKey;
              dsroShared.saveAdminKey(parsed.adminKey);
            }
          } catch (err) { console.warn('Settings konnten nicht gelesen werden', err); }
        } else {
          const shared = localStorage.getItem('dsro-admin-settings');
          if (shared) {
            try {
              const parsed = JSON.parse(shared);
              if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
              if (parsed.customBranch) elements.branch.value = parsed.customBranch;
              if (parsed.branchSelect) elements.branch.value = parsed.branchSelect;
              if (parsed.adminKey) {
                elements.adminKey.value = parsed.adminKey;
                dsroShared.saveAdminKey(parsed.adminKey);
              }
            } catch (err) { console.warn('Shared settings konnten nicht gelesen werden', err); }
          }
        }
      }

      function initEvents() {
        elements.reloadBtn.addEventListener('click', reloadData);
        elements.saveBtn.addEventListener('click', saveChanges);
        elements.addBtn.addEventListener('click', addAssignment);
        if (elements.addResponseBtn) elements.addResponseBtn.addEventListener('click', addResponse);
        if (elements.resetBtn) elements.resetBtn.addEventListener('click', resetPool);
        ['workerUrl','branch','adminKey'].forEach(key => elements[key].addEventListener('change', persistSettings));
        elements.playerInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addAssignment(); } });
        if (elements.responsePlayerInput) {
          elements.responsePlayerInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addResponse(); } });
        }
      }

      dsroShared.applyAdminKeyInput(elements.adminKey, { onChange: persistSettings });
      restoreSettings();
      initEvents();
      initAutocompletes();
      reloadData();
    })();
  </script>
  <script src="admin.js"></script>
</body>
</html>
