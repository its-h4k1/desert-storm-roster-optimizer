<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Event-Zusagen &amp; manuelle Gruppen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <link rel="stylesheet" href="admin.css" />
  <style>
    body { margin: 0; background: var(--bg); color: var(--text); }
    .page-header { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-start; position:sticky; top:0; background:var(--glass); padding:1rem 1.1rem; border-bottom:1px solid var(--border); z-index:5; }
    .page-header h1 { margin:0; font-size:1.45rem; }
    .page-header .eyebrow { margin:0; color:var(--text-muted); font-size:0.9rem; letter-spacing:0.02em; text-transform:uppercase; }
    .page-header .meta-line { margin:0.15rem 0 0; color:var(--text-muted); font-size:0.95rem; }
    .header-meta { display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap; margin-left:auto; }
    .labelled-value { display:flex; gap:0.4rem; align-items:center; padding:0.35rem 0.65rem; border:1px solid var(--border); border-radius:0.75rem; background:var(--panel-muted); color:var(--text-muted); font-weight:600; }
    .build-status-line { display:flex; flex-wrap:wrap; gap:0.5rem; font-size:0.85rem; color:var(--text-muted); align-items:center; }
    .build-status-line a { color:#2563eb; text-decoration:none; }
    .build-status-line a:hover { text-decoration:underline; }
    .build-alert { border:1px solid #fcd34d; background:#fefce8; color:#92400e; border-radius:0.85rem; padding:0.85rem 1rem; display:grid; gap:0.35rem; }
    .build-alert strong { font-size:1rem; }
    .build-alert small { color:#b45309; }
    .settings { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-end; }
    .settings-toggle { border:1px solid var(--border); border-radius:0.85rem; padding:0.35rem 0.65rem; background:var(--panel-muted); }
    .settings-toggle summary { list-style:none; cursor:pointer; display:flex; align-items:center; gap:0.4rem; font-weight:600; color:var(--text-muted); }
    .settings-toggle summary::marker { display:none; }
    .settings-toggle summary::-webkit-details-marker { display:none; }
    .settings-toggle[open] { background:var(--panel); }
    .settings-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:0.75rem; margin-top:0.75rem; }
    .settings-actions { display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; justify-content:flex-end; margin-top:0.5rem; }
    .toolbar { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center; justify-content:space-between; padding:0.75rem 0; }
    .toolbar-actions { display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; }
    .toolbar-meta { display:flex; gap:0.6rem; flex-wrap:wrap; align-items:center; }
    label { display:flex; flex-direction:column; gap:0.35rem; font-size:0.9rem; color:var(--text-muted); }
    input[type="text"], input[type="search"], input[type="password"], select, textarea { font:inherit; padding:0.5rem 0.65rem; border-radius:0.75rem; border:1px solid var(--border); background:var(--bg-alt); color:var(--text); min-width:12rem; }
    input:focus, select:focus, textarea:focus { outline:2px solid rgba(37,99,235,0.35); outline-offset:1px; }
    textarea { resize:vertical; min-height:48px; }
    button { font:inherit; border:1px solid var(--border); border-radius:0.75rem; padding:0.55rem 1rem; background:#fff; color:var(--text); cursor:pointer; display:inline-flex; align-items:center; gap:0.4rem; }
    button:hover { background:#f8fafc; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    .admin-content { width:min(1400px,100%); }
    .page-inner { max-width:1400px; }
    .admin-section { padding:1.1rem; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:1rem; padding:1rem; box-shadow:var(--shadow-panel,0 18px 40px rgba(15,23,42,0.08)); display:grid; gap:0.75rem; }
    .panel h2 { margin:0; }
    .panel.compact { gap:0.5rem; }
    .help-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(240px,1fr)); gap:0.75rem; }
    .help-card { padding:0.85rem; background:var(--panel-muted); border:1px solid var(--border); border-radius:0.85rem; display:grid; gap:0.35rem; }
    .accordion { border:1px solid var(--border); border-radius:0.9rem; background:var(--panel-muted); }
    .accordion summary { cursor:pointer; padding:0.85rem 1rem; list-style:none; display:flex; align-items:center; justify-content:space-between; gap:0.5rem; font-weight:600; }
    .accordion summary::marker { display:none; }
    .accordion summary::-webkit-details-marker { display:none; }
    .accordion[open] { background:var(--panel); }
    .accordion .accordion-body { padding:0 1rem 1rem; display:grid; gap:0.75rem; }
    .layout-two-col { display:flex; flex-direction:column; gap:1rem; align-items:stretch; }
    .add-help { color:var(--text-muted); font-size:0.9rem; }
    .controls { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:center; }
    .spacer { flex:1; min-width:40px; }
    .pill { display:inline-flex; align-items:center; gap:0.35rem; padding:0.25rem 0.6rem; border-radius:999px; font-size:0.85rem; background:var(--bg-alt); color:var(--text); border:1px solid var(--border); }
    .pill.info { background:#e0f2fe; color:#075985; border-color:#bae6fd; }
    .table-wrapper { border:1px solid var(--border); border-radius:0.85rem; overflow:auto; box-shadow:var(--shadow-card); background:var(--panel-muted); }
    table { width:100%; border-collapse:collapse; min-width:860px; }
    thead { background:var(--bg-alt); position:sticky; top:0; z-index:3; text-transform:uppercase; font-size:0.8rem; letter-spacing:0.04em; }
    th, td { padding:0.7rem 0.85rem; border-bottom:1px solid var(--border); text-align:left; vertical-align:top; }
    tbody tr:nth-child(2n) td { background:var(--panel-muted); }
    .row-actions { display:flex; gap:0.4rem; flex-wrap:wrap; }
    .tags { display:flex; gap:0.35rem; flex-wrap:wrap; }
    .tag { padding:0.25rem 0.55rem; border-radius:0.65rem; border:1px solid var(--border); background:var(--bg-alt); font-size:0.8rem; color:var(--text-muted); }
    .tag-hard { background:#fef2f2; border-color:#fecaca; color:#991b1b; font-weight:600; }
    .tag-source-manual { background:#f3f4f6; border-color:#e5e7eb; color:#111827; font-weight:600; }
    .tag-source-ingame { background:#dcfce7; border-color:#bbf7d0; color:#166534; font-weight:600; }
    .tag-source-dm { background:#e0f2fe; border-color:#bfdbfe; color:#1d4ed8; font-weight:600; }
    .tag-callup { background:#eff6ff; border-color:#bfdbfe; color:#1d4ed8; font-weight:600; }
    .tag-decline { background:#fee2e2; border-color:#fecaca; color:#991b1b; font-weight:600; }
    .tag-noresp { background:#fff7ed; border-color:#fed7aa; color:#9a3412; font-weight:600; }
    .tag-fix { background:#f5f5f5; border-color:#d4d4d8; color:#3f3f46; font-weight:600; display:inline-flex; align-items:center; gap:0.35rem; }
    .callup-note { color:#1d4ed8; font-weight:600; font-size:0.9rem; display:inline-flex; align-items:center; gap:0.3rem; }
    tr.from-callup td { background:linear-gradient(90deg, rgba(239,246,255,0.6), rgba(255,255,255,0)); }
    .status-bar { position:sticky; bottom:0; background:var(--glass); border-top:1px solid var(--border); padding:0.75rem 1rem; display:flex; gap:0.6rem; align-items:center; box-shadow:0 -8px 24px rgba(15,23,42,0.08); flex-wrap:wrap; }
    .status-badge { display:inline-flex; align-items:center; gap:0.35rem; padding:0.35rem 0.7rem; border-radius:999px; font-weight:600; font-size:0.9rem; }
    .status-info { background:#e0f2fe; color:#075985; }
    .status-warn { background:#fff7ed; color:#9a3412; }
    .status-ok { background:#dcfce7; color:#14532d; }
    .status-error { background:#fee2e2; color:#991b1b; }
    .prefill-highlight { box-shadow:0 0 0 2px #bfdbfe; background:linear-gradient(90deg, rgba(239,246,255,0.6), rgba(255,255,255,0)); }
    .reliability-preview { font-size:0.85rem; margin-top:0.25rem; }
    .reliability-badge { display:inline-block; margin-right:0.25rem; }
    .reliability-details { opacity:0.8; }
    .reliability-hoch { color:#2e7d32; }
    .reliability-mittel { color:#f9a825; }
    .reliability-niedrig { color:#c62828; }
    .reliability-neu { color:#757575; }
    @media (max-width: 960px) { .page-header { position:static; } label { width:100%; } input, select, textarea, button { width:100%; } button { justify-content:center; } table { min-width:800px; } .header-meta { width:100%; justify-content:flex-start; } .toolbar { flex-direction:column; align-items:flex-start; } }
  </style>
</head>
<body>
  <div class="admin-shell">
    <aside class="admin-sidebar">
      <div class="admin-sidebar-header">
        <div class="admin-logo">ELT Admin</div>
        <button class="sidebar-close" aria-label="Navigation schlie√üen">‚úï</button>
      </div>
      <nav class="admin-nav">
        <a href="index.html">CSV &amp; Datei-Tools</a>
        <a href="events.html">Events erfassen</a>
        <a href="players.html">Spieler &amp; Aliase</a>
        <a href="absences.html">Absenzen</a>
          <a href="group-preferences.html">Gruppenpr√§ferenzen</a>
          <a href="event-assignments.html" class="active">Event-Zusagen</a>
          <a href="attendance-config.html">Attendance-Config</a>
          <a href="noshow-dashboard.html">No-Show Analyse</a>
        </nav>
    </aside>

    <div class="admin-main">
      <header class="admin-header">
        <button class="sidebar-toggle" aria-label="Navigation √∂ffnen">‚ò∞</button>
        <div class="page-title">
          <p>Admin ¬∑ Events</p>
          <h1>Event-Zusagen &amp; manuelle Gruppen</h1>
        </div>
        <div class="admin-header-actions">
          <a class="btn ghost" href="../index.html">Zur Roster-Ansicht</a>
        </div>
      </header>

      <main class="admin-content">
        <section class="admin-section page-wrapper">
          <div class="page-inner">
            <header class="page-header">
              <div style="flex:1;min-width:260px;">
                <p class="eyebrow">Admin ¬∑ Event-Pool</p>
                <h1>Zusage-Pool f√ºrs n√§chste Event</h1>
                <p id="contextMeta" class="meta-line">L√§dt out/latest.json ‚Ä¶</p>
              </div>
              <div class="header-meta">
                <div class="labelled-value" id="eventQuickMeta">n√§chstes Event ¬∑ l√§dt ‚Ä¶</div>
                <span class="pill info" id="assignmentCount">‚Äì</span>
                <span class="pill" id="hardCountA">A: ‚Äì</span>
                <span class="pill" id="hardCountB">B: ‚Äì</span>
                <div class="build-status-line">
                  <span id="rebuildStatusText">Build-Status l√§dt ‚Ä¶</span>
                  <small class="hint" style="color:var(--text-muted);">Hinweis: √Ñnderungen an event_signups_next.csv werden automatisch in den n√§chsten Roster-Build √ºbernommen.</small>
                </div>
                <details class="settings-toggle">
                  <summary>‚öôÔ∏è Einstellungen</summary>
                  <div class="settings-grid">
                    <label>Worker URL
                      <input id="workerUrl" type="text" value="https://ds-commit.hak1.workers.dev/write-file" spellcheck="false">
                    </label>
                    <label>Branch
                      <input id="branchInput" type="text" value="main" spellcheck="false">
                    </label>
                    <div style="display:grid; gap:0.35rem;">
                      <label style="margin:0; color:var(--text-muted); font-size:0.85rem;">Admin-Key</label>
                      <div id="adminKeyStatus" class="pill info">L√§dt Admin-Status‚Ä¶</div>
                      <div id="adminKeyFallbackRow" style="display:none;">
                        <label style="margin:0;">
                          <span style="display:block; font-size:0.85rem; color:var(--text-muted);">Fallback setzen</span>
                          <input id="adminKeyFallback" type="password" placeholder="Optional ‚Äì wird zentral gespeichert" autocomplete="off">
                        </label>
                        <div class="settings-actions" style="margin:0;justify-content:flex-start;">
                          <button id="adminKeyFallbackBtn" type="button">Admin-Key √ºbernehmen</button>
                        </div>
                        <small class="hint" style="color:var(--text-muted);">Nur nutzen, falls der zentrale Login noch nicht gesetzt wurde.</small>
                      </div>
                    </div>
                  </div>
                  <div class="settings-actions">
                    <small class="hint" style="color:var(--text-muted);">Worker-URL &amp; Branch werden lokal gespeichert. Admin-Key kommt aus der zentralen Verwaltung.</small>
                  </div>
                </details>
              </div>
            </header>

            <div id="adminKeyAlert" class="build-alert" style="display:none;" aria-live="polite">
              <strong>Kein Admin-Key gesetzt</strong>
              <p>Bitte √ºber die Admin-Startseite einloggen. Alternativ kannst du hier kurzfristig einen Admin-Key hinterlegen; er wird im zentralen Speicher abgelegt.</p>
            </div>

            <div id="buildSyncBanner" class="build-alert" style="display:none;" aria-live="polite">
              <strong>Es gibt Zusagen, die noch nicht in der aktuellen Aufstellung ber√ºcksichtigt sind.</strong>
              <p id="buildSyncBannerText"></p>
              <small id="buildSyncBannerMeta" style="display:none;"></small>
            </div>

            <main class="page-main" style="display:grid;gap:1rem;">
              <section class="panel compact">
                <div class="toolbar">
                  <div style="display:grid; gap:0.35rem; min-width:280px;">
                    <strong>Kontext n√§chstes Event</strong>
                    <small class="hint" style="color:var(--text-muted);">Alle Eintr√§ge gelten f√ºr das kommende Event (aktuelles Roster). <code>Commitment=hard</code> = verbindliche Zusage / Fixplatz im n√§chsten Build; nach einem gespielten Event √ºber ‚ÄûNeues Event vorbereiten‚Äú leeren.</small>
                  </div>
                  <div class="toolbar-meta">
                    <button id="resetBtn" class="ghost" style="border-color:var(--border);color:#b91c1c;">Neues Event vorbereiten</button>
                    <div class="toolbar-actions">
                      <button id="reloadBtn" class="ghost">Neu laden</button>
                      <button id="saveBtn">Speichern</button>
                    </div>
                  </div>
                </div>
              </section>

              <div class="layout-two-col">
                <section class="panel" id="addPanel">
                  <h2>Spieler hinzuf√ºgen</h2>
                  <div class="controls" style="gap:0.65rem;">
                    <label style="min-width:220px;flex:1;">Spieler (Allianz oder Roster)
                      <input type="search" id="playerInput" placeholder="Name eingeben‚Ä¶" autocomplete="off">
                      <div id="signup-player-reliability" class="reliability-preview muted-text"></div>
                    </label>
                    <label>Gruppe
                      <select id="groupInput">
                        <option value="">‚Äì</option>
                        <option value="A">A</option>
                        <option value="B">B</option>
                      </select>
                    </label>
                    <label>Rolle
                      <select id="roleInput">
                        <option value="">‚Äì</option>
                        <option value="Start">Start</option>
                        <option value="Ersatz">Ersatz</option>
                      </select>
                    </label>
                    <button id="addBtn">Hinzuf√ºgen</button>
                  </div>
                  <p class="add-help">Alle Zusagen hier gelten als verbindlich (<code>Commitment=hard</code>) und werden als manuell erfasst.</p>
                </section>

                <section class="panel">
                  <div class="controls" style="margin-bottom:0.5rem; align-items:flex-start; gap:0.35rem;">
                    <div style="display:grid; gap:0.25rem;">
                      <h2 style="margin:0;">Zugeordnete Teilnehmer</h2>
                      <span id="eventMeta" class="hint" style="color:var(--text-muted);"></span>
                    </div>
                    <label style="display:inline-flex; align-items:center; gap:0.35rem; font-weight:600;">
                      <input type="checkbox" id="hardOnlyToggle" />
                      <span>Nur harte Zusagen</span>
                    </label>
                  </div>
                  <div class="table-wrapper">
                    <table>
                      <thead>
                        <tr>
                          <th>Spieler</th>
                          <th>Gruppe</th>
                          <th>Rolle</th>
                          <th>Zuverl√§ssigkeit</th>
                          <th>Aktion</th>
                        </tr>
                      </thead>
                      <tbody id="assignmentBody"></tbody>
                    </table>
                  </div>
                  <div id="emptyState" class="hint" style="color:var(--text-muted);display:none;">Noch keine Zusagen im Pool.</div>
                  <p class="hint" style="color:var(--text-muted);">Alle Zusagen in dieser Liste sind verbindlich und landen als <code>Commitment=hard</code> in <code>data/event_signups_next.csv</code>.</p>
                </section>
              </div>

              <section class="panel">
                <div class="controls" style="margin-bottom:0.35rem; align-items:flex-start; gap:0.35rem;">
                  <div style="display:grid; gap:0.25rem;">
                    <h2 style="margin:0;">Event-Antworten (Absagen / Keine R√ºckmeldung)</h2>
                    <span id="responseMeta" class="hint" style="color:var(--text-muted);"></span>
                  </div>
                  <div class="controls" style="gap:0.5rem; margin-left:auto;">
                    <label>Antwort-Status setzen
                      <select id="responseStatusInput">
                        <option value="">Keine Antwort setzen</option>
                        <option value="cancelled">Absage</option>
                        <option value="no_response">Keine R√ºckmeldung</option>
                      </select>
                    </label>
                    <label style="min-width:220px;">Spieler (Allianz oder Roster)
                      <input type="search" id="responsePlayerInput" placeholder="Name eingeben‚Ä¶" autocomplete="off">
                      <div id="response-player-reliability" class="reliability-preview muted-text"></div>
                    </label>
                    <label style="flex:1;min-width:180px;">Notiz (optional)
                      <input type="text" id="responseNoteInput" placeholder="z.B. Absage via Discord">
                    </label>
                    <button id="addResponseBtn">Antwort speichern</button>
                  </div>
                </div>
                <div class="table-wrapper">
                  <table>
                    <thead>
                      <tr>
                        <th>Spieler</th>
                        <th>Status</th>
                        <th>Notiz</th>
                        <th>Quelle</th>
                        <th>Aktion</th>
                      </tr>
                    </thead>
                    <tbody id="responseBody"></tbody>
                  </table>
                </div>
                <div id="responseEmptyState" class="hint" style="color:var(--text-muted);display:none;">Keine Event-Antworten gesetzt.</div>
                <p class="hint" style="color:var(--text-muted);">Responses gelten f√ºrs n√§chste Event und landen in <code>data/event_responses_next.csv</code>. Spieler mit Status <strong>Absage</strong> werden f√ºr das kommende Event nicht im Roster ber√ºcksichtigt. Absagen nach Donnerstag 03:00 (Server-Reset, Zeitzone Schweiz/Z√ºrich) gelten als sp√§te Absagen und werden sp√§ter st√§rker gewichtet (aktuell nur Datenerfassung, Status "Keine Antwort setzen" entfernt vorhandene Eintr√§ge).</p>
              </section>

              <details class="accordion">
                <summary>Hintergrund &amp; Funktionsweise</summary>
                <div class="accordion-body">
                  <div class="help-grid">
                    <div class="help-card">
                      <strong>Dauerhafte Gruppenpr√§ferenzen</strong>
                      <ul>
                        <li>Quelle: <code>data/alliance.csv</code> (Spalten <code>PrefGroup</code>, <code>PrefMode</code>, <code>PrefBoost</code>).</li>
                        <li>Wirken langfristig auf den Optimizer.</li>
                      </ul>
                    </div>
                    <div class="help-card">
                      <strong>Event-Zusagen (n√§chstes Event)</strong>
                      <ul>
                        <li>Overlay f√ºr das <em>n√§chste</em> Event: basiert auf <code>out/latest.json</code>.</li>
                        <li>Kein Event-Browser; der Pool gilt immer f√ºr das n√§chste Build.</li>
                        <li>Wird nach dem n√§chsten Build in <code>latest.json</code> gespiegelt.</li>
                      </ul>
                    </div>
                    <div class="help-card">
                      <strong>Verbindlichkeit &amp; Trennung</strong>
                      <ul>
                        <li><code>Commitment=hard</code> = verbindliche Zusage / Fixplatz im n√§chsten Roster-Build.</li>
                        <li>Event-Zusagen sind unabh√§ngig von <code>PrefGroup</code>; Reset leert nur den Zusage-Pool.</li>
                      </ul>
                    </div>
                  </div>
                </div>
              </details>
            </main>
          </div>
        </section>
      </main>
    </div>
  </div>
  <div class="admin-overlay"></div>

  <div class="status-bar">
    <span id="statusBadge" class="status-badge status-info">Bereit</span>
    <div id="statusText" class="status-text">Noch keine √Ñnderungen.</div>
  </div>

  <script src="../shared.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    (function(){
      if (!window.dsroShared) {
        console.error('dsroShared is not available on admin/event-assignments; ensure shared.js is loaded first.');
        return;
      }
      const shared = window.dsroShared;
      const elements = {
        workerUrl: document.getElementById('workerUrl'),
        branch: document.getElementById('branchInput'),
        adminKeyFallback: document.getElementById('adminKeyFallback'),
        adminKeyFallbackRow: document.getElementById('adminKeyFallbackRow'),
        adminKeyFallbackBtn: document.getElementById('adminKeyFallbackBtn'),
        adminKeyStatus: document.getElementById('adminKeyStatus'),
        adminKeyAlert: document.getElementById('adminKeyAlert'),
        reloadBtn: document.getElementById('reloadBtn'),
        saveBtn: document.getElementById('saveBtn'),
        playerInput: document.getElementById('playerInput'),
        groupInput: document.getElementById('groupInput'),
        roleInput: document.getElementById('roleInput'),
        addBtn: document.getElementById('addBtn'),
        assignmentBody: document.getElementById('assignmentBody'),
        assignmentCount: document.getElementById('assignmentCount'),
        hardCountA: document.getElementById('hardCountA'),
        hardCountB: document.getElementById('hardCountB'),
        emptyState: document.getElementById('emptyState'),
        signupPlayerReliability: document.getElementById('signup-player-reliability'),
        responseStatusInput: document.getElementById('responseStatusInput'),
        responsePlayerInput: document.getElementById('responsePlayerInput'),
        responsePlayerReliability: document.getElementById('response-player-reliability'),
        responseNoteInput: document.getElementById('responseNoteInput'),
        addResponseBtn: document.getElementById('addResponseBtn'),
        responseBody: document.getElementById('responseBody'),
        responseEmptyState: document.getElementById('responseEmptyState'),
        responseMeta: document.getElementById('responseMeta'),
        rebuildStatus: document.getElementById('rebuildStatusText'),
        buildBanner: document.getElementById('buildSyncBanner'),
        buildBannerText: document.getElementById('buildSyncBannerText'),
        buildBannerMeta: document.getElementById('buildSyncBannerMeta'),
        statusBadge: document.getElementById('statusBadge'),
        statusText: document.getElementById('statusText'),
        eventMeta: document.getElementById('eventMeta'),
        contextMeta: document.getElementById('contextMeta'),
        eventQuickMeta: document.getElementById('eventQuickMeta'),
        resetBtn: document.getElementById('resetBtn'),
        addPanel: document.getElementById('addPanel'),
        hardOnlyToggle: document.getElementById('hardOnlyToggle'),
      };

      const SETTINGS_KEY = 'dsro-event-assignments-settings';
      const getAdminKey = () => (shared && typeof shared.getAdminKey === 'function') ? shared.getAdminKey() : '';
      const applyAdminKeyInput = (shared && typeof shared.applyAdminKeyInput === 'function')
        ? shared.applyAdminKeyInput
        : () => (() => {});
      const canonicalNameJS = (shared && typeof shared.canonicalNameJS === 'function')
        ? shared.canonicalNameJS
        : (value => {
            if (value == null) return '';
            return String(value).toLowerCase().trim().replace(/\s+/g, ' ');
          });
      const escapeHtml = (shared && typeof shared.escapeHtml === 'function')
        ? shared.escapeHtml
        : (value => value == null ? '' : String(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;'));
      const computeSiteRoot = (shared && typeof shared.computeSiteRoot === 'function')
        ? shared.computeSiteRoot
        : (pathname => {
            const path = pathname || '/';
            const adminIdx = path.indexOf('/admin/');
            if (adminIdx !== -1) return path.slice(0, adminIdx + 1);
            return path.endsWith('/') ? path : path.replace(/[^/]*$/, '/');
          });
      const getPlayerReliability = (name) => {
        if (!name) return null;
        if (!shared || typeof shared.getPlayerReliability !== 'function') return null;
        return shared.getPlayerReliability(name);
      };
      function buildReliabilityBadge(stats) {
        if (!shared || typeof shared.computeReliabilityBucket !== 'function') {
          return '<span class="reliability-badge reliability-neu" title="Keine Zuverl√§ssigkeitsdaten verf√ºgbar.">‚óè ‚Äì</span>';
        }
        const bucketInfo = shared.computeReliabilityBucket(stats);
        const bucket = bucketInfo?.bucket || 'neu';
        const label = bucketInfo?.label || 'neu';
        const tooltip = bucketInfo?.tooltip || 'Keine Zuverl√§ssigkeitsdaten verf√ºgbar.';
        const badgeClass = 'reliability-badge reliability-' + bucket;
        return `<span class="${badgeClass}" title="${escapeHtml(tooltip)}">‚óè ${escapeHtml(label)}</span>`;
      }
      function updatePlayerReliabilityPreview(rawName, mode) {
        const container = mode === 'signup'
          ? elements.signupPlayerReliability
          : mode === 'response'
            ? elements.responsePlayerReliability
            : null;

        if (!container) return;

        const name = (rawName || '').trim();
        if (!name) {
          container.textContent = '';
          container.title = '';
          return;
        }

        if (!shared || typeof shared.getPlayerReliability !== 'function' || typeof shared.computeReliabilityBucket !== 'function') {
          container.textContent = 'Keine Zuverl√§ssigkeitsdaten verf√ºgbar.';
          container.title = '';
          return;
        }

        const stats = shared.getPlayerReliability(name);
        if (!stats) {
          container.textContent = 'Keine Zuverl√§ssigkeitsdaten seit reliability_start_date.';
          container.title = '';
          return;
        }

        const bucketInfo = shared.computeReliabilityBucket(stats);
        const badgeClass = 'reliability-badge reliability-' + bucketInfo.bucket;
        container.innerHTML = `
          <span class="${badgeClass}" title="${escapeHtml(bucketInfo.tooltip || '')}">‚óè ${escapeHtml(bucketInfo.label || '')}</span>
          <span class="reliability-details">
            Events: ${stats.events ?? 0} ¬∑ Attendance: ${stats.attendance ?? 0} ¬∑ No-Shows: ${stats.noShows ?? 0} ¬∑ Early: ${stats.earlyCancels ?? 0} ¬∑ Late: ${stats.lateCancels ?? 0}
          </span>
        `;
      }
      const url = new URL(location.href);
      const playerPrefillRaw = url.searchParams.get('player') || '';
      const playerPrefillCanon = canonicalNameJS(playerPrefillRaw);
      // Commitment existierte bereits als CSV-Spalte, wurde in dieser UI jedoch ignoriert; jetzt wird sie mitgelesen und mitgeschrieben.
      const DEFAULT_HEADERS = ['PlayerName','Group','Role','Commitment','Source','Note'];
      const DEFAULT_RESPONSE_HEADERS = ['PlayerName','Status','ResponseTime','Source','Note'];
      const ALLOWED_RESPONSE_STATUSES = ['cancelled','no_response'];
      const SOURCE_OPTIONS = ['manual','ingame','dm','callup-confirmed'];
      const branchOverride = (new URL(location.href)).searchParams.get('branch');
      const cacheBuster = `?v=${Date.now()}`;
        const buildLatestJsonUrl = (shared && typeof shared.buildLatestJsonUrl === 'function')
          ? shared.buildLatestJsonUrl
        : ({ branchOverride: bOverride, cacheBuster: buster, siteRoot }) => {
            const base = siteRoot || computeSiteRoot(location.pathname || '/');
            if (bOverride) {
              return `https://raw.githubusercontent.com/its-h4k1/desert-storm-roster-optimizer/${bOverride}/out/latest.json${buster}`;
            }
            return `${base}out/latest.json${buster}`;
          };
      const buildRosterJsonUrl = ({ branchOverride: bOverride, cacheBuster: buster, siteRoot }) => {
        const base = siteRoot || computeSiteRoot(location.pathname || '/');
        if (bOverride) {
          return `https://raw.githubusercontent.com/its-h4k1/desert-storm-roster-optimizer/${bOverride}/out/roster.json${buster}`;
        }
        return `${base}out/roster.json${buster}`;
      };
      const SITE_ROOT = computeSiteRoot(location.pathname || '/');
      const LATEST_JSON_URL = buildLatestJsonUrl({ branchOverride, cacheBuster, siteRoot: SITE_ROOT });
      const ROSTER_JSON_URL = buildRosterJsonUrl({ branchOverride, cacheBuster, siteRoot: SITE_ROOT });
      const REPO_OWNER = 'its-h4k1';
      const REPO_NAME = 'desert-storm-roster-optimizer';
      // Admin Event Assignments uses the same latest.json source as the main roster UI: docs/out/latest.json via GitHub Pages (raw URL only when ?branch=<name> is set).
      const toNumberOrNull = (value) => {
        const n = Number(value);
        return Number.isFinite(n) ? n : null;
      };
      const extractBuildRowCount = (meta) => {
        if (!meta || typeof meta !== 'object') return null;
        const candidates = [
          meta.file_rows_total,
          meta.file_entries_total,
          meta.raw_rows,
          meta.total_entries,
        ];
        for (const candidate of candidates) {
          const num = toNumberOrNull(candidate);
          if (num != null) return num;
        }
        return null;
      };
      const extractBuildHardCount = (meta) => {
        if (!meta || typeof meta !== 'object') return null;
        const candidates = [
          meta.hard_commit_rows_total,
          meta.hard_commit_total,
          meta.hard_commitments_total,
          meta.hard_commitments,
        ];
        for (const candidate of candidates) {
          const num = toNumberOrNull(candidate);
          if (num != null) return num;
        }
        return null;
      };
      const countHardCommitments = (rows) => {
        if (!Array.isArray(rows)) return 0;
        return rows.reduce((sum, row) => {
          const commitment = (row.Commitment || row.commitment || '').toString().toLowerCase();
          return sum + (commitment === 'hard' ? 1 : 0);
        }, 0);
      };

      const state = {
        assignments: [],
        headers: [],
        originalCsv: '',
        responses: [],
        responseHeaders: [],
        originalResponseCsv: '',
        loading: false,
        saving: false,
        alliancePool: [],
        allianceCsvPlayers: [],
        rosterPlayers: [],
        rosterIndex: new Map(),
        rosterGroups: {},
        rosterMeta: null,
        eventInfo: null,
        eventSignupsMeta: null,
        eventSignupCommit: null,
        latestPayload: null,
        currentBranch: branchOverride || 'main',
        buildSyncStatus: null,
        playerNames: [],
        signupPoolEntries: [],
        filters: { hardOnly: false },
      };

      // Konzept-Notiz: Dauerhafte Gruppenpr√§ferenzen (data/alliance.csv: PrefGroup/PrefMode/PrefBoost) steuern den Optimizer langfristig.
      // Der Zusage-Pool (data/event_signups_next.csv) geh√∂rt immer zum n√§chsten Event (aktuelles out/latest.json) und √ºberschreibt den Optimizer nicht dauerhaft.

      function normalizeLineEndings(text) { return (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n'); }
      function ensureTrailingNewline(text) { if (!text) return '\n'; return /\n$/.test(text) ? text : text + '\n'; }
      function formatSourceLabel(value) {
        const val = (value || '').toString().trim();
        if (val === 'manual') return 'Manuell';
        if (val === 'ingame') return 'Ingame';
        if (val === 'dm') return 'DM';
        if (val === 'callup-confirmed') return 'Aus Callup';
        return val || '‚Äì';
      }
      function sourceTagClass(value) {
        const val = (value || '').toString().trim();
        if (val === 'ingame') return 'tag-source-ingame';
        if (val === 'dm') return 'tag-source-dm';
        if (val === 'manual') return 'tag-source-manual';
        if (val === 'callup-confirmed') return 'tag-callup';
        return 'tag';
      }
      const FORCED_SOURCE_LABELS = { manual: 'Manuell', 'callup-confirmed': 'Callup' };
      function normalizeForcedSignup(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const commitment = (raw.commitment || raw.Commitment || '').toString().toLowerCase();
        if (commitment !== 'hard') return null;
        const source = raw.source || raw.Source || '';
        const note = raw.note || raw.Note || '';
        const overbooked = Boolean(raw.overbooked || raw.Overbooked);
        return { commitment, source, note, overbooked };
      }
      function buildFixBadge(forcedSignup) {
        const normalized = normalizeForcedSignup(forcedSignup);
        if (!normalized) return '';
        const sourceLabel = normalized.source ? (FORCED_SOURCE_LABELS[normalized.source] || normalized.source) : '';
        const label = sourceLabel ? `verbindlich ¬∑ ${sourceLabel}` : 'verbindlich';
        const tooltipParts = ['Verbindliche Zusage aus event_signups_next.csv'];
        if (sourceLabel) tooltipParts.push(`Quelle: ${sourceLabel}`);
        if (normalized.overbooked) tooltipParts.push('√ºber Kapazit√§t');
        return `<span class="tag tag-fix" title="${escapeHtml(tooltipParts.join(' ¬∑ '))}">üîí ${escapeHtml(label)}</span>`;
      }
      function formatCsvValue(value) {
        if (value === null || value === undefined) return '';
        const str = value.toString();
        if (str.includes('"') || str.includes(',') || str.includes('\n')) return `"${str.replace(/"/g, '""')}"`;
        return str;
      }
      function parseCsv(text) {
        const res = Papa.parse(normalizeLineEndings(text || ''), { header:true, skipEmptyLines:true });
        const rows = Array.isArray(res.data) ? res.data : [];
        return { headers: res.meta?.fields || [], rows };
      }
      function buildCsv(headers, rows) {
        const headerLine = headers.join(',');
        const lines = rows.map(row => headers.map(h => formatCsvValue(row[h] ?? '')).join(','));
        return ensureTrailingNewline([headerLine, ...lines].join('\n'));
      }
      function normalizeResponseStatus(value) {
        const norm = (value || '').toString().trim().toLowerCase();
        if (['decline','declined','absage','cancel','cancelled','canceled','no'].includes(norm)) return 'cancelled';
        if (['no_response','none','unanswered','missing','unknown'].includes(norm)) return 'no_response';
        return '';
      }
      function formatResponseLabel(status) {
        if (status === 'cancelled') return 'Absage';
        if (status === 'no_response') return 'Keine R√ºckmeldung';
        return '‚Äì';
      }

      async function fetchEventSignupCommit(branchValue) {
        const branch = safeBranchName(branchValue || 'main');
        const url = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/commits?path=data/event_signups_next.csv&sha=${encodeURIComponent(branch)}&per_page=1`;
        const response = await fetch(url, { headers: { 'Accept': 'application/vnd.github+json' } });
        if (!response.ok) {
          throw new Error(`GitHub API ${response.status}`);
        }
        const data = await response.json();
        if (!Array.isArray(data) || !data.length) return null;
        const commit = data[0];
        return {
          sha: commit?.sha || null,
          url: commit?.html_url || null,
          date: commit?.commit?.committer?.date || commit?.commit?.author?.date || null,
        };
      }

      async function refreshFileCommit(branchValue) {
        try {
          const info = await fetchEventSignupCommit(branchValue || state.currentBranch || 'main');
          state.eventSignupCommit = info;
        } catch (err) {
          console.warn('Commit-Info konnte nicht geladen werden', err);
          state.eventSignupCommit = null;
        } finally {
          refreshBuildSyncState();
        }
      }

      function safeBranchName(value) {
        const trimmed = (value || '').trim();
        const cleaned = trimmed.replace(/[^\w\-\/]/g, '');
        return cleaned || 'main';
      }
      function sanitizeIdentifier(value) {
        return (value || '').toString().trim().replace(/[^\w\-]/g, '');
      }
      function buildArchivePath() {
        const eventId = sanitizeIdentifier(state.eventSignupsMeta?.event_id || state.eventInfo?.id || '');
        if (eventId) return `data/event_signups_${eventId}.csv`;
        const rawDate = (state.eventInfo?.date || state.eventSignupsMeta?.event_date || '').toString().trim();
        const dateMatch = rawDate.match(/\d{4}-\d{2}-\d{2}/);
        if (dateMatch) return `data/event_signups_${dateMatch[0]}.csv`;
        const today = new Date().toISOString().slice(0, 10);
        return `data/event_signups_${today}.csv`;
      }
      function buildRawDataUrl(relativePath, branchValue) {
        const cleanPath = (relativePath || '').replace(/^\//, '');
        const branch = safeBranchName(branchValue || 'main');
        return `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${branch}/${cleanPath}${cacheBuster}`;
      }
      async function fetchText(path, { allow404 = false } = {}) {
        const res = await fetch(path, { cache:'no-store' });
        if (!res.ok) {
          if (allow404 && res.status === 404) return null;
          throw new Error(`${path}: HTTP ${res.status}`);
        }
        return await res.text();
      }
      async function loadAssignments() {
        const branch = branchOverride || elements.branch.value || 'main';
        state.currentBranch = branch;
        const csvUrl = buildRawDataUrl('data/event_signups_next.csv', branch);
        try {
          const text = await fetchText(csvUrl, { allow404: true });
          if (!text) {
            state.headers = [...DEFAULT_HEADERS];
            state.assignments = [];
            state.originalCsv = buildCurrentCsv();
            await refreshFileCommit(branch);
            return;
          }
          const { headers, rows } = parseCsv(text);
          const mergedHeaders = headers.length ? Array.from(new Set([...headers, ...DEFAULT_HEADERS])) : [...DEFAULT_HEADERS];
          state.headers = mergedHeaders;
          const baseRow = DEFAULT_HEADERS.reduce((acc, k) => ({ ...acc, [k]: k === 'Commitment' ? 'hard' : '' }), {});
          state.assignments = rows.map(r => {
            const commitment = (r.Commitment || r.commitment || baseRow.Commitment || 'hard').toString().toLowerCase();
            return {
              ...baseRow,
              ...r,
              Source: r.Source || r.source || 'manual',
              Commitment: commitment === 'hard' ? 'hard' : baseRow.Commitment,
              Note: r.Note || r.note || '',
            };
          });
          state.originalCsv = buildCurrentCsv();
          await refreshFileCommit(branch);
        } catch (err) {
          console.warn('event_signups_next.csv konnte nicht geladen werden, starte leer', err);
          state.headers = [...DEFAULT_HEADERS];
          state.assignments = [];
          state.originalCsv = buildCurrentCsv();
          await refreshFileCommit(branch);
        }
      }
      async function loadResponses() {
        const branch = branchOverride || elements.branch.value || 'main';
        const csvUrl = buildRawDataUrl('data/event_responses_next.csv', branch);
        try {
          const text = await fetchText(csvUrl, { allow404: true });
          if (!text) {
            state.responseHeaders = [...DEFAULT_RESPONSE_HEADERS];
            state.responses = [];
            state.originalResponseCsv = buildResponseCsv();
            return;
          }
          const { headers, rows } = parseCsv(text);
          const mergedHeaders = headers.length ? Array.from(new Set([...headers, ...DEFAULT_RESPONSE_HEADERS])) : [...DEFAULT_RESPONSE_HEADERS];
          state.responseHeaders = mergedHeaders;
          const baseRow = DEFAULT_RESPONSE_HEADERS.reduce((acc, k) => ({ ...acc, [k]: '' }), {});
          state.responses = rows
            .map(r => ({
              ...baseRow,
              ...r,
              Status: normalizeResponseStatus(r.Status || r.status),
              Source: r.Source || r.source || 'manual',
              Note: r.Note || r.note || '',
            }))
            .filter(r => ALLOWED_RESPONSE_STATUSES.includes(r.Status));
          state.originalResponseCsv = buildResponseCsv();
        } catch (err) {
          console.warn('event_responses_next.csv konnte nicht geladen werden, starte leer', err);
          state.responseHeaders = [...DEFAULT_RESPONSE_HEADERS];
          state.responses = [];
          state.originalResponseCsv = buildResponseCsv();
        }
      }
      async function loadRoster() {
        const branch = branchOverride || elements.branch.value || 'main';
        let latestData = null;
        let rosterData = null;
        let rosterMissing = false;
        try {
          const response = await fetch(LATEST_JSON_URL, { cache:'no-store' });
          if (!response.ok) throw new Error(`${LATEST_JSON_URL}: HTTP ${response.status}`);
          latestData = await response.json();
        } catch (err) {
          console.warn('latest.json nicht verf√ºgbar', err);
        }

        try {
          const response = await fetch(ROSTER_JSON_URL, { cache:'no-store' });
          if (response.status === 404) {
            rosterMissing = true;
            console.info('roster.json fehlt (404) ‚Äì starte ohne Roster weiter.');
          } else if (response.ok) {
            rosterData = await response.json();
          }
        } catch (err) {
          console.warn('roster.json (Fallback) nicht verf√ºgbar', err);
        }

        let allianceCsvPlayers = [];
        try {
          const allianceUrl = buildRawDataUrl('data/alliance.csv', branch);
          const text = await fetchText(allianceUrl, { allow404: true });
          if (text) {
            const { rows } = parseCsv(text);
            allianceCsvPlayers = rows
              .map(row => (row?.PlayerName || '').toString().trim())
              .filter(Boolean);
          }
        } catch (err) {
          console.warn('alliance.csv konnte nicht geladen werden', err);
        }

        const metaSource = latestData || rosterData || {};
        const sharedPayload = latestData || rosterData || {};
        if (!latestData && rosterMissing) {
          console.info('Kein roster.json gefunden; nutze ggf. latest.json als einzige Quelle.');
        }
        if (shared?.hydrateReliabilityFromPayload) {
          shared.hydrateReliabilityFromPayload(sharedPayload);
        }
        if (shared) {
          shared.latestPayload = sharedPayload;
        }
        state.latestPayload = sharedPayload;
        if (shared?.refreshAdminPlayerIndex) {
          shared.refreshAdminPlayerIndex({ payload: shared.latestPayload });
        } else {
          if (shared?.prepareAliasMapFromPayload) shared.prepareAliasMapFromPayload(sharedPayload);
          if (shared?.buildAllKnownPlayersForAdmin) shared.buildAllKnownPlayersForAdmin(sharedPayload);
          if (shared?.buildPlayerAutocompleteIndexForAdmin) shared.buildPlayerAutocompleteIndexForAdmin();
        }
        const playersSource = Array.isArray(latestData?.players)
          ? latestData.players
          : Array.isArray(rosterData?.players)
            ? rosterData.players
            : [];
        const allianceSource = Array.isArray(latestData?.alliance_pool)
          ? latestData.alliance_pool
          : Array.isArray(rosterData?.alliance_pool)
            ? rosterData.alliance_pool
            : [];
        const signupPoolEntries = Array.isArray(latestData?.signup_pool?.file_entries)
          ? latestData.signup_pool.file_entries
          : Array.isArray(rosterData?.signup_pool?.file_entries)
            ? rosterData.signup_pool.file_entries
            : [];

        state.alliancePool = allianceSource;
        state.allianceCsvPlayers = allianceCsvPlayers;
        state.signupPoolEntries = signupPoolEntries;
        const rosterIndex = new Map();
        state.rosterPlayers = playersSource
          .map(p => ({
            name: p.display || p.canon || '',
            group: p.group || '',
            role: p.role || '',
            canon: canonicalNameJS(p.canon || p.display || ''),
            forcedSignup: normalizeForcedSignup(p.forced_signup || (p.has_forced_signup ? { commitment:'hard', source:p.event_signup?.source } : null)),
          }))
          .filter(p => p.name);
        state.rosterPlayers.forEach(p => { if (p.canon) rosterIndex.set(p.canon, p); });
        state.rosterIndex = rosterIndex;
        state.rosterGroups = (metaSource && metaSource.groups) || {};
        state.rosterMeta = metaSource?.generated_at || null;
        state.eventInfo = metaSource?.event || null;
        state.eventSignupsMeta = metaSource?.event_signups || null;
        hydrateAssignmentsFromBuild(metaSource);
        updateContextMeta();
        refreshBuildSyncState();
      }

      function hydrateAssignmentsFromBuild(data) {
        const fileEntries = data?.event_signups?.file_entries;
        if (!Array.isArray(fileEntries) || !fileEntries.length) return;
        // Nur √ºbernehmen, wenn Build und Datei denselben Stand haben, um frische CSV-√Ñnderungen
        // nicht mit alten Build-Daten zu √ºberschreiben.
        const buildCommit = extractBuildCommit(data?.event_signups);
        const fileCommit = state.eventSignupCommit?.sha || null;
        if (buildCommit && fileCommit && buildCommit !== fileCommit) return;
        const baseRow = DEFAULT_HEADERS.reduce((acc, k) => ({ ...acc, [k]: k === 'Commitment' ? 'hard' : '' }), {});
        state.assignments = fileEntries.map(entry => ({
          ...baseRow,
          PlayerName: entry.player || entry.PlayerName || '',
          Group: entry.group_pref || entry.Group || entry.group || '',
          Role: entry.role_pref || entry.Role || entry.role || '',
          Commitment: (entry.commitment || entry.Commitment || baseRow.Commitment || 'hard').toString().toLowerCase() === 'hard' ? 'hard' : baseRow.Commitment,
          Source: entry.source || entry.Source || 'manual',
          Note: entry.note || entry.Note || '',
        }));
        state.headers = state.headers.length ? state.headers : [...DEFAULT_HEADERS];
        state.originalCsv = buildCurrentCsv();
      }
      function buildCurrentCsv() {
        const headers = state.headers.length ? Array.from(new Set([...state.headers, ...DEFAULT_HEADERS])) : [...DEFAULT_HEADERS];
        const rows = state.assignments.map(entry => {
          const out = {};
          headers.forEach(h => { out[h] = entry[h] ?? ''; });
          return out;
        });
        rows.sort((a,b) => {
          const ga = (a.Group || '').toString();
          const gb = (b.Group || '').toString();
          if (ga !== gb) return ga.localeCompare(gb, 'de', { sensitivity:'base' });
          return (a.PlayerName || '').localeCompare((b.PlayerName || ''), 'de', { sensitivity:'base' });
        });
        return buildCsv(headers, rows);
      }
      function buildResponseCsv() {
        const headers = state.responseHeaders.length
          ? Array.from(new Set([...state.responseHeaders, ...DEFAULT_RESPONSE_HEADERS]))
          : [...DEFAULT_RESPONSE_HEADERS];
        const rows = state.responses
          .filter(r => ALLOWED_RESPONSE_STATUSES.includes(r.Status))
          .map(entry => {
            const out = {};
            headers.forEach(h => { out[h] = entry[h] ?? ''; });
            return out;
          })
          .sort((a,b) => (a.PlayerName || '').localeCompare((b.PlayerName || ''), 'de', { sensitivity:'base' }));
        return buildCsv(headers, rows);
      }
      function hasChanges() {
        const currentAssignments = buildCurrentCsv();
        const currentResponses = buildResponseCsv();
        const assignmentsChanged = normalizeLineEndings(currentAssignments).trim() !== normalizeLineEndings(state.originalCsv).trim();
        const responsesChanged = normalizeLineEndings(currentResponses).trim() !== normalizeLineEndings(state.originalResponseCsv).trim();
        return assignmentsChanged || responsesChanged;
      }
      function setStatus(message, tone='info') {
        const toneClass = tone === 'ok' ? 'status-ok' : tone === 'warn' ? 'status-warn' : tone === 'error' ? 'status-error' : 'status-info';
        elements.statusBadge.className = 'status-badge ' + toneClass;
        elements.statusBadge.textContent = tone === 'ok' ? 'OK' : tone === 'error' ? 'Fehler' : tone === 'warn' ? 'Hinweis' : 'Status';
        elements.statusText.textContent = message;
      }
      function setLoading(isLoading) {
        state.loading = isLoading;
        elements.reloadBtn.disabled = isLoading || state.saving;
        if (elements.resetBtn) elements.resetBtn.disabled = isLoading || state.saving;
        updateSaveButtonState();
        if (isLoading) setStatus('Lade Daten‚Ä¶', 'info');
        updateBuildControls();
      }
      function setSaving(isSaving) {
        state.saving = isSaving;
        if (elements.resetBtn) elements.resetBtn.disabled = isSaving || state.loading;
        updateSaveButtonState();
        updateBuildControls();
      }
      function updateSaveButtonState() {
        elements.saveBtn.disabled = state.loading || state.saving || !hasChanges();
        elements.saveBtn.textContent = state.saving ? 'Speichert‚Ä¶' : 'Speichern';
      }

      function updateContextMeta() {
        const parts = [];
        if (state.rosterMeta) parts.push(`latest.json gebaut: ${state.rosterMeta}`);
        const buildCount = extractBuildRowCount(state.eventSignupsMeta);
        if (buildCount != null) {
          parts.push(`Pool laut Build: ${buildCount} Eintr√§ge`);
        }
        parts.push(`Responses gesetzt: ${state.responses.length}`);
        const rebuildHint = 'Hinweis: √Ñnderungen an event_signups_next.csv landen automatisch nach dem n√§chsten Roster-Build in latest.json.';
        const text = parts.length ? `${parts.join(' ¬∑ ')} ¬∑ ${rebuildHint}` : rebuildHint;
          if (elements.contextMeta) elements.contextMeta.textContent = text;
        updateQuickMeta();
      }

        function updateQuickMeta() {
          const parts = [];
          const eventId = state.eventSignupsMeta?.event_id || state.eventInfo?.id;
          const eventDate = state.eventInfo?.date || state.eventSignupsMeta?.event_date;
          if (eventId) parts.push(`Event ${eventId}`);
          else if (eventDate) parts.push(`Event: ${eventDate}`);
          if (state.rosterMeta) parts.push(`Build: ${state.rosterMeta}`);
          parts.push(`Pool: ${state.assignments.length}`);
          if (typeof state.eventSignupsMeta?.hard_signups_only === 'boolean') {
            parts.push(state.eventSignupsMeta.hard_signups_only ? 'Roster-Modus: nur harte Zusagen' : 'Roster-Modus: Legacy');
          }
          parts.push(`Responses: ${state.responses.length}`);
          const text = parts.length ? parts.join(' ¬∑ ') : 'n√§chstes Event';
          if (elements.eventQuickMeta) elements.eventQuickMeta.textContent = text;
        }

      function formatCommitShort(value) {
        if (!value) return '';
        return value.slice(0, 7);
      }

      function extractBuildCommit(meta) {
        if (!meta || typeof meta !== 'object') return null;
        return meta.source_commit || meta.commit || meta.commit_sha || meta.source_sha || meta.csv_sha || null;
      }

      function refreshBuildSyncState() {
        const buildMeta = state.eventSignupsMeta || {};
        const fileCount = state.assignments.length;
        const buildCount = extractBuildRowCount(buildMeta);
        const fileCommit = state.eventSignupCommit?.sha || null;
        const buildCommit = extractBuildCommit(buildMeta);
        const lastBuild = state.rosterMeta || null;
        const fileHardCount = countHardCommitments(state.assignments);
        const buildHardCount = extractBuildHardCount(buildMeta);
        const hasCountMismatch = buildCount != null && buildCount !== fileCount;
        const hasCommitMismatch = Boolean(fileCommit && buildCommit && fileCommit !== buildCommit);
        const hasHardMismatch = buildHardCount != null && buildHardCount !== fileHardCount;
        const needsBuild = hasCountMismatch || hasCommitMismatch || hasHardMismatch;
        state.buildSyncStatus = {
          fileCount,
          buildCount,
          fileHardCount,
          buildHardCount,
          fileCommit,
          buildCommit,
          lastBuild,
          hasHardMismatch,
          isSynced: !needsBuild,
        };
        updateBuildBanner();
        updateBuildControls();
      }

      function updateBuildBanner() {
        if (!elements.buildBanner) return;
        const status = state.buildSyncStatus;
        if (!status || status.isSynced) {
          elements.buildBanner.style.display = 'none';
          return;
        }
        const poolFile = typeof status.fileCount === 'number' ? status.fileCount : '‚Äì';
        const poolBuild = typeof status.buildCount === 'number' ? status.buildCount : '‚Äì';
        const buildStamp = status.lastBuild || 'unbekannt';
        elements.buildBanner.style.display = 'grid';
        if (elements.buildBannerText) {
          elements.buildBannerText.textContent = `Pool (Datei): ${poolFile} ¬∑ Pool im letzten Build: ${poolBuild} ¬∑ Letzter Build: ${buildStamp}.`;
        }
        if (elements.buildBannerMeta) {
          const parts = [];
          const hardFile = (typeof status.fileHardCount === 'number') ? status.fileHardCount : null;
          const hardBuild = (typeof status.buildHardCount === 'number') ? status.buildHardCount : null;
          if (hardFile != null || hardBuild != null) {
            parts.push(`Fixpl√§tze laut Datei: ${hardFile ?? '‚Äì'} ¬∑ Fixpl√§tze im Build: ${hardBuild ?? '‚Äì'}`);
          }
          if (status.fileCommit) parts.push(`CSV-Commit: ${formatCommitShort(status.fileCommit)}`);
          if (status.buildCommit) parts.push(`Build-Commit: ${formatCommitShort(status.buildCommit)}`);
          if (parts.length) {
            elements.buildBannerMeta.textContent = parts.join(' ¬∑ ');
            elements.buildBannerMeta.style.display = 'block';
          } else {
            elements.buildBannerMeta.textContent = '';
            elements.buildBannerMeta.style.display = 'none';
          }
        }
      }

      function updateBuildControls() {
        const status = state.buildSyncStatus;
        if (elements.rebuildStatus) {
          if (!status) {
            elements.rebuildStatus.textContent = 'Build-Status l√§dt ‚Ä¶';
          } else if (status.isSynced) {
            elements.rebuildStatus.textContent = status.lastBuild
              ? `Build aktuell (${status.lastBuild})`
              : 'Build-Status aktuell.';
          } else {
            elements.rebuildStatus.textContent = '√Ñnderungen warten auf den n√§chsten Build.';
          }
        }
      }

      // Autocomplete: zentrale Namensquelle (Shared + Seitendaten)
      function populatePlayers() {
        const additionalNames = [];
        state.alliancePool.forEach(n => additionalNames.push(n.display || n.canon || ''));
        state.allianceCsvPlayers.forEach(n => additionalNames.push(n));
        state.rosterPlayers.forEach(p => additionalNames.push(p.name));
        state.responses.forEach(r => additionalNames.push(r.PlayerName || ''));
        state.assignments.forEach(r => additionalNames.push(r.PlayerName || ''));
        state.signupPoolEntries.forEach(entry => additionalNames.push(entry.PlayerName || entry.player_name || entry.player || ''));

        const updated = shared?.refreshAdminPlayerIndex
          ? shared.refreshAdminPlayerIndex({ payload: state.latestPayload, additionalNames })
          : additionalNames;
        state.playerNames = Array.isArray(updated)
          ? updated.slice()
          : Array.from(new Set(additionalNames)).sort((a,b) => a.localeCompare(b, 'de', { sensitivity:'base' }));
        refreshAutocompletes();
      }

      function attachPlayerAutocomplete(inputEl, getNamesFn, opts={}) {
        if (!inputEl) return null;
        const maxItems = Number(opts.maxItems) || 8;
        const queryFn = typeof opts.queryFn === 'function' ? opts.queryFn : null;
        const parent = inputEl.parentElement;
        if (parent && !parent.classList.contains('autocomplete-wrapper')) {
          parent.classList.add('autocomplete-wrapper');
        }
        const dropdown = document.createElement('div');
        dropdown.className = 'autocomplete-menu';
        dropdown.style.display = 'none';
        (parent || inputEl).appendChild(dropdown);

        let items = [];
        let activeIndex = -1;
        let blurTimer = null;

        const closeMenu = () => {
          dropdown.style.display = 'none';
          dropdown.innerHTML = '';
          items = [];
          activeIndex = -1;
        };

        const commitValue = (value) => {
          inputEl.value = value;
          closeMenu();
          inputEl.dispatchEvent(new Event('input', { bubbles: true }));
        };

        const setActive = (nextIndex) => {
          activeIndex = nextIndex;
          Array.from(dropdown.children).forEach((child, idx) => {
            if (idx === activeIndex) child.classList.add('active');
            else child.classList.remove('active');
          });
        };

        const renderList = (list) => {
          dropdown.innerHTML = '';
          list.forEach((name, idx) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'autocomplete-item';
            btn.textContent = name;
            btn.addEventListener('mousedown', (e) => {
              e.preventDefault();
              commitValue(name);
            });
            btn.addEventListener('mousemove', () => setActive(idx));
            dropdown.appendChild(btn);
          });
          dropdown.style.display = list.length ? 'block' : 'none';
        };

        const updateList = () => {
          const query = inputEl.value || '';
          const trimmed = query.trim();
          if (!trimmed) { closeMenu(); return; }
          let filtered = [];
          if (queryFn) {
            filtered = queryFn(trimmed, maxItems) || [];
          } else {
            const canonQuery = canonicalNameJS(query);
            if (!canonQuery) { closeMenu(); return; }
            const names = (typeof getNamesFn === 'function' ? getNamesFn() : []) || [];
            filtered = names
              .map(name => ({ name, canon: canonicalNameJS(name) }))
              .filter(entry => {
                if (!entry.canon) return false;
                return entry.canon.startsWith(canonQuery) || entry.canon.includes(canonQuery);
              })
              .slice(0, maxItems)
              .map(entry => entry.name);
          }
          items = filtered;
          activeIndex = filtered.length ? 0 : -1;
          renderList(filtered);
          setActive(activeIndex);
        };

        inputEl.addEventListener('input', updateList);
        inputEl.addEventListener('focus', updateList);
        inputEl.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowDown') {
            if (!items.length) updateList();
            if (items.length) {
              e.preventDefault();
              e.stopPropagation();
              const next = activeIndex < items.length - 1 ? activeIndex + 1 : 0;
              setActive(next);
            }
          } else if (e.key === 'ArrowUp') {
            if (!items.length) updateList();
            if (items.length) {
              e.preventDefault();
              e.stopPropagation();
              const next = activeIndex > 0 ? activeIndex - 1 : items.length - 1;
              setActive(next);
            }
          } else if (e.key === 'Enter') {
            if (items.length && activeIndex >= 0) {
              e.preventDefault();
              e.stopImmediatePropagation();
              commitValue(items[activeIndex]);
            }
          } else if (e.key === 'Escape') {
            if (dropdown.style.display !== 'none') {
              e.preventDefault();
              e.stopPropagation();
              closeMenu();
            }
          }
        });

        inputEl.addEventListener('blur', () => {
          blurTimer = setTimeout(() => closeMenu(), 140);
        });
        dropdown.addEventListener('mousedown', () => {
          if (blurTimer) { clearTimeout(blurTimer); blurTimer = null; }
        });

        return { refresh: updateList, close: closeMenu };
      }

      // Autocomplete: Event-Handler & Dropdown-Controller
      const autocompleteControllers = [];
      function initAutocompletes() {
          const getNames = () => state.playerNames;
          const opts = {
            maxItems: 20,
            queryFn: (term, max) => {
              if (shared?.queryPlayerNamesForAdmin) {
                return shared.queryPlayerNamesForAdmin(term, max);
              }
              const names = getNames() || [];
              const lc = (term || '').toLowerCase();
              return names.filter(n => (n || '').toLowerCase().includes(lc)).slice(0, max || 20);
            },
        };
        if (elements.playerInput) autocompleteControllers.push(attachPlayerAutocomplete(elements.playerInput, getNames, opts));
        if (elements.responsePlayerInput) autocompleteControllers.push(attachPlayerAutocomplete(elements.responsePlayerInput, getNames, opts));
      }
      function refreshAutocompletes() {
        autocompleteControllers.forEach(ctrl => { if (ctrl && typeof ctrl.refresh === 'function') ctrl.refresh(); });
      }

      function applyPlayerPrefill() {
        if (!playerPrefillCanon || !elements.playerInput) return;
        const match = (state.playerNames || []).find(name => canonicalNameJS(name || '') === playerPrefillCanon);
        const valueToUse = match || playerPrefillRaw || '';
        if (valueToUse) {
          elements.playerInput.value = valueToUse;
          if (elements.addPanel) elements.addPanel.classList.add('prefill-highlight');
          updatePlayerReliabilityPreview(elements.playerInput.value, 'signup');
        }
      }

      function ensureAssignment(playerName) {
        const existing = state.assignments.find(r => (r.PlayerName || '') === playerName);
        if (existing) return existing;
        const blank = { PlayerName: playerName, Group:'', Role:'', Commitment:'hard', Source:'manual', Note:'' };
        state.assignments.push(blank);
        return blank;
      }

      function removeAssignmentByCanon(playerCanon, { entryRef = null } = {}) {
        if (!playerCanon && !entryRef) return false;
        const before = state.assignments.length;
        state.assignments = state.assignments.filter(row => {
          const canon = canonicalNameJS(row.PlayerName || '');
          if (playerCanon && canon) return canon !== playerCanon;
          if (entryRef) return row !== entryRef;
          return true;
        });
        const removed = state.assignments.length < before;
        if (removed) {
          renderAssignments();
          updateSaveButtonState();
          setStatus('Zusage entfernt.', 'info');
        }
        return removed;
      }

      function renderAssignments() {
        const rows = state.assignments
          .filter(row => !state.filters.hardOnly || (row.Commitment || 'none') === 'hard')
          .slice()
          .sort((a, b) => (a.PlayerName || '').localeCompare((b.PlayerName || ''), 'de', { sensitivity: 'base' }));
        const totalEntries = state.assignments.length;
        elements.assignmentBody.innerHTML = '';
        if (elements.hardOnlyToggle) elements.hardOnlyToggle.checked = Boolean(state.filters.hardOnly);
        elements.assignmentCount.textContent = state.filters.hardOnly
          ? `${rows.length} harte Zusagen (von ${totalEntries})`
          : `${rows.length} Eintr√§ge`;
        const hardCounts = { A: 0, B: 0 };
        state.assignments.forEach(row => {
          const g = (row.Group || '').toUpperCase();
          const isHard = (row.Commitment || 'none') === 'hard';
          if (isHard && (g === 'A' || g === 'B')) hardCounts[g] += 1;
        });
        if (elements.hardCountA) elements.hardCountA.textContent = `A: ${hardCounts.A} hard`;
        if (elements.hardCountB) elements.hardCountB.textContent = `B: ${hardCounts.B} hard`;
        elements.eventMeta.textContent = 'Alle Eintr√§ge beziehen sich auf das n√§chste Event (aktuelles Roster) und sind verbindlich (<code>Commitment=hard</code>); Speichern schreibt nur die CSV-Dateien, Roster-Rebuild bleibt ein separater Schritt. Callup-Eintr√§ge sind blau markiert und nur zur Dokumentation.';
        elements.emptyState.style.display = rows.length ? 'none' : 'block';
        const responseByCanon = new Map();
        state.responses.forEach(r => {
          const canon = canonicalNameJS(r.PlayerName || '');
          if (canon) responseByCanon.set(canon, r);
        });
        rows.forEach((row, idx) => {
          const tr = document.createElement('tr');
          const canon = canonicalNameJS(row.PlayerName || '');
          if (canon) tr.dataset.playerCanon = canon;
          const fromCallup = (row.Source || '') === 'callup-confirmed';
          if (fromCallup) tr.classList.add('from-callup');
          if (playerPrefillCanon && canon && playerPrefillCanon === canon) {
            tr.classList.add('prefill-highlight');
          }
          const playerTd = document.createElement('td');
          const playerName = row.PlayerName || '‚Äì';
          playerTd.textContent = playerName;
          const response = canon ? responseByCanon.get(canon) : null;
          if (response) {
            const badge = document.createElement('div');
            badge.className = 'tags';
            const tag = document.createElement('span');
            tag.className = response.Status === 'cancelled' ? 'tag tag-decline' : 'tag tag-noresp';
            tag.textContent = response.Status === 'cancelled' ? 'Absage' : 'Keine R√ºckmeldung';
            badge.appendChild(tag);
            if (response.Note) {
              const note = document.createElement('span');
              note.className = 'tag';
              note.textContent = response.Note;
              badge.appendChild(note);
            }
            playerTd.appendChild(badge);
          }
          tr.appendChild(playerTd);

          const groupTd = document.createElement('td');
          const groupSel = document.createElement('select');
          ['', 'A', 'B'].forEach(v => {
            const opt = document.createElement('option');
            opt.value = v; opt.textContent = v || '‚Äì';
            if ((row.Group || '') === v) opt.selected = true;
            groupSel.appendChild(opt);
          });
          groupSel.disabled = fromCallup;
          groupSel.addEventListener('change', () => { row.Group = groupSel.value; updateSaveButtonState(); });
          groupTd.appendChild(groupSel);
          tr.appendChild(groupTd);

          const roleTd = document.createElement('td');
          const roleSel = document.createElement('select');
          ['', 'Start', 'Ersatz'].forEach(v => {
            const opt = document.createElement('option'); opt.value = v; opt.textContent = v || '‚Äì';
            if ((row.Role || '') === v) opt.selected = true;
            roleSel.appendChild(opt);
          });
          roleSel.disabled = fromCallup;
          roleSel.addEventListener('change', () => { row.Role = roleSel.value; updateSaveButtonState(); });
          roleTd.appendChild(roleSel);
          tr.appendChild(roleTd);

          const reliabilityTd = document.createElement('td');
          const reliabilityStats = getPlayerReliability(row.PlayerName);
          reliabilityTd.innerHTML = buildReliabilityBadge(reliabilityStats);
          tr.appendChild(reliabilityTd);

            const actionTd = document.createElement('td');
            const delBtn = document.createElement('button');
          delBtn.textContent = 'L√∂schen';
          delBtn.type = 'button';
          delBtn.addEventListener('click', () => {
            const canon = canonicalNameJS(row.PlayerName || '');
            if (!removeAssignmentByCanon(canon, { entryRef: row })) {
              setStatus('Zusage konnte nicht gel√∂scht werden.', 'warn');
            }
          });
          actionTd.appendChild(delBtn);
          tr.appendChild(actionTd);

          elements.assignmentBody.appendChild(tr);
        });
        elements.emptyState.style.display = rows.length ? 'none' : 'block';
        updateQuickMeta();
        refreshBuildSyncState();
      }


      function addAssignment() {
        const player = elements.playerInput.value.trim();
        if (!player) { setStatus('Bitte Spieler ausw√§hlen.', 'warn'); elements.playerInput.focus(); return; }
        const entry = ensureAssignment(player);
        entry.Group = elements.groupInput.value;
        entry.Role = elements.roleInput.value;
        entry.Commitment = 'hard';
        entry.Source = 'manual';
        entry.Note = '';
        renderAssignments();
        updateSaveButtonState();
        setStatus('Eintrag hinzugef√ºgt/aktualisiert.', 'info');
      }

      function findResponseIndexByCanon(canon) {
        if (!canon) return -1;
        return state.responses.findIndex(r => canonicalNameJS(r.PlayerName || '') === canon);
      }

      function renderResponses() {
        if (!elements.responseBody) return;
        const rows = [...state.responses].sort((a,b) => (a.PlayerName || '').localeCompare((b.PlayerName || ''), 'de', { sensitivity:'base' }));
        elements.responseBody.innerHTML = '';
        elements.responseEmptyState.style.display = rows.length ? 'none' : 'block';
        if (elements.responseMeta) {
          elements.responseMeta.textContent = `Gesetzt: ${rows.length} ¬∑ Speichern schreibt event_responses_next.csv`;
        }
        rows.forEach((row, idx) => {
          const tr = document.createElement('tr');

          const playerTd = document.createElement('td');
          playerTd.textContent = row.PlayerName || '‚Äì';
          tr.appendChild(playerTd);

          const statusTd = document.createElement('td');
          const statusSel = document.createElement('select');
          [['','Keine Antwort setzen'], ['cancelled','Absage'], ['no_response','Keine R√ºckmeldung']].forEach(([value, label]) => {
            const opt = document.createElement('option');
            opt.value = value; opt.textContent = label;
            if ((row.Status || '') === value) opt.selected = true;
            statusSel.appendChild(opt);
          });
          const badge = document.createElement('div');
          const updateBadge = () => {
            badge.className = 'tag ' + (row.Status === 'cancelled' ? 'tag-decline' : 'tag-noresp');
            badge.textContent = formatResponseLabel(row.Status);
          };
          statusSel.addEventListener('change', () => {
            const newStatus = normalizeResponseStatus(statusSel.value);
            if (!newStatus) {
              const canon = canonicalNameJS(row.PlayerName || '');
              const idxExisting = findResponseIndexByCanon(canon);
              if (idxExisting >= 0) state.responses.splice(idxExisting, 1);
              renderResponses();
              renderAssignments();
              updateSaveButtonState();
              return;
            }
            row.Status = newStatus;
            row.ResponseTime = new Date().toISOString();
            updateBadge();
            renderAssignments();
            updateSaveButtonState();
          });
          updateBadge();
          statusTd.appendChild(statusSel);
          statusTd.appendChild(badge);
          statusTd.style.display = 'flex';
          statusTd.style.flexDirection = 'column';
          statusTd.style.gap = '0.35rem';
          tr.appendChild(statusTd);

          const noteTd = document.createElement('td');
          const noteInput = document.createElement('input');
          noteInput.type = 'text';
          noteInput.value = row.Note || '';
          noteInput.placeholder = 'optional';
          noteInput.addEventListener('input', () => { row.Note = noteInput.value; updateSaveButtonState(); renderAssignments(); });
          noteTd.appendChild(noteInput);
          tr.appendChild(noteTd);

          const sourceTd = document.createElement('td');
          const source = document.createElement('span');
          source.className = 'tag';
          source.textContent = formatSourceLabel(row.Source || 'manual');
          sourceTd.appendChild(source);
          tr.appendChild(sourceTd);

          const actionTd = document.createElement('td');
          const delBtn = document.createElement('button');
          delBtn.textContent = 'Entfernen';
          delBtn.addEventListener('click', () => {
            const canon = canonicalNameJS(row.PlayerName || '');
            const idxExisting = findResponseIndexByCanon(canon);
            if (idxExisting >= 0) {
              state.responses.splice(idxExisting, 1);
              renderResponses();
              renderAssignments();
              updateSaveButtonState();
            }
          });
          actionTd.appendChild(delBtn);
          tr.appendChild(actionTd);

          elements.responseBody.appendChild(tr);
        });
        updateQuickMeta();
      }

      function addResponse() {
        const player = elements.responsePlayerInput.value.trim();
        const status = normalizeResponseStatus(elements.responseStatusInput.value);
        const note = elements.responseNoteInput.value || '';
        if (!player) { setStatus('Bitte Spieler f√ºr Antwort w√§hlen.', 'warn'); elements.responsePlayerInput.focus(); return; }

        const canon = canonicalNameJS(player);
        const idxExisting = findResponseIndexByCanon(canon);

        if (!status) {
          if (idxExisting >= 0) {
            state.responses.splice(idxExisting, 1);
            setStatus('Antwort entfernt.', 'info');
          } else {
            setStatus('Keine Antwort gesetzt.', 'info');
          }
          renderResponses();
          renderAssignments();
          updateSaveButtonState();
          return;
        }

        const nowIso = new Date().toISOString();
        if (idxExisting >= 0) {
          state.responses[idxExisting] = { ...state.responses[idxExisting], PlayerName: player, Status: status, ResponseTime: nowIso, Note: note, Source: state.responses[idxExisting].Source || 'manual' };
        } else {
          state.responses.push({ PlayerName: player, Status: status, ResponseTime: nowIso, Source: 'manual', Note: note });
        }

        elements.responsePlayerInput.value = '';
        elements.responseNoteInput.value = '';
        elements.responseStatusInput.value = '';
        setStatus('Antwort gespeichert.', 'info');
        renderResponses();
        renderAssignments();
        updateSaveButtonState();
      }

      async function reloadData() {
        updateBuildControls();
        setLoading(true);
        try {
          await loadAssignments();
          await loadResponses();
          await loadRoster();
          populatePlayers();
          applyPlayerPrefill();
          renderAssignments();
          renderResponses();
          setStatus('Daten geladen.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus(`Laden fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setLoading(false);
          updateSaveButtonState();
        }
      }

      async function saveChanges() {
        if (state.loading || state.saving) return;
        const workerUrl = elements.workerUrl.value.trim();
        const adminKey = getAdminKey();
        const branch = elements.branch.value.trim() || 'main';
        if (!workerUrl) { setStatus('Worker-URL fehlt.', 'error'); return; }
        if (!adminKey) {
          setStatus('Kein Admin-Key gesetzt ‚Äì bitte √ºber die Admin-Startseite einloggen.', 'error');
          updateAdminKeyStatus();
          return;
        }
        const content = buildCurrentCsv();
        const responsesContent = buildResponseCsv();
        setSaving(true);
        setStatus('Speichere event_signups_next.csv & event_responses_next.csv‚Ä¶', 'info');
        let signupSaved = false;
        let responsesSaved = false;
        try {
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_signups_next.csv',
            content,
            branch,
            message: 'admin: update event_signups_next.csv via event assignments ui',
          });
          signupSaved = true;
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_responses_next.csv',
            content: responsesContent,
            branch,
            message: 'admin: update event_responses_next.csv via event assignments ui',
          });
          responsesSaved = true;
          state.originalCsv = content;
          state.originalResponseCsv = responsesContent;
          await refreshFileCommit(branch);
          setStatus('Event-Zusagen & Antworten gespeichert.', 'ok');
        } catch (err) {
          console.error(err);
          if (signupSaved) state.originalCsv = content;
          if (responsesSaved) state.originalResponseCsv = responsesContent;
          const prefix = signupSaved && !responsesSaved ? 'Responses fehlgeschlagen. ' : '';
          setStatus(`${prefix}Speichern fehlgeschlagen: ${err.message}`, 'error');
        } finally {
          setSaving(false);
          updateSaveButtonState();
        }
      }

      // Manual post-event action: archive current signups and clear the "next event" pool plus responses
      // so R4/R5 can start from an empty slate for the following roster build.
      async function resetPool() {
        if (state.loading || state.saving) return;
        const workerUrl = elements.workerUrl.value.trim();
        const adminKey = getAdminKey();
        const branch = elements.branch.value.trim() || 'main';
        if (!workerUrl) { setStatus('Worker-URL fehlt.', 'error'); return; }
        if (!adminKey) {
          setStatus('Kein Admin-Key gesetzt ‚Äì bitte √ºber die Admin-Startseite einloggen.', 'error');
          updateAdminKeyStatus();
          return;
        }
        const assignmentCount = state.assignments.length;
        const hasAssignments = assignmentCount > 0;
        const confirmReset = window.confirm(
          'Neues Event vorbereiten?\n\nVorhandene Zusagen werden zuerst archiviert und danach werden event_signups_next.csv & ' +
          'event_responses_next.csv geleert. Das ist der manuelle Startpunkt nach einem gespielten Event.'
        );
        if (!confirmReset) return;
        const headers = state.headers.length ? state.headers : [...DEFAULT_HEADERS];
        const emptyCsv = buildCsv(headers, []);
        const responseHeaders = state.responseHeaders.length ? state.responseHeaders : [...DEFAULT_RESPONSE_HEADERS];
        const emptyResponsesCsv = buildCsv(responseHeaders, []);
        setSaving(true);
        setStatus(hasAssignments ? 'Archiviert Zusagen und leert den Pool‚Ä¶' : 'Leere event_signups_next.csv & event_responses_next.csv‚Ä¶', 'info');
        try {
          let archivePath = null;
          if (hasAssignments) {
            archivePath = buildArchivePath();
            const archiveContent = buildCurrentCsv();
            await writeFile(workerUrl, adminKey, {
              path: archivePath,
              content: archiveContent,
              branch,
              message: 'admin: archive event_signups_next.csv via event assignments ui',
            });
          }
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_signups_next.csv',
            content: emptyCsv,
            branch,
            message: 'admin: reset event_signups_next.csv via event assignments ui',
          });
          await writeFile(workerUrl, adminKey, {
            path: 'data/event_responses_next.csv',
            content: emptyResponsesCsv,
            branch,
            message: 'admin: reset event_responses_next.csv via event assignments ui',
          });
          state.assignments = [];
          state.responses = [];
          state.originalCsv = emptyCsv;
          state.originalResponseCsv = emptyResponsesCsv;
          await refreshFileCommit(branch);
          renderAssignments();
          renderResponses();
          if (hasAssignments && archivePath) {
            setStatus(`${assignmentCount} Zusagen archiviert nach ${archivePath} und Pool f√ºr das n√§chste Event geleert.`, 'ok');
          } else {
            setStatus('Keine Zusagen zum Archivieren ‚Äì Pool ist bereits leer. Antworten wurden zur√ºckgesetzt.', 'info');
          }
        } catch (err) {
          console.error(err);
          setStatus(`Fehler: Archivieren oder Leeren nicht m√∂glich (${err.message}).`, 'error');
        } finally {
          setSaving(false);
          updateSaveButtonState();
        }
        }

      async function writeFile(workerUrl, adminKey, payload) {
        const headers = shared?.buildAdminHeaders ? shared.buildAdminHeaders({
          adminKey,
          headers: { 'Content-Type': 'application/json' },
        }) : { 'Content-Type': 'application/json', 'X-Admin-Key': adminKey };
        const response = await fetch(workerUrl, { method:'POST', headers, body: JSON.stringify(payload) });
        if (!response.ok) { const text = await response.text().catch(() => ''); throw new Error(text || `HTTP ${response.status}`); }
        const result = await response.json().catch(() => ({}));
        if (result && result.ok === false) throw new Error(result.error || 'Worker-Fehler');
        return result;
      }

      function persistSettings() {
        const payload = { workerUrl: elements.workerUrl.value, branch: elements.branch.value };
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(payload));
      }
      function restoreSettings() {
        const saved = localStorage.getItem(SETTINGS_KEY);
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
            if (parsed.branch) elements.branch.value = parsed.branch;
          } catch (err) { console.warn('Settings konnten nicht gelesen werden', err); }
        } else {
          const sharedSettings = localStorage.getItem('dsro-admin-settings');
          if (sharedSettings) {
            try {
              const parsed = JSON.parse(sharedSettings);
              if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
              if (parsed.customBranch) elements.branch.value = parsed.customBranch;
              if (parsed.branchSelect) elements.branch.value = parsed.branchSelect;
            } catch (err) { console.warn('Shared settings konnten nicht gelesen werden', err); }
          }
        }
      }

      function renderAdminKeyState({ message, tone = 'info', showAlert = false } = {}) {
        if (elements.adminKeyStatus) {
          elements.adminKeyStatus.textContent = message || '';
          elements.adminKeyStatus.className = 'pill ' + (tone === 'success' ? 'info' : tone);
        }
        if (elements.adminKeyAlert) {
          elements.adminKeyAlert.style.display = showAlert ? 'grid' : 'none';
          if (showAlert && message) elements.adminKeyAlert.textContent = message;
        }
        if (elements.adminKeyFallbackRow) {
          elements.adminKeyFallbackRow.style.display = showAlert ? 'block' : 'none';
        }
      }

      function applyFallbackAdminKey(value) {
        const next = value != null ? value : (elements.adminKeyFallback?.value || '').trim();
        if (!next) {
          renderAdminKeyState({ message: 'Bitte Admin-Key eingeben.', tone: 'warn', showAlert: true });
          return false;
        }
        try {
          if (shared?.saveAdminKey) shared.saveAdminKey(next);
          renderAdminKeyState({ message: 'Admin-Key gespeichert, pr√ºfe‚Ä¶', tone: 'info', showAlert: false });
          return true;
        } catch (err) {
          console.error('admin-key: error while saving', err);
          renderAdminKeyState({ message: 'Admin-Key konnte nicht gespeichert werden.', tone: 'error', showAlert: true });
          return false;
        }
      }

      function startAdminFlow() {
        restoreSettings();
        initAutocompletes();
        reloadData();
      }

      function initEvents() {
        elements.reloadBtn.addEventListener('click', reloadData);
        elements.saveBtn.addEventListener('click', saveChanges);
        elements.addBtn.addEventListener('click', addAssignment);
        if (elements.playerInput) {
          elements.playerInput.addEventListener('input', () => {
            updatePlayerReliabilityPreview(elements.playerInput.value, 'signup');
          });
        }
        if (elements.addResponseBtn) elements.addResponseBtn.addEventListener('click', addResponse);
        if (elements.resetBtn) elements.resetBtn.addEventListener('click', resetPool);
        ['workerUrl','branch'].forEach(key => elements[key].addEventListener('change', persistSettings));
        elements.playerInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addAssignment(); } });
        if (elements.responsePlayerInput) {
          elements.responsePlayerInput.addEventListener('input', () => {
            updatePlayerReliabilityPreview(elements.responsePlayerInput.value, 'response');
          });
          elements.responsePlayerInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); addResponse(); } });
        }
        if (elements.hardOnlyToggle) {
          elements.hardOnlyToggle.addEventListener('change', () => {
            state.filters.hardOnly = elements.hardOnlyToggle.checked;
            renderAssignments();
          });
        }
      }

      shared.initAdminKeyGate({
        statusEl: elements.adminKeyStatus,
        fallbackInput: elements.adminKeyFallback,
        fallbackRow: elements.adminKeyFallbackRow,
        fallbackButton: elements.adminKeyFallbackBtn,
        alertEl: elements.adminKeyAlert,
        renderStatus: renderAdminKeyState,
        onValid: () => {
          console.debug('admin-key: success (event-assignments) ‚Äì start init');
          initEvents();
          startAdminFlow();
        },
      });
    })();
  </script>
  <script src="admin.js"></script>
</body>
</html>
