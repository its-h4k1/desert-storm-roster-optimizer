<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex, nofollow" />
  <title>Eventergebnis erfassen</title>
  <link rel="stylesheet" href="admin.css" />
  <style>
    body { margin: 0; background: var(--bg); color: var(--text); }
    .page-header { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-start; background:var(--glass); padding:1rem 1.25rem; border-bottom:1px solid var(--border); position:sticky; top:0; z-index:4; }
    .page-header h1 { margin:0; font-size:1.5rem; }
    .page-header .eyebrow { margin:0; color:var(--text-muted); font-size:0.9rem; letter-spacing:0.02em; text-transform:uppercase; }
    .page-header .meta-line { margin:0.1rem 0 0; color:var(--text-muted); font-size:0.95rem; }
    .header-meta { display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap; margin-left:auto; }
    .pill { display:inline-flex; align-items:center; gap:0.35rem; padding:0.25rem 0.6rem; border-radius:999px; font-size:0.85rem; background:var(--bg-alt); color:var(--text); border:1px solid var(--border); }
    .pill.info { background:#e0f2fe; color:#075985; border-color:#bae6fd; }
    .pill.success { background:#dcfce7; color:#14532d; border-color:#bbf7d0; }
    .pill.warn { background:#fff7ed; color:#9a3412; border-color:#fed7aa; }
    .pill.error { background:#fee2e2; color:#991b1b; border-color:#fecdd3; }
    .admin-content { width:min(1200px,100%); }
    .page-main { display:grid; gap:1rem; padding:1rem; }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius:1rem; padding:1rem; box-shadow:var(--shadow-panel,0 18px 40px rgba(15,23,42,0.08)); display:grid; gap:0.75rem; }
    .panel h2 { margin:0; }
    .controls { display:flex; flex-wrap:wrap; gap:0.75rem; align-items:flex-end; }
    label { display:flex; flex-direction:column; gap:0.35rem; font-size:0.9rem; color:var(--text-muted); }
    input[type="text"], input[type="url"], input[type="password"], input[type="number"], textarea { font:inherit; padding:0.5rem 0.65rem; border-radius:0.75rem; border:1px solid var(--border); background:var(--bg-alt); color:var(--text); min-width:12rem; }
    input:focus, textarea:focus { outline:2px solid rgba(37,99,235,0.35); outline-offset:1px; }
    button { font:inherit; border:1px solid var(--border); border-radius:0.75rem; padding:0.55rem 1rem; background:#fff; color:var(--text); cursor:pointer; display:inline-flex; align-items:center; gap:0.4rem; }
    button:hover { background:#f8fafc; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    table { width:100%; border-collapse:collapse; min-width:880px; }
    thead { background:var(--bg-alt); position:sticky; top:0; z-index:3; text-transform:uppercase; font-size:0.8rem; letter-spacing:0.04em; }
    th, td { padding:0.65rem 0.8rem; border-bottom:1px solid var(--border); text-align:left; vertical-align:top; }
    tbody tr:nth-child(2n) td { background:var(--panel-muted); }
    .table-wrapper { border:1px solid var(--border); border-radius:0.9rem; overflow:auto; box-shadow:var(--shadow-card); background:var(--panel-muted); }
    .hint { color:var(--text-muted); font-size:0.85rem; }
    .status-bar { display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center; font-size:0.9rem; color:var(--text-muted); }
    .badge { display:inline-flex; align-items:center; gap:0.35rem; padding:0.3rem 0.65rem; border-radius:999px; border:1px solid var(--border); background:var(--panel-muted); font-weight:600; font-size:0.85rem; }
    .warnings { display:grid; gap:0.35rem; }
    .warning { border:1px solid #fed7aa; background:#fff7ed; color:#9a3412; border-radius:0.85rem; padding:0.65rem 0.8rem; font-size:0.9rem; }
    .empty-state { padding:1rem; border:1px dashed var(--border); border-radius:0.9rem; text-align:center; color:var(--text-muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; }
    .success-cta { display:none; font-size:0.9rem; color:var(--text-muted); }
    .success-cta a { margin-left:0.5rem; text-decoration:none; font-weight:600; }
    .success-cta a:hover { text-decoration:underline; }
  </style>
</head>
  <body>
    <div class="admin-shell">
      <aside class="admin-sidebar">
      <div class="admin-sidebar-header">
        <div class="admin-logo">ELT Admin</div>
        <button class="sidebar-close" aria-label="Navigation schließen">✕</button>
      </div>
      <nav class="admin-nav">
        <a href="index.html">CSV &amp; Datei-Tools</a>
        <a href="events.html">Events erfassen</a>
        <a href="players.html">Spieler &amp; Aliase</a>
        <a href="absences.html">Absenzen</a>
        <a href="event-assignments.html">Event-Zusagen</a>
        <a href="noshow-dashboard.html">No-Show Analyse</a>
        <a href="reliability.html">Reliability</a>
        <a href="event-results.html" class="active">Event-Ergebnisse</a>
      </nav>
    </aside>

    <div class="admin-main">
      <header class="admin-header">
        <button class="sidebar-toggle" aria-label="Navigation öffnen">☰</button>
        <div class="page-title">
          <p>Events</p>
          <h1>Eventergebnis erfassen</h1>
        </div>
        <div class="admin-header-actions">
          <div class="admin-header-tools">
            <div class="admin-status-line">
              <span id="adminKeyState" class="pill info">Admin-Key wird geprüft…</span>
            </div>
            <details id="adminSettings" class="admin-settings">
              <summary>⚙️ Einstellungen</summary>
              <div class="admin-settings-grid">
                <label>Worker URL
                  <input id="workerUrl" type="url" value="https://ds-commit.hak1.workers.dev/write-file" spellcheck="false">
                  <small class="hint">Wird lokal gespeichert.</small>
                </label>
                <label>Branch
                  <input id="branchInput" type="text" value="main" spellcheck="false">
                </label>
                <div>
                  <div id="adminKeyFallbackRow" style="display:none;">
                    <label style="margin:0;">Admin-Key (Fallback)
                      <input id="adminKeyFallback" type="password" placeholder="Optional – zentral gespeichert" autocomplete="off">
                    </label>
                    <div class="admin-settings-actions" style="margin-top:0.35rem;justify-content:flex-start;">
                      <button id="adminKeyFallbackBtn" type="button">Admin-Key übernehmen</button>
                    </div>
                  </div>
                </div>
              </div>
            </details>
          </div>
        </div>
      </header>

      <main class="admin-content">
        <section class="admin-section" style="padding:1rem;">
          <div class="page-header">
            <div>
              <p class="eyebrow">Post-Event</p>
              <h1>Ergebnis für Event eintragen</h1>
              <p class="meta-line">Aufstellung übernehmen → Anwesenheit &amp; Punkte erfassen → Speichern via Commit-Flow.</p>
            </div>
            <div class="header-meta">
              <span id="snapshotMeta" class="badge">Kein Snapshot geladen</span>
              <span id="resultMeta" class="badge">Kein Ergebnis geladen</span>
            </div>
          </div>

          <div class="page-main">
            <section class="panel">
              <div class="controls">
                <label>Event-ID (Format DS-YYYY-MM-DD – gilt für beide Gruppen)
                  <input id="eventId" type="text" placeholder="DS-2025-01-31" autocomplete="off" spellcheck="false">
                </label>
                <div class="controls" style="gap:0.5rem;">
                  <button id="loadRosterBtn" type="button">Aufstellung übernehmen</button>
                  <button id="loadResultsBtn" type="button">Ergebnis laden</button>
                  <button id="saveBtn" type="button">Speichern</button>
                </div>
              </div>
              <div class="status-bar">
                <span id="statusText">Warte auf Aktion…</span>
                <span id="warningPill" class="pill warn" style="display:none;"></span>
                <button id="retryMirrorBtn" type="button" style="display:none;">Mirror erneut versuchen</button>
              </div>
              <div id="saveSuccessCta" class="success-cta" aria-live="polite">
                ✅ Ergebnisse gespeichert. Nächster Schritt: Zusage-Pool leeren (ab Mo 03:00).
                <a href="./event-assignments.html">→ Zur Zusagen-Seite</a>
              </div>
              <div class="warnings" id="warningList" aria-live="polite"></div>
            </section>

            <section class="panel">
              <p class="hint">Ein Ergebnisdatensatz enthält immer beide Gruppen (A &amp; B) eines Datums.</p>
              <div class="table-wrapper">
                <table>
                  <thead>
                    <tr>
                      <th>Spieler</th>
                      <th>Gruppe</th>
                      <th>Slot</th>
                      <th>Rolle</th>
                      <th>Anwesend</th>
                      <th>Punkte</th>
                      <th>Notiz</th>
                    </tr>
                  </thead>
                  <tbody id="resultTableBody">
                    <tr><td colspan="7" class="empty-state">Noch keine Aufstellung geladen.</td></tr>
                  </tbody>
                </table>
              </div>
            </section>
          </div>
        </section>
      </main>
    </div>
  </div>

  <script src="../shared.js"></script>
  <script>
    (function(){
      const shared = window.dsroShared || {};
      const $ = (sel) => document.querySelector(sel);
      const elements = {
        eventId: $('#eventId'),
        workerUrl: $('#workerUrl'),
        branchInput: $('#branchInput'),
        adminKeyFallback: $('#adminKeyFallback'),
        adminKeyFallbackBtn: $('#adminKeyFallbackBtn'),
        adminKeyFallbackRow: $('#adminKeyFallbackRow'),
        adminSettings: $('#adminSettings'),
        loadRosterBtn: $('#loadRosterBtn'),
        loadResultsBtn: $('#loadResultsBtn'),
        saveBtn: $('#saveBtn'),
        retryMirrorBtn: $('#retryMirrorBtn'),
        statusText: $('#statusText'),
        warningPill: $('#warningPill'),
        warningList: $('#warningList'),
        tableBody: $('#resultTableBody'),
        snapshotMeta: $('#snapshotMeta'),
        resultMeta: $('#resultMeta'),
        adminKeyState: $('#adminKeyState'),
        saveSuccessCta: $('#saveSuccessCta'),
      };

      const openAdminSettings = () => {
        if (elements.adminSettings) elements.adminSettings.open = true;
      };
      const closeAdminSettings = () => {
        if (elements.adminSettings) elements.adminSettings.open = false;
      };

      const STORAGE_KEY = 'dsro-event-results-admin';
      const EVENT_RE = /^DS-\d{4}-\d{2}-\d{2}$/i;
      const state = {
        rosterRows: [],
        savedResults: [],
        savedResultsMap: new Map(),
        invalidRosterRows: [],
        invalidSavedExtras: [],
        latestSnapshotMeta: '',
        resultMeta: '',
        loading: false,
        saving: false,
        lastSave: null,
        saveBlockedReason: '',
      };

      function refreshSaveButton() {
        if (!elements.saveBtn) return;
        elements.saveBtn.disabled = state.saving || !!state.saveBlockedReason;
        elements.saveBtn.title = state.saveBlockedReason || '';
      }

      function setStatus(text, tone = 'muted') {
        if (elements.statusText) {
          elements.statusText.textContent = text;
          elements.statusText.className = tone === 'error' ? 'error' : tone === 'success' ? 'success' : '';
        }
        if (elements.saveSuccessCta) {
          elements.saveSuccessCta.style.display = tone === 'success' ? 'block' : 'none';
        }
      }

      function setWarningBanner(message) {
        if (!elements.warningPill) return;
        if (message) {
          elements.warningPill.textContent = message;
          elements.warningPill.style.display = 'inline-flex';
        } else {
          elements.warningPill.style.display = 'none';
        }
      }

      function addWarning(message) {
        if (!elements.warningList) return;
        const div = document.createElement('div');
        div.className = 'warning';
        div.textContent = message;
        elements.warningList.appendChild(div);
      }

      function clearWarnings() {
        if (!elements.warningList) return;
        elements.warningList.innerHTML = '';
      }

      function setMirrorRetryVisible(visible) {
        if (!elements.retryMirrorBtn) return;
        elements.retryMirrorBtn.style.display = visible ? 'inline-flex' : 'none';
      }

      function validateEventId(raw) {
        if (!raw) return '';
        const trimmed = raw.trim().toUpperCase();
        return EVENT_RE.test(trimmed) ? trimmed : '';
      }

      function applyMeta(el, text, tone = 'muted') {
        if (!el) return;
        el.textContent = text;
        el.className = `badge ${tone}`.trim();
      }

      function loadSettings() {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            if (parsed.workerUrl) elements.workerUrl.value = parsed.workerUrl;
            if (parsed.branch) elements.branchInput.value = parsed.branch;
            if (parsed.eventId) elements.eventId.value = parsed.eventId;
          } catch (err) {
            console.warn('Settings konnten nicht gelesen werden', err);
          }
        } else {
          const sharedSettings = shared.readSharedAdminSettings ? shared.readSharedAdminSettings() : null;
          if (sharedSettings) {
            if (sharedSettings.workerUrl) elements.workerUrl.value = sharedSettings.workerUrl;
            if (sharedSettings.customBranch) elements.branchInput.value = sharedSettings.customBranch;
            if (sharedSettings.branchSelect) elements.branchInput.value = sharedSettings.branchSelect;
          }
        }
        shared.applyAdminKeyInput?.(elements.adminKeyFallback, { syncOnInput: false });
      }

      function persistSettings() {
        try {
          const payload = {
            workerUrl: elements.workerUrl.value,
            branch: elements.branchInput.value,
            eventId: elements.eventId.value,
          };
          localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        } catch (err) {
          console.warn('Settings konnten nicht gespeichert werden', err);
        }
      }

      function derivePlayerKey(name) {
        const aliasMap = shared.aliasMap instanceof Map ? shared.aliasMap : null;
        const canonical = shared.canonicalNameJS ? shared.canonicalNameJS(name || '') : (name || '').toLowerCase();
        return aliasMap?.get(canonical) || canonical;
      }

      function buildRosterRows(payload) {
        const rows = [];
        if (!payload) return rows;
        shared.prepareAliasMapFromPayload?.(payload);
        const add = (list, group, slot) => {
          (list || []).forEach((entry, idx) => {
            const rawName = entry?.name || entry?.raw_name || `#${idx + 1}`;
            const display = shared.resolvePlayerDisplayName ? shared.resolvePlayerDisplayName(rawName) : rawName;
            rows.push({
              player_key: (derivePlayerKey(rawName) || '').trim(),
              display_name: display,
              display_name_snapshot: display,
              slot,
              group,
              role: entry?.role || slot,
            });
          });
        };
        add(payload?.team_a?.start, 'A', 'Start');
        add(payload?.team_a?.subs, 'A', 'Sub');
        add(payload?.team_b?.start, 'B', 'Start');
        add(payload?.team_b?.subs, 'B', 'Sub');
        return rows;
      }

      function mapResultsByKey(results = []) {
        const map = new Map();
        results.forEach((entry) => {
          const key = (entry?.player_key || '').trim();
          if (!key) return;
          map.set(key, entry);
        });
        return map;
      }

      function renderWarnings(rows) {
        clearWarnings();
        const rosterRows = state.rosterRows.filter((row) => row.player_key);
        const duplicateKeys = rosterRows.reduce((acc, row) => {
          acc[row.player_key] = (acc[row.player_key] || 0) + 1;
          return acc;
        }, {});
        const dupes = Object.entries(duplicateKeys).filter(([, count]) => count > 1).map(([key]) => key);
        if (dupes.length) {
          addWarning(`Doppelte Spieler-Schlüssel im Roster: ${dupes.join(', ')}`);
          setWarningBanner('Duplikate erkannt');
        } else {
          setWarningBanner('');
        }

        if (state.invalidRosterRows.length) {
          const examples = state.invalidRosterRows.slice(0, 3).map((row) => row.display_name || row.slot || 'Unbekannt');
          addWarning(`Roster fehlerhaft: ${state.invalidRosterRows.length} Einträge ohne player_key (${examples.join(', ')}). Alias/Name korrigieren, sonst kann No-Show nicht gezählt werden.`);
        }

        const missing = rosterRows.filter((row) => !state.savedResultsMap.has(row.player_key));
        if (missing.length && state.savedResults.length) {
          addWarning(`Roster-Spieler fehlen im geladenen Ergebnis: ${missing.length}. Bitte prüfen.`);
        }

        const invalidExtras = state.invalidSavedExtras || [];
        if (invalidExtras.length) {
          addWarning(`Ungültige gespeicherte Einträge ohne player_key: ${invalidExtras.length} (werden ignoriert).`);
        }

        const extra = state.savedResults.filter((entry) => entry.player_key && !rosterRows.some((row) => row.player_key === entry.player_key));
        if (extra.length) {
          addWarning(`${extra.length} gespeicherte Einträge nicht im aktuellen Roster gefunden.`);
        }
      }

      function renderTable() {
        if (!elements.tableBody) return;
        elements.tableBody.innerHTML = '';
        const rows = [];
        const seen = new Set();
        const invalidExtras = [];
        state.rosterRows.forEach((row) => {
          const saved = state.savedResultsMap.get(row.player_key) || {};
          rows.push({ ...row, attended: !!saved.attended, points: Number(saved.points) || 0, note: saved.note || '' });
          seen.add(row.player_key);
        });
        state.savedResults.forEach((entry) => {
          if (seen.has(entry.player_key)) return;
          if (!entry.player_key) {
            invalidExtras.push(entry);
            return;
          }
          rows.push({
            player_key: (entry.player_key || '').trim(),
            display_name: entry.display_name_snapshot || entry.display_name || entry.name || entry.player_key,
            display_name_snapshot: entry.display_name_snapshot || entry.display_name || entry.name || entry.player_key,
            group: entry.group || entry.team || '–',
            slot: entry.slot || entry.role || 'n/a',
            role: entry.role || entry.slot || '',
            attended: !!entry.attended,
            points: Number(entry.points) || 0,
            note: entry.note || '',
          });
        });

        if (!rows.length) {
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 7;
          td.className = 'empty-state';
          td.textContent = 'Noch keine Aufstellung geladen.';
          tr.appendChild(td);
          elements.tableBody.appendChild(tr);
          return;
        }

        rows.forEach((row) => {
          const tr = document.createElement('tr');
          tr.dataset.playerKey = row.player_key;
          tr.dataset.displayName = row.display_name_snapshot || row.display_name;
          tr.dataset.slot = row.slot;
          tr.dataset.group = row.group;
          tr.dataset.role = row.role;

          const cells = [
            row.display_name_snapshot || row.display_name || row.player_key,
            row.group,
            row.slot,
            row.role,
          ];
          cells.forEach((text) => {
            const td = document.createElement('td');
            td.textContent = text || '';
            td.className = 'mono';
            tr.appendChild(td);
          });

          const attendedTd = document.createElement('td');
          const attendedInput = document.createElement('input');
          attendedInput.type = 'checkbox';
          attendedInput.checked = !!row.attended;
          attendedInput.className = 'attended';
          attendedTd.appendChild(attendedInput);
          tr.appendChild(attendedTd);

          const pointsTd = document.createElement('td');
          const pointsInput = document.createElement('input');
          pointsInput.type = 'number';
          pointsInput.min = '0';
          pointsInput.step = '1';
          pointsInput.value = Number.isFinite(row.points) ? row.points : 0;
          pointsInput.className = 'points';
          pointsTd.appendChild(pointsInput);
          tr.appendChild(pointsTd);

          const noteTd = document.createElement('td');
          const noteInput = document.createElement('textarea');
          noteInput.value = row.note || '';
          noteInput.rows = 2;
          noteInput.className = 'note';
          noteTd.appendChild(noteInput);
          tr.appendChild(noteTd);

          elements.tableBody.appendChild(tr);
        });

        state.invalidSavedExtras = invalidExtras;
        renderWarnings(rows);
        refreshSaveButton();
      }

      async function fetchLatest() {
        const url = shared.buildLatestJsonUrl ? shared.buildLatestJsonUrl({ cacheBuster: `?v=${Date.now()}` }) : 'out/latest.json';
        return shared.fetchJsonWithErrors ? shared.fetchJsonWithErrors(url) : (await fetch(url)).json();
      }

      async function handleLoadRoster() {
        const eventId = validateEventId(elements.eventId.value);
        if (!eventId) {
          setStatus('Ungültige Event-ID. Format: DS-YYYY-MM-DD', 'error');
          return;
        }
        setStatus('Lade Aufstellung aus latest.json…');
        state.loading = true;
        try {
          const payload = await fetchLatest();
          state.rosterRows = buildRosterRows(payload);
          state.invalidRosterRows = state.rosterRows.filter((row) => !(row.player_key || '').trim());
          state.saveBlockedReason = state.invalidRosterRows.length
            ? 'Roster enthält Einträge ohne player_key. Alias korrigieren.'
            : '';
          state.latestSnapshotMeta = payload?.generated_at || 'latest.json';
          applyMeta(elements.snapshotMeta, `Aufstellung A + B: ${state.rosterRows.length} Spieler · ${state.latestSnapshotMeta}`);
          renderTable();
          setStatus('Aufstellung übernommen.', 'success');
        } catch (err) {
          console.error(err);
          setStatus(`Konnte latest.json nicht laden: ${err.message}`, 'error');
        } finally {
          state.loading = false;
          persistSettings();
        }
      }

      async function handleLoadResults() {
        const eventId = validateEventId(elements.eventId.value);
        if (!eventId) {
          setStatus('Ungültige Event-ID. Format: DS-YYYY-MM-DD', 'error');
          return;
        }
        setStatus('Lade gespeichertes Ergebnis…');
        state.loading = true;
        try {
          const base = shared.computeSiteRoot ? shared.computeSiteRoot(location.pathname) : './';
          const url = `${base}data/event_results/${eventId}.json?v=${Date.now()}`;
          const resultJson = await (shared.fetchJsonWithErrors ? shared.fetchJsonWithErrors(url) : (await fetch(url)).json());
          const entries = Array.isArray(resultJson) ? resultJson : Array.isArray(resultJson?.results) ? resultJson.results : [];
          state.savedResults = entries.map((entry) => ({ event_id: eventId, ...entry }));
          state.invalidSavedExtras = state.savedResults.filter((entry) => !(entry.player_key || '').trim());
          state.savedResultsMap = mapResultsByKey(state.savedResults);
          state.resultMeta = resultJson?.generated_at || 'geladen';
          applyMeta(elements.resultMeta, `Ergebnis geladen @ ${state.resultMeta}`, 'success');
          renderTable();
          setStatus(`${entries.length} Einträge geladen.`, 'success');
        } catch (err) {
          console.error(err);
          state.savedResults = [];
          state.savedResultsMap = new Map();
          applyMeta(elements.resultMeta, 'Kein Ergebnis gefunden', 'warn');
          renderTable();
          setStatus(`Ergebnis konnte nicht geladen werden (${err.message}).`, 'error');
        } finally {
          state.loading = false;
          persistSettings();
        }
      }

      function collectResults() {
        if (!elements.tableBody) return [];
        const rows = Array.from(elements.tableBody.querySelectorAll('tr'));
        return rows.map((row) => {
          const playerKey = (row.dataset.playerKey || '').trim();
          if (!playerKey) return null;
          const attended = !!(row.querySelector('input.attended')?.checked ?? false);
          const pointsVal = parseInt(row.querySelector('input.points')?.value, 10);
          const points = Number.isFinite(pointsVal) ? pointsVal : 0;
          const note = row.querySelector('textarea.note')?.value || '';
          return {
            event_id: validateEventId(elements.eventId.value) || '',
            player_key: playerKey,
            display_name_snapshot: row.dataset.displayName || row.dataset.playerKey,
            slot: row.dataset.slot || '',
            group: row.dataset.group || '',
            role: row.dataset.role || '',
            attended,
            points,
            note,
          };
        }).filter(Boolean);
      }

      function describeWorkerError(err) {
        if (!err) return 'Unbekannter Fehler';
        const parts = [];
        const message = err?.message || '';
        if (message) parts.push(message);
        if (err?.status) parts.push(`Status: ${err.status}`);
        const detail = err?.responseText || err?.body;
        if (detail && detail !== message) {
          parts.push(`Antwort: ${String(detail).slice(0, 280)}`);
        }
        return parts.filter(Boolean).join(' · ');
      }

      async function sendWorkerRequest({ payload, workerUrl }) {
        const headers = shared.buildAdminHeaders ? shared.buildAdminHeaders({
          adminKey: shared.getAdminKey?.(),
          headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
        }) : { 'Content-Type': 'application/json', Accept: 'application/json', 'X-Admin-Key': shared.getAdminKey?.() };
        let res;
        try {
          res = await fetch(workerUrl, {
            method: 'POST',
            headers,
            body: JSON.stringify(payload),
            mode: 'cors',
          });
        } catch (err) {
          const error = new Error(err?.message || 'Netzwerkfehler');
          error.cause = err;
          throw error;
        }
        const responseText = await res.text().catch(() => '');
        let parsed = null;
        try {
          parsed = responseText ? JSON.parse(responseText) : null;
        } catch (err) {
          parsed = null;
        }
        const workerOk = parsed ? parsed.ok !== false : true;
        if (!res.ok || !workerOk) {
          const error = new Error((parsed && (parsed.error || parsed.detail)) || responseText || `HTTP ${res.status}`);
          error.status = res.status;
          error.responseText = responseText;
          error.responseJson = parsed;
          throw error;
        }
        return parsed || {};
      }

      async function writeFilesAtomic({ files, workerUrl, message }) {
        const payload = {
          files: files.map((file) => ({ path: file.path, content: file.content })),
          branch: files[0]?.branch,
          message: message || files[0]?.message || 'admin: commit files',
        };
        return sendWorkerRequest({ payload, workerUrl });
      }

      async function writeSingleFile({ file, workerUrl }) {
        return sendWorkerRequest({ payload: file, workerUrl });
      }

      async function handleMirrorRetry() {
        const last = state.lastSave;
        if (!last) {
          addWarning('Kein vorheriger Save vorhanden. Bitte erneut speichern.');
          return;
        }
        setStatus('Mirror wird erneut geschrieben…');
        setMirrorRetryVisible(false);
        clearWarnings();
        try {
          const mirrorFile = {
            path: `docs/data/event_results/${last.eventId}.json`,
            branch: last.branch,
            message: `admin: mirror event results ${last.eventId}`,
            content: last.content,
          };
          await writeSingleFile({ file: mirrorFile, workerUrl: last.workerUrl });
          setStatus('Mirror aktualisiert.', 'success');
          applyMeta(elements.resultMeta, `Mirror aktualisiert @ ${new Date().toLocaleString()}`, 'success');
        } catch (err) {
          console.error('Mirror-Retry fehlgeschlagen', err);
          addWarning(`Mirror erneut fehlgeschlagen: ${describeWorkerError(err)}`);
          setStatus('Mirror erneut fehlgeschlagen – bitte Worker/Logs prüfen.', 'error');
          setMirrorRetryVisible(true);
        }
      }

      function normalizeEventResultsIndex(rawIndex) {
        const ids = Array.isArray(rawIndex)
          ? rawIndex
          : Array.isArray(rawIndex?.event_ids)
            ? rawIndex.event_ids
            : [];
        const unique = new Set();
        ids.forEach((id) => {
          if (typeof id === 'string' && id.trim()) {
            unique.add(id.trim());
          }
        });
        return Array.from(unique).sort((a, b) => b.localeCompare(a));
      }

      async function fetchEventResultsIndex() {
        const url = `../data/event_results/index.json?v=${Date.now()}`;
        try {
          const response = await fetch(url, { cache: 'no-store' });
          if (response.status === 404) return null;
          if (!response.ok) throw new Error(`Index HTTP ${response.status}`);
          const data = await response.json();
          return normalizeEventResultsIndex(data);
        } catch (err) {
          console.warn('Event-Results-Index konnte nicht geladen werden', err);
          return null;
        }
      }

      function updateEventResultsIndex(ids, eventId) {
        const next = new Set(Array.isArray(ids) ? ids : []);
        next.add(eventId);
        return Array.from(next).sort((a, b) => b.localeCompare(a));
      }

      async function handleSave() {
        const eventId = validateEventId(elements.eventId.value);
        if (!eventId) {
          setStatus('Ungültige Event-ID. Format: DS-YYYY-MM-DD', 'error');
          return;
        }
        const adminKey = shared.getAdminKey ? shared.getAdminKey() : '';
        if (!adminKey) {
          setStatus('Kein Admin-Key gesetzt – bitte einloggen.', 'error');
          renderAdminKeyState({ message: 'Kein Admin-Key gesetzt.', tone: 'warn', showAlert: true });
          return;
        }
        const workerUrl = (elements.workerUrl.value || '').trim();
        if (!workerUrl) {
          setStatus('Worker-URL fehlt.', 'error');
          return;
        }
        clearWarnings();
        if (state.invalidRosterRows.length) {
          const examples = state.invalidRosterRows.slice(0, 3).map((row) => row.display_name || row.slot || 'Unbekannt');
          state.saveBlockedReason = 'Roster enthält Einträge ohne player_key.';
          refreshSaveButton();
          addWarning(`Speichern blockiert: ${state.invalidRosterRows.length} Roster-Einträge ohne player_key (${examples.join(', ')}). Alias/Name korrigieren.`);
          setStatus('Speichern blockiert: Roster-Einträge ohne player_key.', 'error');
          return;
        }
        const results = collectResults();
        if (!results.length) {
          setStatus('Keine Daten zum Speichern.', 'error');
          return;
        }

        const rosterKeys = new Set(state.rosterRows.map((r) => (r.player_key || '').trim()).filter(Boolean));
        const resultKeys = new Set(results.map((entry) => (entry.player_key || '').trim()).filter(Boolean));
        const missingKeys = Array.from(rosterKeys).filter((key) => !resultKeys.has(key));
        if (missingKeys.length) {
          const displayNames = state.rosterRows
            .filter((row) => missingKeys.includes(row.player_key))
            .map((row) => row.display_name || row.player_key)
            .slice(0, 10);
          const listText = displayNames.join(', ') + (missingKeys.length > displayNames.length ? ', …' : '');
          setStatus('Speichern blockiert: Roster-Spieler fehlen im Ergebnis.', 'error');
          addWarning(`Speichern blockiert: ${missingKeys.length} Roster-Spieler fehlen im Ergebnis (player_key mismatch/leer). (${listText})`);
          return;
        }

        const resultMap = new Map(results.map((entry) => [(entry.player_key || '').trim(), entry]));
        const invalidAttendance = Array.from(rosterKeys).filter((key) => typeof resultMap.get(key)?.attended !== 'boolean');
        if (invalidAttendance.length) {
          const names = state.rosterRows
            .filter((row) => invalidAttendance.includes(row.player_key))
            .map((row) => row.display_name || row.player_key)
            .slice(0, 10);
          setStatus('Speichern blockiert: Attendance nicht gesetzt/ungültig.', 'error');
          addWarning(`Speichern blockiert: Attendance nicht gesetzt/ungültig für ${invalidAttendance.length} Spieler. (${names.join(', ')})`);
          return;
        }
        let handledError = false;
        const branch = (elements.branchInput.value || 'main').trim() || 'main';
        const content = JSON.stringify({
          event_id: eventId,
          generated_at: new Date().toISOString(),
          results,
        }, null, 2);
        const baseFile = {
          path: `data/event_results/${eventId}.json`,
          branch,
          message: `admin: update event results ${eventId}`,
          content,
        };
        const mirrorFile = {
          path: `docs/data/event_results/${eventId}.json`,
          branch,
          message: `admin: mirror event results ${eventId}`,
          content,
        };
        const indexIds = await fetchEventResultsIndex();
        const indexFiles = [];
        if (indexIds !== null) {
          const nextIndex = updateEventResultsIndex(indexIds, eventId);
          const indexContent = JSON.stringify({ event_ids: nextIndex }, null, 2);
          indexFiles.push({
            path: 'data/event_results/index.json',
            branch,
            message: `admin: update event results index ${eventId}`,
            content: indexContent,
          });
          indexFiles.push({
            path: 'docs/data/event_results/index.json',
            branch,
            message: `admin: mirror event results index ${eventId}`,
            content: indexContent,
          });
        } else {
          addWarning('Event-Results-Index konnte nicht aktualisiert werden.');
          setStatus('Index konnte nicht geladen werden – Ergebnis wird ohne Index gespeichert.', 'warn');
        }
        const commitMessage = `admin: update event results ${eventId} (ssot + mirror)`;
        state.lastSave = {
          eventId,
          branch,
          content,
          workerUrl,
        };
        state.saving = true;
        setStatus('Speichere Ergebnis via Worker…');
        try {
          clearWarnings();
          setMirrorRetryVisible(false);
          const files = [baseFile, mirrorFile, ...indexFiles];
          try {
            await writeFilesAtomic({ files, workerUrl, message: commitMessage });
            setStatus('Ergebnis gespeichert & Mirror aktualisiert.', 'success');
          } catch (atomicErr) {
            console.warn('Batch-Commit fehlgeschlagen, versuche sequenziell', atomicErr);
            let ssotWritten = false;
            try {
              await writeSingleFile({ file: baseFile, workerUrl });
              ssotWritten = true;
              if (indexFiles[0]) {
                try {
                  await writeSingleFile({ file: indexFiles[0], workerUrl });
                } catch (indexErr) {
                  const msg = describeWorkerError(indexErr);
                  addWarning(`SSOT Index konnte nicht gespeichert werden: ${msg}`);
                }
              }
            } catch (ssotErr) {
              const msg = describeWorkerError(ssotErr);
              addWarning(`SSOT konnte nicht gespeichert werden: ${msg}`);
              throw ssotErr;
            }
            try {
              await writeSingleFile({ file: mirrorFile, workerUrl });
              if (indexFiles[1]) {
                try {
                  await writeSingleFile({ file: indexFiles[1], workerUrl });
                } catch (indexErr) {
                  const msg = describeWorkerError(indexErr);
                  addWarning(`Mirror Index konnte nicht gespeichert werden: ${msg}`);
                }
              }
              setStatus('Ergebnis gespeichert & Mirror aktualisiert.', 'success');
            } catch (mirrorErr) {
              const msg = describeWorkerError(mirrorErr);
              addWarning(`SSOT gespeichert, Mirror fehlgeschlagen: ${msg}`);
              setStatus('SSOT gespeichert, Mirror fehlgeschlagen – bitte erneut versuchen.', 'error');
              applyMeta(elements.resultMeta, 'SSOT gespeichert, Mirror fehlt', 'warn');
              setMirrorRetryVisible(true);
              state.savedResults = results;
              state.savedResultsMap = mapResultsByKey(results);
              renderTable();
              handledError = true;
              throw mirrorErr;
            }
          }
          applyMeta(elements.resultMeta, `Gespeichert @ ${new Date().toLocaleString()}`, 'success');
          state.savedResults = results;
          state.savedResultsMap = mapResultsByKey(results);
          renderTable();
        } catch (err) {
          console.error(err);
          openAdminSettings();
          if (!handledError) {
            setStatus(`Speichern fehlgeschlagen: ${err.message}`, 'error');
          }
        } finally {
          state.saving = false;
          refreshSaveButton();
          persistSettings();
        }
      }

      function renderAdminKeyState({ message, tone = 'info', showAlert = false } = {}) {
        if (!elements.adminKeyState) return;
        elements.adminKeyState.textContent = message;
        elements.adminKeyState.className = `pill ${tone}`.trim();
        if (elements.adminKeyFallbackRow) {
          elements.adminKeyFallbackRow.style.display = showAlert ? 'block' : 'none';
        }
        if (showAlert) {
          openAdminSettings();
        } else if (tone === 'success') {
          closeAdminSettings();
        }
      }

      function initEvents() {
        elements.loadRosterBtn?.addEventListener('click', handleLoadRoster);
        elements.loadResultsBtn?.addEventListener('click', handleLoadResults);
        elements.saveBtn?.addEventListener('click', handleSave);
        elements.retryMirrorBtn?.addEventListener('click', handleMirrorRetry);
        ['workerUrl', 'branchInput', 'eventId'].forEach((key) => {
          elements[key]?.addEventListener('change', persistSettings);
        });
      }

      function initAdminGate() {
        shared.initAdminKeyGate?.({
          statusEl: elements.adminKeyState,
          fallbackInput: elements.adminKeyFallback,
          fallbackButton: elements.adminKeyFallbackBtn,
          fallbackRow: elements.adminKeyFallbackRow,
          settingsToggle: elements.adminSettings,
          onValid: () => {
            renderAdminKeyState({ message: 'Admin-Key ist gesetzt (zentral).', tone: 'success' });
          },
          renderStatus: renderAdminKeyState,
        });
      }

      function init() {
        loadSettings();
        initEvents();
        initAdminGate();
      }

      document.addEventListener('DOMContentLoaded', init);
    })();
  </script>
  <script src="admin.js"></script>
</body>
</html>
